{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/SORT/Prev Sem/COS3711/Drive/COS3711/Exam Papers/Memo/2015_Oct_M.pdf","text":"file:///C/Users/KRIB/Dropbox/COS3711%20-%20Advanced%20Programming/2016/S2/Memos/2015_Oct_M.txt[10/12/2016 11:08:15 PM] oct / nov 2015 question 1 class Register : public Qobject { Q_OBJECT public: Register(){} void newRegister(QString str) { m_Register = str; emit setRegister(m_Register); } signals: setRegister(QString str); private: QString m_Register; }; class Output : public Qobject{ Q_OBJECT public: Output(){} public slots: void outputRegister(QString str) { cout << str <<endl; } }; //main Register r; r.newRegister(\"E234\") Output o; QObject::connect(&r,SIGNAL(setRegister(QString())), &o, SLOT((outputRegister(QString)))) 1.2 not sure: ^\\d{4}\\-(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])$ file:///C/Users/KRIB/Dropbox/COS3711%20-%20Advanced%20Programming/2016/S2/Memos/2015_Oct_M.txt[10/12/2016 11:08:15 PM] question 2 2.1 class Shape : public QObject Q_OBJECT Q_PROPERTY(int len, READ getLength WRITE setLength) public: //getters int getLength() const{return length;} //setters void setLength(int l){length = l;} //the rest functions come here as in the question }; class Circle : public Shape { Q_OBJECT public: //everything remains the same. }; 2.2 void whatAmI(Shape *s) { cout << s->metatObject()->className() << endl; } 2.3 yes it is legal, Sets the value of the object's name property to value. If the property is defined in the class using Q_PROPERTY then true is returned on success and false otherwise. If the property is not defined using Q_PROPERTY, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned. 2.4 No legal, there are property defined int the class Circle or Shape with the value \"Colour\", hence will not work. file:///C/Users/KRIB/Dropbox/COS3711%20-%20Advanced%20Programming/2016/S2/Memos/2015_Oct_M.txt[10/12/2016 11:08:15 PM] 2.5 meta-object : The meta-object system is based on three things: The QObject class provides a base class for objects that can take advantage of the meta-object system. The Q_OBJECT macro inside the private section of the class declaration is used to enable meta-object features, such as dynamic properties, signals, and slots. The Meta-Object Compiler (moc) supplies each QObject subclass with the necessary code to implement meta-object features. The moc tool reads a C++ source file. If it finds one or more class declarations that contain the Q_OBJECT macro, it produces another C++ source file which contains the meta-object code for each of those classes. This generated source file is either #include'd into the class's source file or, more usually, compiled and linked with the class's implementation. question 3 3.1 line 2 - QListView *view = new QListView() line3 - view->setModel(model) line 4 - not sure but i would write like this model->data(model->index(row,col), Qt::DisplayRole) line 5 - model->setData(model->index(row),data) 3.2 QModelIndex - The QModelIndex class is used to locate data in a data model. 3.3 this generic, so it will apply to all, the difference between, a model and view - This class is used as an index into item models derived from QAbstractItemModel. The index is used by item views, delegates, and selection models to locate an item in the model. 3.3 Model The model typically is the data of your application and the logic to retrieve and persist that data. Often, this is a domain model that can be based on a database or the results from web services. In some cases, that domain model maps perfectly to what you see on the screen, but in other cases it has to be adapted, aggregated or extended to be usable. View The View was responsible for drawing the UI on the screen. Without windows or controls, that meant drawing, boxes, buttons, input fields, etc on the screen. The View can also monitor the model and display any data in it or update itself if the data changes. Controller The controller is responsible for handling the User Input and then updating the Model or the View. So if the user is interacts with the application, IE: presses a button on the keyboard, moves the mouse, the controller is notified of that user gesture and decides what to do with it. Maybe it should update the view, maybe it should update the model. question 4 4.1 4.2 file:///C/Users/KRIB/Dropbox/COS3711%20-%20Advanced%20Programming/2016/S2/Memos/2015_Oct_M.txt[10/12/2016 11:08:15 PM] a) intergrity of data is maintained- by decoupling we ensure all creations InputField are given to the Factory, hence we ensure that no tempering of the main data,responsibilty of classes are maintained. b) debugging - debuging for errors becomes easier becuase code are seprated //you can google the advatngeous of a factory pattern, they will apply to this question as well question 5 5.1 Solo *s = Solo::instance(); 5.2 line1 // you cannot create an instance of S, because the construtor is private line 2 // s1 cannot be created because the constructor is private, and to create an instance we need to call the fun in the form of Solo *s2 = Solo::instance(), which has not been used in the code above. 5.3 to ensure once a Solo is initialized the first time it will not be initialzed again, that is subsequently if the user tries to create another instance, it will check if it has been initializwd if yes, then return not initialized else return new Solo object, to achieve only once initialization we need to make static. 5.4 question 6 not applicable to your examination preparation question 7 7.1 In SAX, events are triggered when the XML is being parsed. When the parser is parsing the XML, and encounters a tag starting (e.g. <something>), then it triggers the tagStarted event (actual name of event might differ). Similarly when the end of the tag is met while parsing (</something>), it triggers tagEnded. Using a SAX parser implies you need to handle these events and make sense of the data returned with each event. In DOM, there are no events triggered while parsing. The entire XML is parsed and a DOM tree (of the nodes in the XML) is generated and returned. Once parsed, the user can navigate the tree to access the various data previously embedded in the various nodes in the XML. In general, DOM is easier to use but has an overhead of parsing the entire XML before you can start using it. 7.2 you have to add the following siganls: file:///C/Users/KRIB/Dropbox/COS3711%20-%20Advanced%20Programming/2016/S2/Memos/2015_Oct_M.txt[10/12/2016 11:08:15 PM] void show(); void run() { (for int i=0; i < 10; i++){ cout << \"im walking\" << endl; wait(2000); emit show(); } } //then in startwaliking() connect(this,SIGNAL(show), this,SLOT(startWalking())); start(); 7.3 QTcpSocket or QTcpServer END===========","libVersion":"0.2.3","langs":""}