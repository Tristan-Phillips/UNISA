{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Tutorial Letters/COS3711 2022 TL105 myUnisa.pdf","text":"COS3711/105/2022 Tutorial letter 105/2021 Advanced Programming COS3711 Year module School of Computing IMPORTANT INFORMATION: This document contains material from the online lessons from myUnisa. COS3711/105/2022 2 CONTENTS Page 1 Introduction 3 2 Welcome page 3 3 Module Orientation 5 4 Lesson 1 – Libraries 10 5 Lesson 2 – Meta-Objects, Properties and Reflective Programming 12 6 Lesson 3 – Models and Views 14 7 Assignment 1 Notes 16 8 Lesson 4 – Validation and Regular Expressions 17 9 Lesson 5 – Parsing XML 18 10 Lesson 6 – More Design Patterns 23 11 Assignment 2 Notes 30 12 Lesson 7 – Concurrency 31 13 Lesson 8 – Networking and Cloud Computing 34 14 Assignment 3 Notes 36 COS3711/105/2022 3 1 Introduction Dear student As noted in tutorial letter TL101, this is a fully online module, and therefore your module study material is available on myUnisa. However, in order to support you in your learning process, I also provide the study material in PDF format (apart from the additional material which will only be found online). Below you will find all the material that is available on the COS3711 site on myUnisa. 2 Welcome page COS3711 - Advanced Programming Welcome to COS3711 – a module on advanced programming concepts – from your lecturer, Dr Colin Pilkington. Major concepts The major concepts you will learn include: • Using libraries • Understanding and implementing design patterns (there are many design patterns, and you will focus on only a few this year) • XML parsing • Validating input • Reflective programming • Concurrency using threads and processes • Network programming • Cloud computing Assumed background knowledge It is assumed that you are proficient in the following skills (which you should have gained in your previous studies): • C++: creating classes and objects, inheritance and polymorphism, pointers, templates, reading from and writing to files, .h and .cpp file usage, and the use of public/protected/private • Qt: console and GUI applications, signals and slots, Qt container classes • Understanding UML diagrams • Design patterns: understanding of some design patterns such as Composite, Observer, Serializer, Flyweight, Monostate, and Command Assessment You will be assessed in various ways in this module. The 3 assignments are practical assignments, and you will have to design, code, compile, and run applications in preparation for submission. The exam, however, is a written exam (with no practical component), and you will be expected to understand the theory behind what you are doing, as well as writing code to implement concepts. You will continue using the Qt framework that was used in COS2614. We trust that you will enjoy this semester as you extend your C++ skills. Your responsibility A quick note about your responsibility as a student: you need to work through the prescribed textbook, tutorial letters and lessons, do all the exercises, and also do all the assignments – both the parts that are submitted for marking and the self-assessment parts. This will not guarantee success, but without it, it will be very difficult to pass. COS3711/105/2022 4 Checking in with the technology In order to get started on this journey together, we need to make sure that you know what tools we will be using throughout the semester: • Welcome page: This is the page you are currently on, and you will always start on this landing page of the myUnisa site. • Announcements are added regularly, so please keep checking these. • Discussions: This page is provided for you to discuss module-related topics with each other. • Additional Resources: Here you will find further tutorial letters, videos, and supplementary material needed for the module. • Official Study Material is where you will find past exams and some official tutorial letters. • The Calendar will remind you of important current events and information. • Lessons: This is where you will find all the work for this semester, including what has to be studied and extra notes. Contacting us Please feel free to contact me if you need help, and I look forward to guiding you through your studies this semester. Please also check on my availability on the Osprey server (http://osprey.unisa.ac.za/reg.htm). Take a look at the comic strip below that provides some guidelines when contacting me. Our equivalent of a T.A. is an e-tutor. \"Piled Higher and Deeper\" by Jorge Cham www.phdcomics.com Dr Colin Pilkington Science campus, Florida Park GJ Gerwel building, 04-015 011-471-2130 Contact times: Monday to Friday, from 8:00 till 14:00 pilkicl@unisa.ac.za School of Computing: 011 670 9200 COS3711/105/2022 5 3 Module Orientation Introduction Welcome to the Lessons that will make up your study material for the semester. Here you will find out about the prescribed book, the work that you are expected to study from it, and the assignments that need to be done. It is important that you check the assessment and study plan page, as here you will find a guide to getting through all the material in the allotted time (as well as getting the assignments in on time). This orientation lesson covers more general topics that relate to the module. The rest of the lessons will guide you through the work that has to be studied as part of this module. Purpose and outcomes Purpose COS3711 is a final year undergraduate module. We are obliged to offer a course that is comparable in standard to what other universities in the world offer in advanced programming concepts at this level. In the School of Computing, we opted for an advanced programming course using the public domain framework Qt 5. This module teaches a selection of design patterns to improve your existing object-oriented programming knowledge, new programming aspects such as concurrency, XML handling, and regular expressions as well as the reuse of open-source libraries and tools, using the Qt 5 framework. In addition, some network programming and cloud computing concepts will be included. The topics covered in this module require a good working knowledge of C++ as well as object-oriented programming knowledge as covered in the first- and second-level programming modules. A more detailed list of what you are expected to know can be found on the welcome page for this module. After completing this module, you should have a deeper understanding of both the C++ language and the Qt libraries, as well as of the design patterns used in developing applications with them. Outcomes After completing this module you should be able to: • Understand, recognise and implement a number of design patterns • Understand and reuse libraries • Understand and implement concurrent programming techniques • Use regular expressions in an application environment • Generate and parse XML files • Understand and implement reflective programming • Write programs that connect to a network • Describe cloud computing concepts and tools Books Prescribed book This is the last year that we are using this prescribed book and will be using open educational resources from 2023. The prescribed book for COS3711 is: An Introduction to Design Patterns in C++ with Qt, Second edition. Alan Ezust and Paul Ezust Prentice Hall ISBN: 978-0-13-282645-7 COS3711/105/2022 6 Note that we are using the second edition of this book, and that it differs substantially from the various electronic copies of the book that you might find online. Hence you need to purchase a copy of the second edition. A picture of the book in included so that you can be sure that you are getting the correct book. The following chapters from Ezust are covered in COS3711: • Chapter 7 Libraries and Design Patterns • Chapter 12 Meta Objects, Properties, and Reflective Programming • Chapter 13 Models and Views • Chapter 14 Validation and Regular Expressions • Chapter 15 Parsing XML • Chapter 16 More Design Patterns • Chapter 17 Concurrency Part II of the prescribed book contains a C++ Language Reference which you can consult during your study. Note that this book is out of print, and you may struggle to find a new hard copy of the book. There is an ebook, eIntroduction to Design Patterns in C++ with Qt, whose ISBN number is 9780132851633. Recommended books The following two books can be used as additional references: • J. Blanchette & M. Summerfield. C++ GUI programming with Qt 4. Prentice-Hall. • E. Gamma, R. Helm, R. Johnson & J.M. Vlissides. Design Patterns: Elements of Reusable Object- Oriented Software. Addison-Wesley. Books online You can also find books on Qt (including the prescribed textbook and the Blanchette & Summerfield book) in the online resources from the Library. Go to oasis.unisa.ac.za • Click on Library Links  Search for Information Resources. • Accept the Terms and conditions. • Click on Publishers  S  Safari Books Online  Safari Books Online. • Click on Safari Books Online (O'Reilly). • This will take you to the O’Reilly site. At the Select your institution prompt, go to the top of the list and choose Not listed? Click here. Continue using your Unisa credentials. • In the search box at the top of the page, search the entire site for “Qt” or any other topic that you may want to read up on. • You can then click on a book’s title, which should take you to the Table of Contents for that book. From here you can click on the chapter you want to read. Electronic resources Computer and internet access Students who register for COS3711 must have access to a suitable computer and have Internet access. The operating system must be a recent version of Windows. It is possible to use a computer with a Unix variant (such as Linux) or Mac, but, unfortunately, we will not be able to provide assistance if you do. Prescribed software The prescribed software for COS3711 is Qt 5, although you may use more recent versions too. This is a comprehensive software development kit (SDK) comprising a C++ compiler, the Qt 5 framework, and the Qt Creator IDE (as well as some other tools). You must install this software on your computer and use it for the programming exercises and assignments for this course. COS3711/105/2022 7 You can go to https://www.qt.io/download or https://download.qt.io/archive/qt/ to download the necessary files. You can also download an older version of Qt 5 from the Osprey web server of the School of Computing at http://osprey.unisa.ac.za/download/Disk/. The prescribed software is also installed on the computers in all Unisa computer laboratories. Installing the software Instructions for installing and using the prescribed software are provided in tutorial letter 103, which you can find under Additional Resources on myUnisa. Using Qt 5 Note that although we are using the Qt 5 framework, the prescribed textbook is based on Qt 4. You can have a look at the Qt wiki site The Transition from Qt 4.x to Qt 5 (https://wiki.qt.io/Transition_from_Qt_4.x_to_Qt5) for more details on what changes need to be made. However, we have already made the necessary changes to the example code in the chapters that you need to study, and you can download these from the Additional Resources page (UpdatedSourceFiles.zip). Osprey web server The School of Computing also uses the Osprey web server (http://osprey.unisa.ac.za/). The purpose of this server is to provide information about the School of Computing. It does not offer student administration services. There is also a discussion forum here that can be used. Assessment and study plan Assessment plan You will be assessed in several ways in this module. There are 3 assignments. o These are practical assignments that require you to design, code, compile, and run applications. o These should be done individually, and not in groups. o The first two assignments count 30% each, and the third one 40%. o Together, these 3 assignments count 30% towards the final module mark. • There is 1 written exam. o This exam counts 70% towards the final module mark. o You must submit at least the first assignment by the due date to get admission to the exam. Assignments are not merely to give you admission to the exam, or to determine a year mark. The real purpose of assignments is to get you to engage with the material and to understand it. And there is no better way to learn the concepts and techniques of programming than to develop programs and get them to work. It is essential that you complete all assignments in preparation for the exam. It is a great pity that each semester there are students who pass the exam, but due to not having done well in the assignments, or not having done one of the assignments at all, they do not get the required 50% to pass the module. Make sure that this does not happen to you. Due dates and times Due dates and times can be found in tutorial letter TL102. Note that assignments are due by midday on the due date. Study plan Here is a study plan (also available in tutorial letter TL102) that you can use to guide your studies through the year and following it should ensure that you get all three assignments in by the due dates. COS3711/105/2022 8 Dates 2022 Lesson Work to do Assignments due 22 March to 3 April Orientation Lesson 1 Module orientation Chapter 7 (Libraries and Design Patterns) Read and work through Lesson 1. 4 April to 17 April Lesson 2 Chapter 12 (Meta Objects) Refer to the Notes in Lesson 2 for additional material on Chapter 12. 18 April to 1 May Lesson 3 Chapter 13 (Models and Views) Refer to the Notes in Lesson 3 for additional material on Chapter 13. 2 May to 15 May Assignment 1 Complete assignment 1 Counts 30% Due midday 16 May 16 May To 29 May Lesson 4 Chapter 14 (Validation and Regex) Refer to the Notes in Lesson 4 for additional material on Chapter 14. 30 May to 12 June Lesson 5 Chapter 15 (Parsing XML) Refer to the Notes in Lesson 5 for additional material on Chapter 15. 13 June to 26 June Lesson 6 Chapter 16 (More Design Patterns) Refer to the Notes in Lesson 6 for additional material on Chapter 16. 27 June to 10 July Assignment 2 Complete assignment 2 Counts 30% Due midday 11 July 11 July to 24 July Lesson 7 Chapter 17 (Concurrency) Refer to the Notes in Lesson 7 for additional material on Chapter 17. 25 July to 7 August Lesson 8 Networking and Cloud Computing Study tutorial letter TL104 which you can find under Additional Resources. 8 August to 5 September Assignment 3 Complete assignment 3 Counts 40% Due midday 5 September 6 September to 16 October Revision: work through all the assignments again, through all the tutorial letters, extra notes and the textbook, as well as the past exams. 17 October Exams commence Plagiarism of assignments When your assignment has been marked, a percentage will be awarded. This is an indication of how correct your answers were, as well as the quality of your assignment. Copying other students’ solutions, or the official solutions from a previous or current semester, is plagiarism, which is a punishable offence that may lead to expulsion from the university. At the very least you will receive 0 for a plagiarised assignment. Policy on extensions The time available for study is limited, so please adhere to the assignment due dates. We understand that there are sometimes reasons why you cannot submit an assignment by the due date, so the following allowance has been made: COS3711/105/2022 9 • If you submit assignment 1 or 2 within 5 days after the due date, it will still be accepted and marked. • Assignments that are submitted after this may be marked but may not count towards your year mark. • We can unfortunately not allow extensions for assignment 3, as there is not enough time after the submission date to get all assignments marked and the marks submitted in time. Examination Use your my Studies @ Unisa brochure for general examination guidelines and examination preparation guidelines. Note the following: Owing to regulatory requirements, in order to be considered for examination admission a student must submit at least Assignment 1. • The examination consists of one examination paper. • The examination paper is a 2-hour paper and will be set in English only. • You will be examined on all the content covered in the assignments (including the self-assessment parts of the assignments), as well as all the content in the prescribed book, unless specifically stated otherwise. • Previous examination papers are available to students on myUnisa under Official Study Material. Progressing through the lessons Each of the lessons that follows this introductory section is broken into three parts: • Outcomes: This section tells you what you can expect to learn in the unit. • Study material: Here you will find which chapter of the prescribed book you are expected to study in the unit, to meet the assessment outcomes mentioned in the first section. There will also be an indication of how long you have to work with the material in this unit if you are to keep up to date with your studies. • Notes: Any particular points of interest will be picked up in this section, and so it may provide extra reading and other material that you should have a look at. The units that deal with the assignments will be structured differently, and here you will find the following: • Scope: This section will detail what work must be completed in order to attempt the assignment, as well as information on how to submit your answers. • Assignment questions: This section will tell you where you can find the assignment questions. • Assignment solutions: After the closing date, a discussion of the assignment will be posted as a tutorial letter (we will let you know that it has been posted via an announcement), and the sample solutions will be posted to a folder in Additional Resources. Activity One of the things that myUnisa does not have is the ability for you to create an online profile for yourself. This means that other students (and even your lecturers) know very little about you. Please take the time to go the Discussion forum, and to the Introductions forum. In a new topic, please introduce yourself to the group. Tell us who you are: your name, and age (if you want to) • Maybe tell us a little about your background: where are you from, in which city do you currently live, do you have a full-time job, and so on. • What programming experience do you have? Have you ever heard of Qt? What is your opinion of it? • Also, read some of the introductions and respond to the introductions of the other students. COS3711/105/2022 10 4 Lesson 1 - Libraries Outcomes After completing this chapter, you should be able to: • Know different containers of code and how they support code reuse • Install and use the libraries which accompany the prescribed book • Understand the concept of frameworks and APIs • Understand, identify, and implement the Serializer pattern • Describe the concept of an antiPattern Study Material Ezust You need to study Chapter 7 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Section 7.2: Installing Libraries Read through this section without downloading or installing any libraries suggested in this section. The installation of the Ezust libraries is detailed in tutorial letter TL103, which you can download from the Additional Resources page. Section 7.4.1: Serializer Pattern The version of the Serializer pattern in Ezust does not follow the classic pattern. Rather use the description of it below. When you need to input or output the state of an object of some class (whether to and from the console, or to and from a file) it is not a good idea to include this code in the class definition. It is better to apply the Serializer pattern and implement either or both Reader and Writer classes which do this on behalf of the class. Note that the pattern is not designed to handle input and output on behalf of Class1, it is used to store/load the state of Class1 objects. In this diagram, the client program uses an instance of Class1. If it wants to input the state of this instance (from a file or from the console) it declares an instance of Class1Reader, and calls its read() member function with the object as argument. A similar process is followed if the client program wants to output an instance of Class1. Take note: for this pattern to work efficiently, Class1 must be able to provide its complete state to Class1Writer, and it must allow Class1Reader to set its state fully. In C++, it is common to overload the stream extraction and insertion operators >> and << to input and output the state of an object of a given class. These can be written extremely simply in terms of Class1, Class1Reader and Class1Writer if the Serializer pattern has been applied. COS3711/105/2022 11 Videos Watch the videos in the Videos – Other topics folder in Additional Resources that revise topics from COS2614 that will be relevant in COS3711 again. Polymorphism and polymorphic assignment • Qt’s child management facility • Signals and slots • Stack and heap memory COS3711/105/2022 12 5 Lesson 2 – Meta-Objects, Properties and Reflective Programming Outcomes After completing this chapter, you should be able to: • Understand the Meta-Object pattern • Understand Qt’s implementation of Meta-Object • Implement reflective programming • Understand Qt’s support for run-time type identification • Understand the use of QMetaType Study Material Ezust You need to study Chapter 12 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Section 12.2: Type Identification (playlists.pro) Use the example in the playlists folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. This application may not want to compile, as the ui_mainwindow.h (created by Qt) cannot find the playlistsveiw.h or playlistview.h files, even though they are in the correct folder. This has to do with folder structures, and once you have built the application you may have to change the two lines #include \"playlistsview.h\" #include \"playlistview.h\" to #include \"..\\..\\playlists\\playlistsview.h\" #include \"..\\..\\playlists\\playlistview.h\" (or something similar, depending on where the ui_mainwindow.h file is located in relation to the two files it is looking for). Section 12.4: QVariant Class (properties.pro) Use the example in the properties folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. This application uses Qt’s testing capabilities to check customer properties. The output is either displayed in the Application Output window in the bottom pane of Qt Creator, or (if Run in terminal is checked) it will display in a console window. Section 12.6: MetaTypes The src\\metatype folder contains the fraction.h and metatype.cpp files needed for this example. To run this example, you will need to set up your own console project and add these two files to it. You need to make some changes before the program will compile and run: • In metatype.pro: make sure that QT += gui is included. • In fraction.h: Comment out the three overloaded << and >> operator functions below the class (or implement them yourself). • In metatype.cpp: There is a ; missing at the end of the qDebug() statement in the middle of main(). • Also in metatype.cpp: in createTest(), change QMetaType::construct(fracType) to QMetaType::create(fracType). COS3711/105/2022 13 • Check the Run in terminal checkbox. Signals and slots It is worth knowing that the way signals and slots are handled in Qt 5 has changed from that used before, although the old-style way still works. See the following for more information. https://wiki.qt.io/New_Signal_Slot_Syntax https://doc.qt.io/qt-5/signalsandslots-syntaxes.html https://woboq.com/blog/new-signals-slots-syntax-in-qt5.html Videos Watch the videos in the Videos – Other topics folder in Additional Resources on the using the meta- object and dynamic properties on myUnisa. Meta-object • Dynamic properties COS3711/105/2022 14 6 Lesson 3 – Models and Views Outcomes After completing this chapter, you should be able to: • Understand and identify the Model-View-Controller pattern • Design and implement applications with separated models and views • Have an overview of Qt’s in-built models and views • Use Qt’s in-built model and view classes • Understand the role of delegates in Qt’s model/view framework • Understand the value of smart pointers Study Material Ezust You need to study Chapter 13 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Section 13.2.1: QFileSystemModel (filesystem.pro) Use the example in the filesystem folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 13.2.2: Multiple views (multiview.pro) Use the example in the multiview folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 13.2.3: Delegate Classes (stardelegate.pro) The example (figure 13.8) refers to $QTDIR/examples/modelview/stardelegate. This should be C:\\Qt\\Qt5.3.0\\Examples\\Qt-5.3\\widgets\\itemviews\\stardelegate. It produces the following output. Figure 13.8 is a modified version of the example: The examples in 13.5 and 13.6 refer to files in the playlist folder – again, use the folder that we have supplied, rather than the original, as the files have been updated to run in Qt 5. Section 13.3: Table models (page 414) Use the example in the shortcutmodel-standarditem folder that has been provided in UpdatedSourceFiles.zip (that you can get from the Additional Resources), to test the Examples13.10 to 13.12. This is a version that has been corrected and updated for Qt 5. COS3711/105/2022 15 Section 13.4: Tree Models (objectbrowser.pro) Use the example in the objectbrowser folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been corrected and updated for Qt 5. The model test was not working correctly and has been commented out. Section 13.4.1: Trolltech Model Testing Tool You can simply read through this section; the programme does not work correctly in a Windows environment (and there are also problems with getting a debugger to work in a Windows environment). Section 13.5: Smart Pointers (dataobjects.pro) Add the following line to the .pro file: QT += widgets When you run this code, you will get several errors that indicate that QString has no member named toAscii – this function has been deprecated and replaced with toLatin1. You need to make all these changes in the dataobject.cpp file (lines 37, 159, 167, and 197), the qobjectreader.cpp file (line 63, 89 and 96), and the country.cpp file (line 30). Also, qVariantValue is deprecated. In qobjectreader.cpp, line 41, replace QTime t = qVariantValue<QTime>(val); with QTime t = val.value<QTime>();. Also, in qobjectwriter.cpp, line 72 onwards, change if (result == QString()) result = Qt::escape(val.toString()); else result = Qt::escape(result); return result; to if (result == QString()) result = QString(val.toString()).toHtmlEscaped(); else result = QString(result).toHtmlEscaped(); return result; Also, in qobjectwriter.cpp, line 107, change qFindChildren<QObject*>(obj, QString()); to obj->findChildren<QObject*>(QString()); This project has no executable file defined, so it will not actually run, but there should be no more compile errors. COS3711/105/2022 16 7 Assignment 1 Notes Assignment 1 scope What is covered? This assignment is a practical assignment, and covers chapters 7, 12, and 13 Ezust. The assignment has two parts: Part A should be submitted for marking. • Part B is for self-assessment purposes only and should not be submitted. Note that concepts from it may be included in the exams. We will provide model solutions to both parts of the assignment. Both parts are equally important, and we strongly recommend that you tackle all the questions of both parts of the assignment, to gain the full benefit from it. How to submit the assignment As the assignments will be marked from running versions of your answers, you have to submit a .zip file containing all the code (.h and .cpp files), the project file (.pro), and any text or other files (if applicable). The .zip file should not contain any .exe or .o files (so do not include the build-desktop folder), and you should delete the .pro.user file as well. If there is additional information that you feel the lecturer needs to take note of, please include a readme.txt in the .zip file. Each question of the assignment should be submitted in a separate, appropriately named folder. All the .h, .cpp, and .pro files relating to a single question should be saved in the folder. Also, your project will only be tested in the prescribed software of this module. Hence you should make sure that your project runs in the prescribed software. Ensure that your submission is virus free! When marking your assignments, your .zip file will be unzipped, the project file will be built and the functionality of your application will be tested. Note that there are often marks awarded for submitting an assignment answer that builds and runs. Thus, even if you cannot complete all sections of a question, make sure that you have done what you can that still results in a running version of the program (even if it has limited functionality). You should submit your assignment electronically via myUnisa. Time allocated You will need 2 weeks to complete this assignment. Due date Check tutorial letter TL102 for the due date for this assignment. Assignment 1 questions The assignment questions can be found in separate tutorial letter that will be uploaded to Additional Resources. Assignment 1 solutions After the closing date, a discussion of the assignment will be posted as a tutorial letter together with the sample solution code to a folder in Additional Resources. COS3711/105/2022 17 8 Lesson 4 – Validation and Regular Expressions Outcomes After completing this chapter, you should be able to: • Use input masks to control user input • Know the purpose of validators and Qt’s support for validators • Know how to set validators for input widgets in Qt • Know the purpose of regular expressions and an overview of the regular expression syntax • Understand the relationship between validators and regular expressions • Be able to write simple regular expressions for validation of input in Qt Study Material Ezust You need to study Chapter 14 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Section 14.1 Input Masks Use the example in the inputmask folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.2 Validators Use the example in the numvalidate folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.3 Regular Expressions At the bottom of page 443 there is a reference to a regular expression tester from Nokia in the src/regex- tester folder. Note that although the folder is there, there is no code for you to use. However, you can find the code in your Qt installation folder in C:\\Qt\\Qt5.3.0\\Examples\\Qt-5.3\\widgets\\tools\\regexp. Section 14.3.2 Regular Expressions: Phone Number Recognition (regexp.pro) Use the example in the regex folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.4 Regular Expression Validation Use the example in the regexval folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.5 Subclassing QValidator Use the example in the palindrome folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. COS3711/105/2022 18 9 Lesson 5 – Parsing XML Outcomes After completing this chapter, you should be able to: • Understand Qt’s support for parsing XML • Have an understanding of SAX and DOM parsing in Qt • Implement parsing using the SAX-parser • Generate XML files using DOM • Implement parsing using DOM Study Material Ezust You need to study Chapter 15 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Working with XML Note that XML files can be set up in 2 different ways: one format uses tags (like book) with attributes (like title and pages): <library> <book title=”Computer Algorithms” pages=”688” /> <book title=”C++ unleashed” pages=”918” /> </library> or, using tags (book, title, and pages) with text (like Computer Algorithms and 688) <library> <book> <title>Computer Algorithms</title> <pages>688</pages> </book> <book> <title> C++ unleashed</title> <pages>918</pages> </book> </library> An element is anything from the start tag to the end tag of an element. So, library is an element, as is pages. Strictly speaking, attributes are supposed to supply extra information that is not part of the data (or text). However, there are no rules about when to use attributes and when to use elements. Some argue that using attributes is more limiting, and that using elements is more extensible. Note also that the indenting of the above text is simply to make it more readable. Further, taking the tree (or hierarchical) structure of XML seriously, an XML document must contain a root element, although it does not matter what this element’s name is: <root> .... </root> COS3711/105/2022 19 This root then has branches that are called children: <root> <child> <sub_child> ... </sub_child> <sub_child> ... </sub_child> </child> <child> ... </child> </root> Section 15.2: SAX Parsing (sax1.pro) Use the example in the sax1 folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been updated for Qt 5. If you are working in Qt 6, SAX parsing is no longer supported. For this reason, you will not be expected to write code for SAX parsing in the exam, you still need to be aware of its use. There are several things you need to note about running this example (which should run as given): • Note that the xml file that you want to parse should maybe be placed in the build-desktop folder instead of in its debug folder – it depends on which folders Qt will use as its default folder. • You can place several xml files here, and then list them in the Arguments edit box in Run Settings – remember to type at least one name (the samplefile.xml file, for example) in the Arguments box if you want the program to run. • If you are getting slightly garbled output, then use the samplefile1.xml that is also supplied in the sax1 folder – there is sometimes a problem with the new line and carriage return characters. The example given here simply parses the xml file and displays it. Suppose you had a Person class that had a name and an age. An xml file for this could look as follows: <people> <person name=”Xin” age=”12” /> <person name=”Ndou” age=”21” /> </people> You thus know the structure of the xml file. If you now wanted to parse this file and then create instances of your Person class, you could do something along the lines of the following: bool StockReader::startDocument() { return true; } bool StockReader::startElement(const QString &namespaceURI, const QString &localName, const QString &qName, const QXmlAttributes &atts) { if (qName == \"person\") { QString name = atts.value(0); //QString name = atts.value(“name”); //this is also a valid method int age = atts.value(1).toInt(); Check the name of the tag We know that its first attribute is the name, and the second is the age COS3711/105/2022 20 p.setName(name); p.setAge(age); } return true; } bool StockReader::endElement(const QString &namespaceURI, const QString &localName, const QString &qName) { return true; } bool StockReader::endDocument() { return true; } You would obviously have to have some way of dealing with p, the Person object that was created, and that would depend on your individual program. However, if the xml file is not based on attributes but on text, we could have the following: <people> <person> <name>Xin</name> <age>12</age> </person> <person> <name>Ndou</name> <age>21</age> </person> </people> Parsing this is different and would involve something along the lines of the following. The variables used in the example (inName and inAge) would need to be members of the XMLHandler class: bool XMLHandler::startDocument() { inName = false; inAge = false; return true; } bool XMLHandler::startElement(const QString &namespaceURI, const QString &localName, const QString &qName, const QXmlAttributes &atts) { if (qName == \"name\") inName = true; if (qName == \"age\") inAge = true; return true; } bool XMLHandler::characters(const QString& text) { if (inName) { objectList.append(text); inName = false; } Set values in an object Set flags so that we know which tag we are in Set the appropriate flag Handle the text between the opening and closing tag, and reset the flag COS3711/105/2022 21 if (inAge) { objectList.append(text); inAge = false; } return true; } bool XMLHandler::endElement(const QString &namespaceURI, const QString &localName, const QString &qName) { if (qName == \"person\") { p.setName(objectList[0]); p.setAge(objectList[1].toInt()); pl.append(p); objectList.clear(); } return true; } bool XMLHandler::endDocument() { return true; } Section 15.3.1: DOM Tree Walking (domwalker.pro) Use the example in the domwalker folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been updated for Qt 5. Remember to put the samplefile.xml file in the build-desktop folder, so that the example can read this file. This example uses a form of the classic Visitor pattern, but as you are not expected to know this design pattern, this will not be discussed further. Section 15.3.2: Generation of XML with DOM (dombuilder.pro) Note the comment at the top of page 472 (the first paragraph of this section): it is better to generate XML documents using an API, than hard coding the output to ensure that the output is parsable. Thus, while you can do this: toFile << \"<people>\" << endl; toFile << \" <person name=\\\"\" << name << \"\\\" age=\\\"\" << age; toFile << \"\\\" />\" << endl; toFile << \"</people>\" << endl; it is better to use the more complicated DOM approach. Use the example in the dombuilder folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been corrected. Example 15.15 refers to folder src/libs/docbook/ – this can be found in the c:\\projects\\libs\\docbook folder, and you can find the files referred to there. Example 15.14 is a Linux alternative. XSL stands for EXtensible Stylesheet Language, and XSLT stands for XSL Transformations – transforming XML (whose tags are not well understood by browsers) documents to other formats like XHTML (whose tags are well understood by browsers). If you would like to learn XSLT, look at the tutorial at https://www.w3schools.com/xml/xsl_intro.asp. More on generation of XML with DOM Once we are back at the closing tag for person, we have all the detail we need to instantiate an object COS3711/105/2022 22 If you wanted to manually construct XML from an object, you can use the following outline. Say we wanted to create the following XML document: <people> <person> <name>Xin</name> <age>12</age> </person> <person> <name>Ndou</name> <age>21</age> </person> </people> You will need to create the document and a root: QDomDocument doc; QDomElement rootElement = doc.createElement(\"people\"); doc.appendChild(rootElement); Then, for each child, you would create it as follows: QDomElement personElement = doc.createElement(\"person\"); rootElement.appendChild(personElement); QDomElement nameElement = doc.createElement(\"name\"); personElement.appendChild(nameElement); QDomText nameText = doc.createTextNode(name); nameElement.appendChild(nameText); QDomElement ageElement = doc.createElement(\"age\"); personElement.appendChild(ageElement); QDomText ageText = doc.createTextNode(age [as a string]); ageElement.appendChild(ageText); This then creates the XML document in a manner that you can be certain will be parsable. Section 15.4: XML Streams (streambuilder.pro) Use the example in the streambuilder folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been updated for Qt 5. Tutorial There is a very nice, concise introduction to SAX and DOM XML parsing in Qt at http://www.digitalfanatics.org/projects/qt_tutorial/chapter09.html. Although it is part of a larger tutorial, it is clear enough to follow. One could, of course, go back to some of the previous tutorials and build the address book application that is used. Root element 1 st child 2 nd child Create root element Create document Add root to document Create child element and add it to the root Create name element and add it to person Create the text and add it to the name element Now do the same for age COS3711/105/2022 23 10 Lesson 6 – More Design Patterns Outcomes After completing this chapter, you should be able to: • Understand, identify and implement the Factory Method pattern • Understand, identify and implement the Abstract Factory pattern • Understand, identify and implement the Singleton pattern • Understand, identify and implement the Memento pattern • Understand, identify and implement the Façade pattern • Understand, identify and implement the Strategy pattern • Understand, identify and implement the Adapter/Wrapper pattern Study Material Ezust You need to study Chapter 16 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Section 16.1: Creational Patterns Ezust discusses both the Factory Method, and • Abstract Factory design patterns. Section 16.1.4: Polymorphism from Constructors You will need to create your own project to test this little program. Remember to check the Run in terminal box on the Run Settings tab. Otherwise, the program should run as described in Ezust. Section 16.2: Memento Pattern According to the Gang of Four (E. Gamma, R. Helm, R. Johnson & J.M. Vlissides: Design Patterns: Elements of Reusable Object-Oriented Software), a memento is an object that stores a snapshot of the internal state of another object, and this state can only be “read” by the original object. This allows an object’s state to be restored at some later point, allowing for an “undo” or a rollback operation. What we have in this section is not the memento pattern, but rather an implementation of the serializer pattern. The Gang of Four do not include the serializer pattern in their set of patterns, although other authors do. Serializer is used to stream objects into other data structures (writing) and is also responsible for restoring objects from such a data structure (reading). It is commonly used to write and restore the state of an object to a file or database, allowing for storage and retrieval. Go back and have a look at the notes in Unit 1; see also section 7.4.1 on page 249. A comment here about QObjectReader and QObjectWriter. These follow the idea of a serializer well, in that neither knows anything about the structure of the objects passed to it and serializes the object as it finds it. The StockControl project in the UpdatedSourceFiles.zip is a running version of an application that uses the QObjectWriter and QObjectReader classes. Note also that the files referred to in examples 16.11-14 can be found in C:\\projects\\libs\\dataobjects. Section 16.3: Façade Pattern Note also that the files referred to in examples 16.15-19 can also be found in C:\\projects\\libs\\metadata and C:\\projects\\libs\\filetagger. COS3711/105/2022 24 References See the following sources for more information on design patterns: E. Gamma, R. Helm, R. Johnson & J.M. Vlissides. (1995). Design Patterns: Elements of Reusable Object-Oriented Software. Addision-Wesley. • C.G. Lasater. (2007). Design Patterns. Wordware Applications Library. Factory Method This design pattern is applicable when a class needs to create objects but doesn’t know which objects to create, and the responsibility for creating objects can be transferred to the subclasses. So, this design pattern defines a class with a function for creating an object, but the subclasses implement this function to create appropriate objects. The UML structure of this design pattern is given below: The main classes included in the UML diagram are: Product: defines the interface of the objects to be created by the Factory. ConcreteProduct: implements the Product interface, which is created by the ConcreteFactory. Factory: declares the factoryMethod(), which returns an object of type Product. ConcreteFactory: overrides the factoryMethod() to return an instance of type ConcreteProduct. There are a number of variations of this design pattern. Firstly, the FactoryMethod() in Factory may provide a default implementation of the factory method, and it may call the FactoryMethod in one of its functions (operation()). This means the Factory is not always necessarily abstract. Secondly, the factory method could take parameters and based on them, several different objects can be created. This means a ConcreteFactory may create more than one type of object. Watch the video on this pattern that can be found in the Videos - Design Patterns folder in Additional Resources on myUnisa, and then make sure that you can describe the differences between this pattern and other patterns beyond what is given in Ezust. Also read the correction to the video. Abstract Factory This design pattern is applicable when you need to create families of related or dependent objects. This design pattern mainly has two hierarchies: (1) Hierarchies of product classes, whose objects are meant to be used together. (2) Then you have a hierarchy of factory classes to facilitate creation of the product classes. The UML structure of the design pattern is given below: COS3711/105/2022 25 The main classes included in the UML diagram are: AbstractProductA and AbstractProductB: abstract classes of two related product classes. ProductA1 and ProductA2: concrete product A classes. ProductB1 and ProductB2: concrete product B classes. AbstractFactory: abstract factory class that declares functions for creating product A and B objects. ConcreteFactory1 and ConcreteFactory2: concrete factories, which implement functions declared in the AbstractFactory to create concrete product A and B classes. Client: it only uses the functions declared in AbstractProductA, AbstractProductB and AbstractFactory. Using this design pattern, the client does not know about the implementation details of the concrete product families, and it can interchangeably use any of the concrete factories to create the appropriate concrete products. Watch the video on this pattern that can be found in the Videos - Design Patterns folder in Additional Resources on myUnisa, and then make sure that you can describe the differences between this pattern and other patterns beyond what is given in Ezust. Singleton This design pattern is applicable when you want to have a class which has only one instance, and this single instance can be accessed via a global access point. This is generally achieved by making the constructor of the class private, creating one instance, and a function that can be used to return the single instance. Since there is only one class involved, a UML diagram is not included here. Instead, one way of implementing Singleton is demonstrated below: Class definition class A{ public: static A* getInstance(); private: A(); static A* onlyInstance; }; Class implementation A* A::onlyInstance = NULL; A::A(){} A* A::getInstance(){ if(onlyInstance == 0) COS3711/105/2022 26 onlyInstance = new A(); return onlyInstance; } As demonstrated in the code, the single instance of A is stored in the static variable onlyInstance. When a request for an A instance is made via getInstance(), an instance of A is created and stored in onlyInstance. All subsequent calls to getInstance() do not create new instances but rather return the only instance of A stored in onlyInstance. Memento The Memento pattern is a behavioural pattern. This design pattern is applicable when the state of an object needs to be saved so that its state can be restored later without violating the encapsulation of the class. The data members of the class, which determine the state of its objects, may not all be accessible (via setters and getters) outside the class. Hence the class itself has to be involved in saving and restoring the state of its objects. The UML structure of the design pattern is given below: The main classes involved in the UML diagram are: Originator: state of the objects of this class are being saved and restored. To save the state of an object, it creates a snapshot of its state by creating a Memento, via the createMemento() function. To restore the state of the object, it uses a Memento via the setMemento() function. Memento: stores the state of an Originator. Caretaker: it keeps the Memento. The role of the Caretaker is only to store the Memento, and it is not allowed to access the state of the Originator saved in the Memento. One way of achieving this is by making the getState(), setState(),and even the constructor of Memento, private, so that the Caretaker cannot access the state of the Originator. However Orginator needs to be able to access the constructor, getState(), and setState() of Memento. One way of achieving this is by making Originator a friend of Memento. Caretaker requests a snapshot of an Originator using the createMemento() function. The Originator in turn creates a snapshot of its state by passing its state to Memento, and thus creating a Memento, which is then passed to the Caretaker. If the state of the Originator has to be restored, then Caretaker can invoke the setMemento() function to restore the state of the Originator. COS3711/105/2022 27 Watch the 2 videos on this pattern that can be found in the Videos - Design Patterns folder in Additional Resources on myUnisa, and then make sure that you can describe the differences between this pattern and other patterns beyond what is given in Ezust. Façade The Façade pattern is a structural pattern. The Façade pattern is applicable when you would like to provide a simplified interface to a complicated set of systems but yet allowing the client to access the functionality of the underlying system. This design pattern defines a Façade that interacts and invokes the subsystems to satisfy the request of the client. A simplified diagram of this design pattern is given below: Strategy The Strategy pattern is a behavioural pattern and is applicable when there is a family of algorithms that needs to be made interchangeable based on the context. Using this design pattern, each algorithm is encapsulated in a class, and the run time selection of a relevant algorithm is made possible. The UML diagram of this design pattern is given below: The classes involved in this UML diagram are: Strategy: It is the class which defines a common interface (here the function Algorithm()) for the classes that represents the family of algorithms. It is generally an abstract class, and is sometimes referred to as an abstract strategy. COS3711/105/2022 28 StrategyOne, StrategyTwo and StrategyThree: These are the concrete strategies, which each define the Algorithm() function. These classes are sometimes referred to as concrete strategies. Context: Context has a reference to a Strategy, and it can decide on the concrete strategy to choose, based on the requirement. Watch the video on this pattern that can be found in the Videos - Design Patterns folder in Additional Resources on myUnisa, and then make sure that you can describe the differences between this pattern and other patterns beyond what is given in Ezust. There are also two videos on combining the strategy and factory method patterns. Adapter/Wrapper This design pattern is a structural design pattern and is applicable when the functionality of a class can be reused but the interface of the class is not compatible with the existing classes. So, this design pattern converts the interface of an existing class into another, as expected by the client. This design pattern is sometimes called a Wrapper pattern since it can be seen as wrapping around an existing class to present a different interface to other classes. There are two forms (Class Adapter and Object Adapter) of the Adapter pattern, and the UML diagrams of both forms of the Adapter pattern are given below: Class Adapter Object Adapter The main classes included in the UML diagram are: Client: uses objects conforming to the Target interface Target: defines the domain-specific interface used by the Client Adaptee: defines the interface of an existing class to be reused Adapter: adapts the interface of Adaptee to the Target interface In a Class Adapter, Adapter adapts the interface of Adaptee by inheriting from Adaptee. In the Request() function of the Adapter, it simply invokes the SpecificRequest() function in Adaptee. COS3711/105/2022 29 Here the client call operates on an Adapter instance, which in turn calls Adaptee operations (SpecificRequest(), for instance), which carry out the operation. In an Object Adapter, Adapter adapts the interface of Adaptee by creating an instance of Adaptee (adaptee). In the Request() function of the Adapter, it simply invokes the SpecificRequest() function on the instance of Adaptee. Here the client call operates on an Adapter instance, which in turn calls operations on the Adaptee instance to carry out the operation. COS3711/105/2022 30 11 Assignment 2 Notes Assignment 2 scope What is covered? This assignment is a practical assignment, and covers chapters 14, 15, and 16 Ezust. The assignment has two parts: Part A should be submitted for marking. • Part B is for self-assessment purposes only and should not be submitted. Note that concepts from it may be included in the exams. We will provide model solutions to both parts of the assignment. Both parts are equally important, and we strongly recommend that you tackle all the questions of both parts of the assignment, to gain the full benefit from it. How to submit the assignment As the assignments will be marked from running versions of your answers, you have to submit a .zip file containing all the code (.h and .cpp files), the project file (.pro), and any text or other files (if applicable). The .zip file should not contain any .exe or .o files (so do not include the build-desktop folder), and you should delete the .pro.user file as well. If there is additional information that you feel the lecturer needs to take note of, please include a readme.txt in the .zip file. Each question of the assignment should be submitted in a separate, appropriately named folder. All the .h, .cpp, and .pro files relating to a single question should be saved in the folder. Also, your project will only be tested in the prescribed software of this module. Hence you should make sure that your project runs in the prescribed software. Ensure that your submission is virus free! When marking your assignments, your .zip file will be unzipped, the project file will be built and the functionality of your application will be tested. Note that there are often marks awarded for submitting an assignment answer that builds and runs. Thus, even if you cannot complete all sections of a question, make sure that you have done what you can that still results in a running version of the program (even if it has limited functionality). You should submit your assignment electronically via myUnisa. Time allocated You will need 2 weeks to complete this assignment. Due date Check tutorial letter TL102 for the due date for this assignment. Assignment 2 questions The assignment questions can be found in separate tutorial letter that will be uploaded to Additional Resources. Assignment 2 solutions After the closing date, a discussion of the assignment will be posted as a tutorial letter together with the sample solution code to a folder in Additional Resources. COS3711/105/2022 31 12 Lesson 7 - Concurrency Outcomes After completing this chapter, you should be able to: • Know the different classes in Qt for implementing concurrency • Understand and implement multiprocessing using the QProcess class • Understand and implement multithreading using the QThread class • Understand thread safety and the classes available in Qt for thread safety Study Material Ezust You need to study Chapter 17 from the prescribed book. Time allocated You will need 2 weeks to study this unit. Notes Section 17.1: QProcess and Process Control (randomNumbers.pro and logRandom.pro) The LogTail project, as included in Ezust, does not produce the desired output on Windows, because the command tail is only applicable on a UNIX variant operating system. A new example is provided in UpdatedSourceFiles.zip (in the QProcess and process control folder) to demonstrate starting, controlling, and communicating with other processes similar to LogTail. To test the new project, follow the instructions below. Firstly, open, build, and run the randomNumbers project so that randomNumbers.exe is generated in the debug folder of the project. This project should display 10 random numbers. You can now close this project. Secondly, open and build the logRandom project. Before you execute the project, copy and paste randomNumbers.exe from the debug folder of the randomNumbers project into the build (or debug, depending on where Qt will look for it) folder of the logRandom project. Run the project to view the output. Section 17.1.1: Processes and Environment (environment.pro) Use the example in the QProcess and process control\\environment folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a modified version of this example, which works exactly as described in Ezust. Test the project using the command line argument –f NULL. The only difference is that the Windows version uses putenv rather than setenv, and different environment variables are used (ones that are known in a Windows environment). Section 17.1.2: Qonsole (qonsole1.pro) Use the example in the qonsole1 folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a corrected version that includes a project file. In a Windows environment, you can use commands like • dir (to list directory contents) • cd (to change to another directory) • md (to make a directory) • date (to get the current date; you will need to press <Enter> a second time to bypass updating the date) • help (to get help) COS3711/105/2022 32 to check that the example is working. Please remember to type in the command exit before you close the window, to exit the command line process. Section 17.1.3: Qonsole with keyboard events (keyevents.pro) Use the example in the keyevents folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is an updated version for Qt 5. Section 17.2.2: Parallel prime number calculators (PrimeThreads.pro) Use the example in the PrimeThreads folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is an updated version for Qt 5. Section 17.2.3: Concurrent map/reduce example (life.pro) Use the example in the life folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is an updated version for Qt 5. An alternate approach to threading There are many who have argued that the way threading is shown in older Qt documentation is incorrect, and that there are better ways of doing it. The argument about the way threading is shown in the Qt documentation being wrong, relates to the way things were done in earlier versions of Qt (when QThread was abstract and subclassing it was required), that have now been changed in later versions (from Qt 4.4). The issue arises around what is known as thread affinity and the signal/slot system: Qt needs to check in which thread the sending and receiving objects are, and simply creating an instance of a class that is subclassed from QThread does not mean that it will, in fact, run in a separate thread. What is being done (subclassing QThread) works, but it is not how QThread was designed to be used; note also that it is not wrong, but may be bad object-orientated programming practice. QThread was designed as an interface (or control point), and not as a place to put code that is meant to be run in a thread. Also, QThread functions were intended to be called from the creating thread, and not the thread that QThread starts. Further, if you think about it, in OOP we create objects to do specific work, and making it part of a QThread hierarchy by subclassing QThread implies that this work is somehow an extension of QThread, which it really is not. Thus, this new approach keeps the thread code and the code of your specific object separate and encapsulated – a good OOP principle. Realise that QThread itself is an object, not a thread; it is just a wrapper around a thread that allows you to control the thread. So, the thread affinity of the QThread object is not necessarily the same as the actual thread (that is, the QThread object may be running in a different thread from the thread that is being created: the QThread object’s affinity will be the same as the thread that constructed the object, which would be the main thread). It has been argued that it is not necessary to subclass QThread at all. We present a brief example of this alternative approach, based on a PrimeFinder class that is used to find prime numbers, where PrimeFinder is implemented as a thread. Thus we get class PrimeFinder : public QObject { Q_OBJECT public slots: findPrime(); signals: finished(); //and so on }; int main() { COS3711/105/2022 33 PrimeFinder pf; QThread t; pf.moveToThread(&t); QObject::connect(&t, SIGNAL(started()), &pf, SLOT(findPrime())); QObject::connect(&pf, SIGNAL(finished()), &t, SLOT(quit())); t.start(); // and so on } As PrimeFinder is a QObject, its thread affinity is the same as that which created it – in this case the main thread. If you want it to run in a different thread, then you use the moveToThread() function. The moveToThread() function tells Qt that the event handlers, and the signals and slots, are dealt with from the indicated thread context. The started() signal of the thread is connected to the function in PrimeFinder that does the work; this function in PrimeFinder should emit a finished() signal once it is done. Then, the finished() signal of the PrimeFinder object is linked to the quit() slot of the thread. It is possible to have multiple instances of the PrimeFinder class assigned to a single thread, or multiple instances of several different classes assigned to a single thread. There is no need to tie a single instance of a class to a single thread. There is a really good video produced by VoidRealms at https://www.youtube.com/watch?v=yazMHbIew0Q, which demonstrates this quite well, and is worth having a look at. A full list of VoidRealms’ Qt videos can be found at https://www.youtube.com/playlist?list=PL2D1942A4688E9D63. This was put together from the following sources, and reading these will also give you some more insight: https://blog.qt.io/blog/2010/06/17/youre-doing-it-wrong/ http://stackoverflow.com/questions/4093159/what-is-the-correct-way-to-implement-a-qthread-example- please http://codethis.wordpress.com/2011/04/04/using-qthread-without-subclassing/ COS3711/105/2022 34 13 Lesson 8 – Networking and Cloud Computing Outcomes After completing this learning unit, you should be able to: • Know the difference between, and use of, various networking protocols, including FTP, TCP, and UDP • Understand and implement the process and tools Qt provides to handle networked applications • Describe the basic concepts and infrastructure related to cloud computing • Describe the benefits that can be gained from utilising cloud computing platforms and tools. Study Material Extra notes You need to study the extra notes on Networking that are available as tutorial letter TL104 in Additional Resources. The necessary source code to compile and run the code examples can be found in the UpdatedSourceFiles.zip file. You will also need to do the Azure Fundamentals part 1 module online as indicated below. Time allocated You will need 2 weeks to study this unit. Notes Cloud computing You need to complete the Azure Fundamentals part 1 learning path online. COS3711/105/2022 35 You can access this learning path at https://docs.microsoft.com/en-us/learn/paths/az-900-describe- cloud-concepts/. The learning path is made up of 3 modules: 1. Introduction to Azure fundamentals 2. Discuss Azure fundamental concepts 3. Describe core Azure architectural components You will also find other learning paths that you are free to take to further your knowledge in this growing area of expertise and that can be used to prepare for a Microsoft exam (should you wish to go that far). These modules consist of a mix of text, videos, extra notes, and labs, which you can complete at your own pace. Note that you are only required to complete the Azure Fundamentals part 1 learning path. The module will guide you through the basics of cloud computing and the tools and resources that Microsoft use to implement it. There are knowledge checks at the end of each module to check your understanding. You will not be expected to know the minute detail of each tool, but rather have an overall appreciation for what cloud computing has to offer and how it is implemented. Further reading The following reading will supplement your knowledge of the topic. • It will be worth your while reading the Wikipedia article on cloud computing (https://en.wikipedia.org/wiki/Cloud_computing) to get an overall view of its history and current trends. • Microsoft also has a useful article on cloud computing (https://azure.microsoft.com/en- us/overview/what-is-cloud-computing/). • IBM also offer a guide to cloud computing (https://www.ibm.com/cloud/learn/cloud-computing). COS3711/105/2022 36 14 Assignment 3 Assignment 3 scope What is covered? This assignment is a practical assignment and covers all the work covered this year. How to submit the assignment As the assignments will be marked from running versions of your answers, you have to submit a .zip file containing all the code (.h and .cpp files), the project file (.pro), and any text or other files (if applicable). The .zip file should not contain any .exe or .o files (so do not include the build-desktop folder), and you should delete the .pro.user file as well. If there is additional information that you feel the lecturer needs to take note of, please include a readme.txt in the .zip file. Each question of the assignment should be submitted in a separate, appropriately named folder. All the .h, .cpp, and .pro files relating to a single question should be saved in the folder. Also, your project will only be tested in the prescribed software of this module. Hence you should make sure that your project runs in the prescribed software. Ensure that your submission is virus free! When marking your assignments, your .zip file will be unzipped, the project file will be built and the functionality of your application will be tested. Note that there are often marks awarded for submitting an assignment answer that builds and runs. Thus, even if you cannot complete all sections of a question, make sure that you have done what you can that still results in a running version of the program (even if it has limited functionality). You should submit your assignment electronically via myUnisa. Time allocated You will need 4 weeks to complete this assignment. Due date Check tutorial letter TL102 for the due date for this assignment. Assignment 3 question The assignment question can be found in separate tutorial letter that will be uploaded to Additional Resources. Assignment 3 solution After the closing date, a discussion of the assignment will be posted as a tutorial letter together with the sample solution code to a folder in Additional Resources. © UNISA 2022","libVersion":"0.2.3","langs":""}