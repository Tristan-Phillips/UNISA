{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/Virtual Classes/VC09_Ch17_Concurrency.pdf","text":"COS3711 – Advanced Programming Virtual Class: COS3711 - 22 - Y Chapter 17 – Concurrency Lecturer: Dr C Pilkington Tutor: Ron Barnard Concurrency Outcomes ▪ Know the different Classes in Qt for implementing concurrency ▪ Understand and implement multi-processing using the QProcess Class ▪ Understand and implement multi-threading using the QThread Class ▪ Understand thread safety, and the Classes available in Qt for thread safety Concurrency Definitions Concurrency (General) - The fact of two or more events or circumstances happening or existing at the same time. • Concurrency - A condition that exists when, during a given period of time, at least two threads are making progress. ◦ Property of a program – program structure. ◦ Can occur in a single-core processor through time-slicing. • Parallelism - A condition that arises when, given a particular point of time, at least two threads are executing simultaneously. ◦ Run-time behaviour – program execution. ◦ Cannot occur in a single-core processor. Concurrency Definitions Two approaches to concurrency - • Processes – Executing instances of programs (Tasks). • Threads – Executing units that are part of a process. Process Thread • An executing instance of a program (Task). Each process has at least one thread. ◦ Can consist of multiple threads. • Thread is a functionality within a process. ◦ Subset of a process. • Runs in its own memory space. • Has its own resources - ◦ Own memory space, files etc • Run in a shared memory space. ◦ Use the memory of the process they belong to. • Share the process resources. ◦ Run in the same memory space. • Communication between processes is more difficult and resource-intensive. • Easy communication between threads due to shared memory space. Concurrency QProcess QProcess() - • Class for running and controlling other processes; • Derived from QObject, uses Signals and Slots; • Launches another process using start(QString &program, QStringList &arguments). New process is a child process that terminates when the parent process terminates; • startDetached() starts a process that continues running after the parent terminates. • Alternatively, you can set the program to run with setProgram() and setArguments(), and then call start() or open() (Alias for start()). (start() is overloaded). • Only need to sub-class QProcess if you want to extend the functionality eg: add a specific signal. Concurrency QProcess – Methods void QProcess::start(QString &program, QStringList &arguments) - To start a process, pass the name and command line arguments of the program you want to run as arguments to start(). Arguments, if any, are supplied as individual strings in a QStringList. Called process terminates when parent terminates. bool QProcess::startDetached() - Starts the program (with default arguments) in a new process, and detaches from it. Returns true on success; otherwise returns false. If the calling process exits, the detached process will continue to run unaffected. void QProcess::setWorkingDirectory(QString &dir) - Sets the working directory. QProcess will start the process in this directory. The default behaviour is to start the process in the working directory of the calling process. void QProcess::setProgram(QString &program) - Set the program to use when starting the process. This method must be called before start(). (Alternative to calling start() with arguments). void QProcess::setArguments(QStringList &args) - Set the arguments to pass to the called program when starting the process. This method must be called before start(). (Alternative to calling start() with arguments). Concurrency QProcess – Methods QByteArray QProcess::readAllStandardOutput() - Returns all data available from the standard output of the process as a QByteArray. QByteArryay QProcess::readAllStandardError() - Returns all data available from the standard error of the process as a QByteArray. QProcess::ProcessError QProcess::error() - Returns the type of error that occurred last (enums – FailedToStart, Crashed, Timedout, WriteError, ReadError, UnknownError). int QProcess::exitCode() - Returns exit code of the last process that finished – Application can specify any exit code 0 – 255, convention 0 indicates no error. QProcess::ExitStatus QProcess::exitStatus() - Returns the exit status of the last process that finished. (enums – NormalExit, CrashExit). QProcess::ProcessState QProcess::state() - Returns the current state of the process (enums - NotRunning, Starting, Running). Concurrency QProcess – Signals & Slots Signals - void errorOccurred(QProcess::ProcessError error) - Emitted when an error occurs with the process. void finished(int exitCode, QProcess::ExitStatus exitStatus) - Emitted when the process finishes – provides the ExitCode and ExitStatus. After the process has finished, the buffers in QProcess are still intact. You can still read any data that the process may have written before it finished. void readyReadStandardError() - Emitted when the process has made new data available through its standard error channel (stderr). void QProcess::readyReadStandardOutput() - Emitted when the process has made new data available through its standard output channel (stdout). void started() - Emitted when the process has started ie: state() returns Running. void stateChanged(QProcess::ProcessState newState) - Emitted whenever the state of the process changes, provides the new state. Slots - void kill() - Kills the current process, exits immediately. void terminate() - Attempts to terminate the process. Process may not exit when calling terminate(). Concurrency QProcess – Example connect(process, SIGNAL(readyReadStandardOutput()), this, SLOT(processOutput())); connect(process, SIGNAL(started()), this, SLOT(processStarted())); connect(process, SIGNAL(finished(int)), this, SLOT(processFinished(int))); connect(process, SIGNAL(errorOccurred(QProcess::ProcessError)), this, SLOT(processError(QProcess::ProcessError))); void ProcessView::startProcess() { // Slot connected to button in view process->start(\"randomNumbers\"); } void ProcessView::processOutput() { QString outStr = process->readAllStandardOutput(); edtView->append(\"\\nProcess output: \\n\" + outStr); } void ProcessView::processStarted() { edtView->clear(); edtView->setText(\"Process started\"); } Concurrency QThread QThread Class - provides a platform-independent way to manage threads. • Modern CPUs have multiple cores. Single-threaded application can only make use of one core. • Application with multiple threads can be assigned to multiple cores. • Distributing work to multiple threads, which use multiple cores, can allow applications to run much faster. • A QThread object manages one thread of control within the program. • QThreads begin executing in QThread::run(). QThread::start() slot calls run(). • By default, run() starts the event loop by calling exec() and runs a Qt event loop inside the thread. Thread – each process has at least one thread – main thread. GUI must be in main thread. • QThread will notify you via a signal when the thread is started() and finished(), or you can use isFinished() and isRunning() to query the state of the thread. • You can stop the thread by calling exit() or quit(). In extreme cases, you may want to forcibly terminate() an executing thread. However, doing so is dangerous and discouraged. • It is possible to deallocate objects that live in a thread that has just ended, by connecting the finished() signal to QObject::deleteLater(). Concurrency QThread Worker – Secondary thread referred to as a worker thread. • Worker object must be QObject – uses Signals and Slots. • You can use worker objects by moving them to the thread using QObject::moveToThread(). • Can connect the worker's slots to any signal, from any object, in any thread. • It is safe to connect signals and slots across different threads, uses a mechanism called queued connections. Maya Posch link - https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/ • The main thing to keep in mind when using a QThread is that it is not a thread. It is a wrapper around a thread object. This wrapper provides the signals, slots and methods to easily use the thread object within a Qt project. • A QThread should be used as follows - ◦ Prepare an object (QObject) Class with all your desired functionality in it; ◦ Then instatiate a new QThread instance; ◦ Push the QObject into it using moveToThread(QThread*) method of the QObject instance; ◦ Call start() on the QThread instance. Concurrency QThread - Methods Methods - void QObject::moveToThread(QThread *targetThread) - Changes the thread affinity for the object and its children. The object cannot be moved if it has a parent. Event processing will continue in the targetThread. QThread * QObject::thread() const – Returns the thread in which the object lives. void QThread::exit(int returnCode = 0) - Tells the thread's event loop to exit with a return code. The QEventLoop::exec() function returns returnCode. By convention, a returnCode of 0 means success, any non-zero value indicates an error. bool QThread::isFinished() const – Returns true if the thread is finished, otherwise false. bool QThread::isRunning() const – Returns true if the thread is running, otherwise false. int QThread::idealThreadCount() - Returns number of processor cores – real and logical. [static] Concurrency QThread – Protected methods Protected methods int QThread::exec() - Enters the event loop and waits until exit() is called, returning the value that was passed to exit(). • The value returned is 0 if exit() is called via quit(). • This method is meant to be called from within run(). • It is necessary to call this method to start event handling. • Note: This method can only be called within the thread itself. virtual void QThread::run() - The starting point for the thread. • After calling start(), the newly created thread calls run(). • The default implementation simply calls exec(). • Can be overridden to facilitate advanced thread management. • Returning from run() will end the execution of the thread. Concurrency QThread – Slots Slots - void QThread::quit() - Tells the thread's event loop to exit with return code 0 (success). • Equivalent to calling QThread::exit(0); • This method does nothing if the thread does not have an event loop. void QThread::start() - Begins execution of the thread by calling run(). void QThread::terminate() - Terminates the execution of the thread. • The thread may or may not be terminated immediately, depending on the operating system's scheduling policies. Use QThread::wait() after terminate(), to be sure. • Warning: This method is dangerous and its use is discouraged. The thread can be terminated at any point in its code path. Threads can be terminated while modifying data. There is no chance for the thread to clean up after itself, unlock any held mutexes, etc. Use this method only if absolutely necessary. Concurrency QThread – Signals Signals - void QThread::finished() - Emitted from the thread when it finishes executing. Used with QObject::deleteLater(). void QThread::started() - Emitted when the thread starts executing, before run() is called. Associated slot - void QObject::deleteLater() - Schedules this object for deletion. • The object will be deleted when control returns to the event loop. • If the event loop is not running when this method is called the object will be deleted once the event loop is started. • If deleteLater() is called after the main event loop has stopped, the object will not be deleted. • If deleteLater() is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes. Concurrency Thread safety Thread safety – Application / code is thread-safe if it behaves correctly when accessed from multiple threads. Issues - • Accessing shared data without locking; • Deadlock – Thread 1 & 2 both need access to A & B, Thread 1 locks A, Thread 2 locks B; • Race-condition – Behaviour dependent on timing / sequence of events. May be unpredictable in a multi-threaded situation. Reentrant - Execution can be interrupted at any point, and then safely called again (“re-entered”) before previous invocations complete execution. (Invoke == Call) • Function - is reentrant if it can be called simultaneously from multiple threads, but only if each invocation uses its own data. • Class – is reentrant if its member methods can be called safely from multiple threads, as long as each thread uses a different instance of the Class. Concurrency Thread safety Thread-safe - • Function – is thread-safe if it can be called simultaneously from multiple threads, even when the invocations use shared data. • Class – is thread-safe if its member methods can be called safely from multiple threads, even if all the threads use the same instance of the Class. Thread-safe Class / function is always reentrant, but reentrant Class / function is not always thread- safe. QMutex - basic class for enforcing mutual exclusion. A thread locks a mutex in order to gain access to a shared resource. If a second thread tries to lock the mutex while it is already locked, the second thread will be put to sleep until the first thread completes its task and unlocks the mutex. QReadWriteLock - similar to QMutex, except that it distinguishes between \"read\" and \"write\" access. When a piece of data is not being written to, it is safe for multiple threads to read from it simultaneously. QSemaphore – Protects multiple resources – QMutex protects one resource only. QtConcurrent – High-level APIs for multi-threaded applications, don't need to use QMutex etc. Concurrency moveToThread() example // Declare objects QThread* thread = new QThread; Worker* worker = new Worker(); // Inherits QObject // Move worker to thread worker->moveToThread(thread); // Connect Signals and Slots connect(worker, SIGNAL(error(QString)), this, SLOT(errorString(QString))); connect(thread, SIGNAL(started()), worker, SLOT(process())); connect(worker, SIGNAL(finished()), thread, SLOT(quit())); connect(worker, SIGNAL(finished()), worker, SLOT(deleteLater())); connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater())); // Start thread thread->start(); Concurrency QThread example Worker Class Client code worker.h class Worker : public QObject { Q_OBJECT public slots: void doWork(); signals: void result(QString data); }; worker.cpp void Worker::doWork { emit result(\"Workers are the best\"); } // Somewhere in MainWindow QThread* thread = new Thread(this); Worker* worker = new Worker(); worker->moveToThread(thread); connect(thread, &QThread::finished, worker, &QObject::deleteLater); connect(this, &MainWindow::startWork, worker, &Worker::doWork); connect(worker, &Worker::result, this, handleResult); thread->start(); // Later on, to stop the thread thread->quit(); Concurrency Past papers Past paper - Oct / Nov 2019 - To do - Read TL105; Exercises; Past Paper Oct/Nov 2019 - Q3.2 Threads; look at “Maya Posch” link; Qt documentation – QProcess, QThread, QMutex etc.","libVersion":"0.2.3","langs":""}