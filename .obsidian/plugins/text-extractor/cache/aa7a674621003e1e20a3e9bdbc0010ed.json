{"path":"UNISA/98906 - BSc Science in Computing/COS3712 - Computer Graphics/Unsorted/COS3712/Exam pack/Exam pack/Excersizes/COS3712 Odd Solutions.pdf","text":"Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 1 Odd Solutions 1.1 The main advantage of the pipeline is that each primitive can be processed independently. Not only does this architecture lead to fast performance, it reduces memory requirements because we need not keep all objects available. The main disadvantage is that we cannot handle most global eﬀects such as shadows, reﬂections, and blending in a physically correct manner. 1.3 We derive this algorithm later in Chapter 6. First, we can form the tetrahedron by ﬁnding four equally spaced points on a unit sphere centered at the origin. One approach is to start with one point on the z axis (0, 0, 1). We then can place the other three points in a plane of constant z. One of these three points can be placed on the y axis. To satisfy the requirement that the points be equidistant, the point must be at (0, 2 √ 1.11 A 1024 x 1280 display has a 4 to 5 aspect ratio. Hence, if the diagonal is 50 cm and we want square pixels, the screen must be approximately 31 cm x 39 mm. Each pixel is then about 0.3 mm on each side. A smooth display will require about 3 triads for each pixel, and thus the triads are about 0.1 mm apart. Finally if the shadow mask is halfway between the screen and electron guns, the shadow mask spacing is half the triad spacing. 2 Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 2 Odd Solutions 2.9 We can solve this problem separately in the x and y directions. The transformation is linear, that is xs = ax + b, ys = cy + d. We must maintain proportions, so that xs in the same relative position in the viewport as x is in the window, hence x − xmin A ﬂexible mesh representation would consist of an edge list, a vertex list and a polygon list with pointers so we could know which edges belong to which polygons and which polygons share a given vertex. 2.15 The Maxwell triangle corresponds to the triangle that connects the red, green, and blue vertices in the color cube. 2.19 Consider the lines deﬁned by the sides of the polygon. We can assign a direction for each of these lines by traversing the vertices in a counter-clockwise order. One very simple test is obtained by noting that any point inside the object is on the left of each of these lines. Thus, if we substitute the point into the equation for each of the lines (ax+by+c), we should always get the same sign. 2.21 Each of the four tetrahedrons that are created has 1/8 of the volume of the original tetrahedron. Hence, by keeping only these four and removing the middle volume, the resulting volume is half the original volume. Each of the triangles that we create when we subdivide has 1/4 the area of the original face. Thus each subtetrahedron has the same area as one of the original faces and in total the surface area of the four subtetrahedrons is the same as the surface area of the original tetrahedron, even though the central section has been removed. If we repeat the calculation for the length of all edges, we ﬁnd the length of all edges kept after a subdivision is greater the the length of the edges of the original tetrahedron. 2 Angel: Interactive Computer Graphics, Seventh Edition Chapter 3 Odd Solutions 3.7 There are a couple of potential problems. One is that the application program can map diﬀerent points in object coordinates to the same point in screen coordinates. Second, a given position on the screen when transformed back into object coordinates may lie outside the user’s window. 3.11 Consider a three position switch. The three positions can correspond to velocities of 0, +1 and -1. We can integrate to get positions from these velocities. Thus, we have no change (0), a constantly increasing position (+1), and a constantly decreasing position (-1). 3.13 Let (x1, y1) be the end of the arm of length l1. Assuming that the lower-left corner is the origin x1 = l1 cos θ y1 = l − 1 sin θ If (x2, y2) is the position of the end of the second arm, we can use a similar formula measured from (x1, y1) x2 = x1 + l2 sin ϕ y2 = y1 + l2 sin ϕ 1 Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 4 Solutions 4.1 If the scaling matrix is uniform then RS = RS(α, α, α) = αR = SR Consider Rx(θ), if we multiply and use the standard trigonometric identities for the sine and cosine of the sum of two angles, we ﬁnd Rx(θ)Rx(ϕ) = Rx(θ + ϕ) By simply multiplying the matrices we ﬁnd T(x1, y1, z1)T(x2, y2, z2) = T(x1 + x2, y1 + y2, z1 + z2) 4.5 There are 12 degrees of freedom in the three–dimensional aﬃne transformation. Consider a point p = [x, y, z, 1]T that is transformed to p′ = [x′y′, z′, 1]T by the matrix M. Hence we have the relationship p′ = Mp where M has 12 unknown coeﬃcients but p and p′ are known. Thus we have 3 equations in 12 unknowns (the fourth equation is simply the identity 1=1). If we have 4 such pairs of points we will have 12 equations in 12 unknowns which could be solved for the elements of M. Thus if we know how a quadrilateral is transformed we can determine the aﬃne transformation. In two dimensions, there are 6 degrees of freedom in M but p and p′ have only x and y components. Hence if we know 3 points both before and after transformation, we will have 6 equations in 6 unknowns and thus in two dimensions if we know how a triangle is transformed we can determine the aﬃne transformation. 4.7 It is easy to show by simply multiplying the matrices that the concatenation of two rotations yields a rotation and that the concatenation of two translations yields a translation. If we look at the product of a rotation and a translation, we ﬁnd that the left three columns of RT are the left three columns of R and the right column of RT is the right column of the translation matrix. If we now consider RTR′ where R′ is a rotation matrix, the left three columns are exactly the same as the left three columns of RR′ and the and right column still has 1 as its bottom 1 element. Thus, the form is the same as RT with an altered rotation (which is the concatenation of the two rotations) and an altered translation. Inductively, we can see that any further concatenations with rotations and translations do not alter this form. 4.9 If we do a translation by -h we convert the problem to reﬂection about a line passing through the origin. From m we can ﬁnd an angle by which we can rotate so the line is aligned with either the x or y axis. Now reﬂect about the x or y axis. Finally we undo the rotation and translation so the sequence is of the form T−1R−1SRT. 4.11 The most sensible place to put the shear is second so that the instance transformation becomes I = TRHS. We can see that this order makes sense if we consider a cube centered at the origin whose sides are aligned with the axes. The scale gives us the desired size and proportions. The shear then converts the right parallelepiped to a general parallelepiped. Finally we can orient this parallelepiped with a rotation and place it where desired with a translation. Note that the order I = TRSH will work too. 4.13 A vertex in a three-dimensional system is a location. It has no other properties but its location. 4.15 Points, vectors and scalars. 4.19 One test is to use the ﬁrst three vertices to ﬁnd the equation of the plane ax + by + cz + d = 0. Although there are four coeﬃcients in the equation only three are independent so we can select one arbitrarily or normalize so that a2 + b2 + c2 = 1. Then we can successively evaluate ax + bc + cz + d for the other vertices. A vertex will be on the plane if we evaluate to zero. An equivalent test is to form the matrix      1 1 1 1 x1 x2 x3 x4 y1 y2 y3 y4 z1 z2 z3 z4      for each i = 4, ... If the determinant of this matrix is zero the ith vertex is in the plane determined by the ﬁrst three. 4.21 Although we will have the same number of degrees of freedom in the objects we produce, the class of objects will be very diﬀerent. For example if we rotate a square before we apply a nonuniform scale, we will shear the square, something we cannot do if we scale then rotate. 2 4.23 The vector a = u × v is orthogonal to u and v. The vector b = u × a is orthogonal to u and a. Hence, u, a and b form an orthogonal coordinate system. 4.25 Using r = cos θ Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 5 Odd Solutions 5.1 Eclipses (both solar and lunar) are good examples of the projection of an object (the moon or the earth) onto a nonplanar surface. Any time a shadow is created on curved surface, there is a nonplanar projection. All the maps in an atlas are examples of the use of curved projectors. If the projectors were not curved we could not project the entire surface of a spherical object (the Earth) onto a rectangle. 5.3 Suppose that we want the view of the Earth rotating about the sun. Before we draw the earth, we must rotate the Earth which is a rotation about the y axis. Next we translate the Earth away from the origin. Finally we do another rotation about the y axis to position the Earth in its desired location along its orbit. There are a number of interesting variants of this problem such as the view from the Earth of the rest of the solar system. 5.5 Yes. Any sequence of rotations is equivalent to a single rotation about a suitably chosen axis. One way to compute this rotation matrix is to form the matrix by sequence of simple rotations, such as R = RxRyRz. The desired axis is an eigenvector of this matrix. 5.7 Consider the line determined by the points (x1, y1, z1) and (x2, y2, z2). Any point along can be written parametrically as (αx1 + (1 − α)x2, αy1 + (1 − α)y2, αz1 + (1 − α)z2). Consider the simple projection of this point 1 5.11 The CORE system used this approach. Retained objects were kept in distorted form. Any transformation to any object that was deﬁned with other than an orthographic view transformed the distorted object and the orthographic projection of the transformed distorted object was incorrect. 5.15 If we use θ = ϕ = 45, we obtain the projection matrix P =      1 0 −1 0 0 1 −1 0 0 0 0 0 0 0 0 1      5.17 All the points on the projection of the point (x.y, z) in the direction dx, dy, dz) are of the form (x + αdx, y + αdy, z + αdz). Thus the shadow of the point (x, y, z) is found by determining the α for which the line intersects the plane, that is axs + bys + czs = d Substituting and solving, we ﬁnd α = d − ax − by − cz LookAt(x-dx/2, y, z, 0, 0, 0, 0, 1, 0); /* draw scene here */ /* swap buffers and clear */ LookAt(x+dx/2, y, z, 0, 0, 0, 0, 1, 0); /* draw scene again */ /* swap buffers and clear */ 5.23 Probably the simplest approach would be the one in the previous problem of repeating vertices at the end of each row to create a degenerate polygon. 3 Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 6 Odd Solutions 6.1 Point sources produce a very harsh lighting. Such images are characterized by abrupt transitions between light and dark. The ambient light in a real scene is dependent on both the lights on the scene and the reﬂectivity properties of the objects in the scene, something that cannot be computed correctly with OpenGL. The Phong reﬂection term is not physically correct; the reﬂection term in the modiﬁed Phong model is even further from being physically correct. 6.3 If we were to take into account a light source being obscured by an object, we would have to have all polygons available so as to test for this condition. Such a global calculation is incompatible with the pipeline model that assumes we can shade each polygon independently of all other polygons as it ﬂows through the pipeline. 6.5 Materials absorb light from sources. Thus, a surface that appears red under white light appears so because the surface absorbs all wavelengths of light except in the red rangea subtractive process. To be compatible with such a model, we should use surface absorption constants that deﬁne the materials for cyan, magenta and yellow, rather than red, green and blue. 6.7 Let ψ be the angle between the normal and the halfway vector, ϕ be the angle between the viewer and the reﬂection angle, and θ be the angle between the normal and the light source. If all the vectors lie in the same plane, the angle between the light source and the viewer can be computer either as ϕ + 2θ or as 2(θ + ψ). Setting the two equal, we ﬁnd ϕ = 2ψ. If the vectors are not coplanar then ϕ < 2ψ. 6.13 Without loss of generality, we can consider the problem in two dimensions. Suppose that the ﬁrst material has a velocity of light of v1 and the second material has a light velocity of v2. Furthermore, assume that the axis y = 0 separates the two materials. Place a point light source at (0, h) where h > 0 and a viewer at (x, y) where y < 0. Light will travel in a straight line from the source to a point (t, 0) where it will leave the ﬁrst material and enter the second. It will then travel from this point in a straight line to (x, y). We must ﬁnd the t that minimizes the time travelled. 1 Using some simple trigonometry, we ﬁnd the line from the source to (t, 0) has length l1 = √Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 7 Odd Solutions 7.1 The major problem is that the environment map is computed without the object in the scene. Thus, all global lighting calculations of which it should be a part are incorrect. These errors can be most noticeable if there are other reﬂective objects will now not show the reﬂection of the removed object. Other errors can be caused by the removed object no longer blocking light and by its shadows being missing. Other visual errors can be due to distortions in the mapping of the environment to a simple shape, such as a cube, and to errors in a two step mapping. In addition, a new environment map should be computed for each viewpoint. 7.3 Consider a single sine wave that is sampled at a rate just over the Nyquist rate with the ﬁrst sample where the sine is zero. The next sample will be slightly greater than zero, the following slightly greater (in magnitude) than the second, and so until we get samples about equal to the maximum of the sine. Subsequent samples will get smaller and smaller until we get to the minimum of the sine, and then the values will slowly increase. This pattern will repeat, each cycle taking multiple periods of the original sine. Visually, this pattern looks like a modulated sine wave. This visual appearance is due to us seeing the energy of the original samples and those of the ﬁrst replica which appears just over the Nyquist rate. Our eye is a low pass but imperfect ﬁlter that lets both pass through. If we add the two sinusoids using the trigonometric identity we see the sum and diﬀerence frequencies which explains this modulation. The higher frequency (the sum) gives the inner frequency while the diﬀerence generates the slowly varying envelope. These patterns describe the Moire patterns we see when we move past two fences, one behind the other, when driving in a car. 7.5 Once aliasing occurs, it is very diﬃcult to remove because the data that has been aliased at another frequency is mixed with any unaliased data at that frequency. Thus, if we remove energy at that frequency, we remove both aliased and unaliased information. On the other hand, if we remove data at frequencies above the Nyquist frequency before sampling occurs, although we loose information, we are left with only unaliased data after sampling occurs. 7.7 The basic problem is that when we use subtractive colors and ﬁlters, 1 the colors modulate each other and there is a multiplicative rather than additive relationship. Thus, if we have two CMY colors. (C1, M1, Y1) and (C2, M2, Y2), the resulting color is (C1C2, M1M2, Y1Y2). OpenGL supports this kind of blending by allowing us to set a source or destination blending factor that is itself a color, Thus if the source blending factor is the destination color and destination blending factor is zero, we can create a ﬁlter. 7.11 Suppose that the histogram of the image is a function f (x) where x is the luminance. The lookup table formed from the function ∫ x 0 g(x′)dx′ will create an image with a ﬂat histogram. A simple discrete example is illustrative. Suppose we have a image which is 1024 x 1024 and has 256 values of luminance. If the image we want to create is to have a ﬂat histogram, there should be 4096 pixels with each luminance value. If we have the histogram of the original image, we can use this histogram to ﬁnd which original luminance values we must use to obtain the lowest 4096 values to assign to 0, the next lowest 4096 to assign to 1, and so on. The function that describes this process is the integral of the histogram curve. 7.13 In the perspective projection, each row of squares will have a diﬀerent size and thus each will appear as a pattern with a diﬀerent frequency. Consequently, there will be diﬀerent Moire patterns. In a parallel projection, once the checkerboard is oriented, the patterns are all the same. Consider the side of the cube determined by the plane y = 1. The projector through a point (x, 1, z) on this plane is on a line from the origin that intersects the unit sphere x2 p + y2 p + z2 p = 1. Points on this line are of the form (αx, αy, αz). Using the fact that the line passes though the plane y = 1 yields α = 1 previous level. The upper bound is given by the series 1 + 1/4 + 1/16 + 1/64 + . . . = 4/3. Thus we need at most 1/3 more storage. 3 Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 8 Odd Solutions 8.1 First, consider the problem in two dimensions. We are looking for an α and β such that both parametric equations yield the same point, that is x(α) = (1 − α)x1 + αx2 = (1 − β)x3 + βx4, y(α) = (1 − α)y1 + αy2 = (1 − β)y3 + βy4. These are two equations in the two unknowns α and β and, as long as the line segments are not parallel (a condition that will lead to a division by zero), we can solve for α β. If both these values are between 0 and 1, the segments intersect. If the equations are in 3D, we can solve two of them for the α and β where x and y meet. If when we use these values of the parameters in the two equations for z, the segments intersect if we get the same z from both equations. 8.3 If we clip a convex region against a convex region, we produce the intersection of the two regions, that is the set of all points in both regions, which is a convex set and describes a convex region. To see this, consider any two points in the intersection. The line segment connecting them must be in both sets and therefore the intersection is convex. 8.5 See Problem 5.22. Nonuniform scaling will not preserve the angle between the normal and other vectors. 8.7 Note that we could use OpenGL to, produce a hidden line removed image by using the z buﬀer and drawing polygons with edges and interiors the same color as the background. But of course, this method was not used in pre–raster systems. Hidden–line removal algorithms work in object space, usually with either polygons or polyhedra. Back–facing polygons can be eliminated. In general, edges are intersected with polygons to determine any visible parts. Good algorithms (see Foley or Rogers) use various coherence strategies to minimize the number of intersections. 8.9 The O(k) was based upon computing the intersection of rays with the planes containing the k polygons. We did not consider the cost of ﬁlling the polygons, which can be a large part of the rendering time. If we consider a 1 scene which is viewed from a given point there will be some percentage of the area of the screen that is ﬁlled with polygons. As we move the viewer closer to the objects, fewer polygons will appear on the screen but each will occupy a larger area on the screen, thus leaving the area of the screen that is ﬁlled approximately the same. Thus the rendering time will be about the same even though there are fewer polygons displayed. 8.11 There are a number of ways we can attempt to get O(k log k) performance. One is to use a better sorting algorithm for the depth sort. Other strategies are based on divide and conquer such a binary spatial partitioning. 8.13 If we consider a ray tracer that only casts rays to the ﬁrst intersection and does not compute shadow rays, reﬂected or transmitted rays, then the image produced using a Phong model at the point of intersection will be the same image as produced by our pipeline renderer. This approach is sometimes called ray casting and is used in volume rendering and CSG. However, the data are processed in a diﬀerent order from the pipeline renderer. The ray tracer works ray by ray while the pipeline renderer works object by object. 8.15 Consider a circle centered at the origin: x2 + y2 = r2. If we know that a point (x, y) is on the curve than, we also know (−x, y), (x, −y), (−x, −y), (y, x), (−y, x), (y, −x), and (−y, −x) are also on the curve. This observation is known as the eight–fold symmetry of the circle. Consequently, we need only generate 1/8 of the circle, a 45 degree wedge, and can obtain the rest by copying this part using the symmetries. If we consider the 45 degree wedge starting at the bottom, the slope of this curve starts at 0 and goes to 1, precisely the conditions used for Bresenham’s line algorithm. The tests are a bit more complex and we have to account for the possibility the slope will be one but the approach is the same as for line generation. 8.17 Flood ﬁll should work with arbitrary closed areas. In practice, we can get into trouble at corners if the edges are not clearly deﬁned. Such can be the case with scanned images. 8.19 Note that if we ﬁll by scan lines vertical edges are not a problem. Probably the best way to handle the problem is to avoid it completely by never allowing vertices to be on scan lines. OpenGL does this by having vertices placed halfway between scan lines. Other systems jitter the y value of any vertex where it is an integer. 2 8.21 Although each pixel uses ﬁve rays, the total number of rays has only doubled, i.e. consider a second grid that is oﬀset one half pixel in both the x and y directions. 8.23 A mathematical answer can be investigated using the notion of reconstruction of a function from its samples (see Chapter 7). However, a very easy to see by simply drawing bitmap characters that small pixels lead to very unreadable characters. A readable character should have some overlap of the pixels. 8.25 We want k levels between Imin and Imax that are distributed exponentially. Then I0 = Imin, I1 = Iminr, I2 = Iminr2, ..., Ik−1 = Imax = Iminrk−1. We can solve the last equation for the desired r = ( Imax Angel ad Shreiner: Interactive Computer Graphics; Seventh Edition Chapter 9 Odd Solutions 9.1 If the upper arm is longer than the lower arm then, as a ﬁrst approximation, the robot can reach all points within a sphere centered at the joint on the base. However, this answer is only approximate because the lower arm cannot move below the level of the base, so a second approximation is a hemisphere above the base. This approximation has to have added to it points below the base that can be reached by the lower arm while the upper arm is parallel to the top of the base, a set of points that depends on the length of the upper arm and the radius of the base. If the lower arm is longer than the upper arm, then there will be an interior sphere radius equal to the diﬀerence in the arm lengths that cannot be reached. 9.3 For this simple example, there are three values of the joint angles and three coordinates in space, so there are a couple of simple approaches that can work. One is to use the result of the previous problem to solve for the joint angles in terms of the given x, y, and z values, using a numerical method. We could then simply move the joint angles from their initial to ﬁnal positions linearly. A more interesting possibility is to have the tip of the robot arm trace out a given path, for example, a line segment between the starting and ending positions. If use the parametric form of this line, we can obtain a set of positions along it as the parameter varies from 0 to 1. For each of these intermediate positions, we can numerically solve for the joint angles and have the joint angles move linearly between successive points. This scheme would give us an approximately linear trajectory. In general, the problem is far more diﬃcult because a typical robot will have many more degrees of freedom and thus there will be many possible joint angle combinations for a given reachable position. We also have to worry about factors such as the maximum allowable rate at which joint angles can change. 9.11 The trick here is to store the average value of the four trees below at each node. Thus, if we have an 2n × 2n image, the nodes at level n has the 22n pixel values, the nodes at level n − 1 each store the average of the four 1 pixels below them, and so on. The root node stores the average value of the image, which is the average of the values stored at its four children. 9.13 Yes. For instance, we can save the state at nodes so that changes in state cannot propagate. 2 Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 10 Odd Solutions 10.1 There are a number of possibilities. One is to use the turtle representation where the angle is 60 degrees and the distance forward is half the size of the triangle. Then the sequence F F RRF F RRF RF RRF RRF RF RR will draw the edges of the four triangles. Another approach is to have 3 productions, each of which draws one of the interior triangles. 1 Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 11 Odd Solutions 11.1 (m + 1)3 11.3 As u varies over (a, b), v = u−a For r > 1Angel and Shreiner: Interactive Computer Graphics, Seventh Edition Chapter 12 Solutions 12.1 Let’s do the problem in two dimensions. The solution in three dimensions is essentially the same. Assume that the vertices are used in a consistent clockwise or counterclockwise manner. Starting at some vertex, that vertex and the next determine a line of the form ax + by + c = 0. If we evaluate ax + by + c for a given point, the result will be positive or negative depending on which side of the line the point lies. If we are following the vertices in a clockwise manner, the point is inside the polygon if and only if it is to the right of each of these lines. 12.3 Consider two identical circles of radius r centered at (a, 0) and (−a, 0). We can describe them through the single implicit equation ((x − a) 2 + y2 − r2)((x + a) 2 + y2 − r2), by simply multiplying together their individual implicit equations. We can form the torus by rotation these circles about the y axis which is equivalent to replacing x2 by x2 + z2. 12.5 The line from the center of the circle to the closest point on the ray must be perpendicular to the ray. Thus, if the ray is written as p = p0 + td and the circle has radius r and center pc, we can solve d · (p0 + td − pc) = 0, for t. We can then check the distance between this point and the center. If it is greater than r, the ray misses the sphere. 12.7 Generally, the depth information has to be retained so that the raster processors can determine which entities are in front. 12.9 As was discussed in the text, pipeline strategies can be adapted to non–shared-memory architectures. Ray tracing is more diﬃcult to adapt because if there are multiple reﬂections or translucent objects, all object must be available when a ray is traced. For large data sets, a distributed memory architecture may not have suﬃcient memory to allow storage of 1 the entire object database on each processor. In this case, a shared-memory machine has a huge advantage. 12.13 i + j + k 12.19 There are 256 (28) ways to color the vertices of a cube. If we take out symmetries (rotations, swapping colors), there are 14 distinct cases. Of these 4 cases gave a face with two whites on one diagonal and two blacks on the other and thus have an ambiguous interpretation. 2","libVersion":"0.2.3","langs":""}