{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Virtual Classes/VC07_Ch15_Parsing_XML.pdf","text":"COS3711 – Advanced Programming Virtual Class: COS3711 - 21 - Y Chapter 15 – Parsing XML Lecturer: Dr C Pilkington Tutor: Ron Barnard Parsing XML Outcomes ▪ Understand Qt's support for parsing XML ▪ Have an understanding of SAX and DOM parsing in Qt ▪ Implement parsing using the SAX parser ▪ Generate XML files using DOM ▪ Implement parsing using DOM Parsing XML XML - Definition Extensible Markup Language (XML) – is a markup language that defines a set of rules for encoding documents in a human-readable and machine-readable format. • originally published in 1998 by World Wide Web Consortium (W3C); • latest version 1.1 published in 2006 – not used much, v1.0 still most widely used; • file extension .xml; • commonly used for data storage and communication (particularly over the internet); • used by many applications such as MS Office, OpenOffice, .NET, and Qt (Designer); • XML is hardware and software independent – data is stored in plain text format; • XML does not actually do anything – it is data wrapped in tags, following a set of rules; • there are no pre-defined tags. Markup language - is a computer language that uses tags to define elements within a document. eg: <body> </body> <b> </b> <br/> • It is human-readable, meaning markup files contain standard words, rather than programming syntax; • used to format text – when document is processed the markup does not appear; • most popular are HTML and XML. Parsing XML XML - Terminology Character – An XML document is a string of characters. Most Unicode (UTF-8) characters can be used. • Characters are divided into - ◦ Markup – Markup begins with < and ends with >, or begins with & and ends with ; ◦ Content – Any string that is not markup. Tag – markup construct that begins with < and ends with >. There are 3 types of tags - • Start tag - <section> • End tag - </section> • Empty element tag - <br/> Element – document component that begins with a start tag and ends with a matching end tag, or consists of only an empty element tag. Can have text content, and attributes; Attribute – markup construct that consists of a name-value pair, within a start tag or empty element tag. • can only have a single value, and can only appear once in each element. <book type=”novel”> • multiple values* – list: comma, or semi-colon, or space delimited <section class=”mainbox redbox”> *not defined by XML Attributes should contain meta-data, not data itself. Parsing XML XML - Rules Valid characters – All Unicode characters are valid except NULL, some control characters have to be escaped to be used. (Non-printing characters were added in v1.1). Escaping – Characters that cannot be used directly (cannot be used as content) have to be escaped - < &lt; > &gt; & &amp; ' &apos; “ &quot; Comments - Comments can be used anywhere in a document, outside other markup - • Comments begin with <!-- and end with --> • eg: <!-- This is a comment, no escaping required - <book> and & can appear in a comment --> Syntax – XML document must be “well-formed” ie: conform to the rules - • A single root element contains all other elements (Tree structure - parent / child / sibling elements); • Special characters can only appear when used as markup < > & ; • Tags must be correctly nested, none missing, and none overlapping; • Tag names are case-sensitive, and start and end tags must match exactly (both required); • Tag names must begin with - a letter, or an underscore (Cannot start with xml); • Tag names can contain - alphanumeric character, underscore, hyphen, full stop (No spaces); • Prolog (Optional – must be first, if used) - <?xml version=\"1.0\" encoding=\"UTF-8\"?> Parsing XML XML – Tokens (Small unit of indivisible character values) Token Type Description STARTDOC Represents the start of the XML. Always the first token. The document element itself is represented by a START token, not the STARTDOC token ENDDOC Represents the end of the XML. Always the last token. START Represents the start of an element. END Represents the end of an element. The END token has no value, but marks the element's end. TEXT Represents text. ATTR Represents an attribute. ATTR tokens are allowed to appear after a STARTDOC or START token. NAMESPACE Represents a namespace (xmlns) attribute. Also only allowed after START or STARTDOC tokens. COMMENT Represents a comment. PROCINST Represents a processing instruction. Parsing – Process of splitting up a stream of information into its constituent pieces (Tokens). Parsing XML XML Example XML Comment <?xml version=\"1.0\" encoding=\"UTF-8\"?> <library> <book category=\"satire\"> <title lang=\"en\">Catch 22</title> <author>Joseph Heller</author> <year>1961</year> <price>30.00</price> </book> <book category=\"children\"> <title lang=\"en\">Harry Potter</title> <author>J K Rowling</author> <year>2005</year> <price>29.00</price> </book> </library> Prolog ( Optional ) Root element Child element Sibling elements Attribute – value must be in inverted commas Parsing XML XML Parsers SAX - (Simple API for XML) DOM - (Document Object Model) Parse-event-driven parsing Tree-style parsing Sequential parsing – one direction only Random access to tree structure Process XML document of almost any size Processing limited by amount of available memory Only current process loaded, previously processed portions discarded Entire document loaded into memory Read XML documents only Read, write, edit XML documents XML elements represented as objects - Nodes • QXmlStreamReader, QXmlStreamWriter – Stream-style parsing • QXmlSimpleReader is obsolete Parsing XML Qt – QXmlStreamReader methods Method Comment setDevice(QIODevice) : void Set file to be read atEnd() : bool while(!reader.atEnd()) readNext() : TokenType Reads next token and returns its type isStartElement() : bool Returns true if tokenType() equals StartElement name() : QStringRef ( Use toString() ) Returns the name of a StartElement, or EndElement readElementText() : QString Returns all text between StartElement and EndElement isEndElement() : bool Returns true if tokenType() equals EndElement Attributes - QXmlStreamAttribute attributes() : QXmlStreamAttribute Returns the attributes of a StartElement name() : QStringRef An attribute consists of a name() and a value() value() : QStringRef ( Use toString() ) Errors hasError() : bool if (reader.hasError()) errorString(), error() Information about errors Parsing XML Qt – QXmlStreamReader example // Read file QXmlStreamReader reader; reader.setDevice(&file); reader.readNext(); // Loop through document while(!reader.atEnd()) { if(reader.isStartElement()) { if(reader.name().toString() == \"title\") { foreach(const QXmlStreamAttribute &attr, reader.attributes()) { if (attr.name().toString() == \"type\") { QString attrValue = attr.value().toString(); // Do something with name / value pair } } title = reader.readElementText(); } else if (reader.name().toString() == \"artist\") { // Attributes as above artist = reader.readElementText(); } Parsing XML Qt – QXmlStreamReader example else if (reader.name().toString() == \"year\") { foreach(const QXmlStreamAttribute &attr, reader.attributes()) { if (attr.name().toString() == \"type\") { QString attrValue = attr.value().toString(); // Do something with name / value pair } } year = reader.readElementText(); } } // end isStartElement if (reader.isEndElement() && reader.name().toString() == \"cd\") { // Process output cd += QString(\"Title: %1 Artist: %2 Year: %3 \\n\").arg(title, artist, year); } // end isEndElement // Process next element reader.readNext(); } // end while // Close file file.close(); } return cd; } Parsing XML DOM – Generating XML Classes used with DOM - • QDomDocument ◦ QDomDocument(QString name) Constructor Also QDomDocument() ◦ createElement(QString ele) Creates elements ◦ appendChild(QString child) Add elements / text to DOM document ◦ createTextNode(QString tNode) Create element text ◦ setContent(QString text) Used to parse XML when reading file etc • QDomElement; ◦ appendChild(QString child) Add node to element ◦ setAttribute(“name”, value) Used to set attributes to elements • QDomText ◦ createTextNode(QString text) Create text for element • QDomNode; Base class for element, text, document . . Parsing XML DOM - Write example <catalog> <cd> <title>Title One</title> <artist>Artist One</artist> <year>1991</year> </cd> <cd> <title>Title Two</title> <artist>Artist Two</artist> <year>1992</year> </cd> </catalog> // Create XML document, and create root element QDomDocument doc; QDomElement rootElement; rootElement = doc.createElement(\"catalog\"); doc.appendChild(rootElement); Parsing XML DOM - Write example // Repeat for each entity in XML document (Function or loop) - QDomElement cd = doc.createElement(\"cd\"); QDomElement title = doc.createElement(\"title\"); // Create each element QDomText titleText = doc.createTextNode(“Title name”); // Text direct QDomElement artist = doc.createElement(\"artist\"); QDomText artistText = doc.createTextNode(cdData.at(1)); // Text from list, object etc QDomElement year = doc.createElement(\"year\"); QDomText yearText = doc.createTextNode(cdData.at(2)); rootElement.appendChild(cd); // Append elements to parent cd.appendChild(title); title.appendChild(titleText); cd.appendChild(artist); artist.appendChild(artistText); cd.appendChild(year); year.appendChild(yearText); Parsing XML DOM - Attributes Attributes – Should not be used for data – provide additional information (meta-data) Add attributes DOM - QDomElement ele = doc.createElement(\"person\"); ele.setAttribute(\"ID\", \"34675-345\"); ele.setAttribute(\"Age\", 34); ele.setAttribute(\"Ph\", \"555-1234987\"); rootElement.appendChild(ele); <person ID=”34675-345” Age=”34” Ph=”555-1234987”> Parsing XML DOM – Read example // Open file first. QDomDocument doc; doc.setContent(&file); QDomElement root = doc.documentElement(); // Check that it is correct list if (root.tagName() == \"catalog\") { // Declare variables QString title, artist, year; QDomNode node = root.firstChild(); while (!node.isNull()) { // Parse XML QDomElement element(node.toElement()); if (element.tagName() == \"cd\") { QDomNode CDNode = node.firstChild(); while (!CDNode.isNull()) { Parsing XML DOM – Read example QDomElement CDElement(CDNode.toElement()); if (CDElement.tagName() == \"title\") { title = CDElement.text(); } if (CDElement.tagName() == \"artist\") { artist = CDElement.text(); } if (CDElement.tagName() == \"year\") { year = CDElement.text(); } CDNode = CDNode.nextSibling(); } } // Process input cd = QString(\"CD Title: %1, Artist: %2, Year: %3\") .arg(title, artist, year); list.append(cd); // Clear variables omitted node = node.nextSibling(); } } Parsing XML DOM – Past papers Past papers - • Oct / Nov 2019 - ◦ Q3.1 Given code written using QXmlStreamWriter. Write XML code produced. • Jan / Feb 2021 ◦ Q3.3 Given XML code (Including attributes). Write code to read XML – DOM. To do - • Read TL105; • Exercise 7 – Read (SAX - XmlStreamReader) / Write (DOM) XML; • Past Paper Oct/Nov 2019 - Q3.1 DOM write – Write code & run • Example reading DOM – Make up any XML file, or download – include attributes. • An example/s reading properties, write output to XML DOM / QXmlStreamWriter.","libVersion":"0.2.3","langs":""}