{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/SORT/Prev Sem/COS3711/drive-download-20200416T190041Z-001/Exam Papers/Exam answers 2011 Oct Nov.pdf","text":"Exam answers: Oct/Nov 2011 Question one 1.1 Layout is a child of Window ,label and textEdit are both children to layout. 1.2 Window is the QObject in this program because it is the most top parent in the hierarchy. 1.3 Here we have addWidget() being called on a layout, and the widget provided as argument is added as a child of the widget for which the layout is applied. For example: layout->addWidget(label); implicitly states that layout is a parent to label, window->setLayout(layout) makes layout a child of window and therefore we do not need to call setParent(). 1.4 a) Here, child objects are stack objects so when the program exits (parents destroyed), it will try to delete (destroy) parent using delete, this will fail and cause the program to crash. This is not allowed and does not support/satisfy child management. b) This case works nicely for child management because all heap objects (i.e. children) will be deleted (destroyed) when the program exits (Parents deleted). Parents out of scope, children are also destroyed. 1.5 #include<QPushButton> QPushButton* submitButton = new QPushButton(\"Submit\"); layout->addWidget(submitButton); connect(submitButton, SIGNAL(clicked()), textEdit, SLOT(clear())); Window layout label textEdit Question Two 2.1) #ifndef PRODUCT_H #define PRODUCT_H class Product { public: Product(QString d, double p, int n) :m_Description(d), m_PricePeritem(p), m_NoOfItems(n) { } virtual void sell(int n); private: QString m_Description; double m_PricePerItem; int m_NoOfItems; }; #endif // PRODUCT_H // product.cpp void Product::sell(int n) { if(m_NoOfItems >= n) { m_NoOfItems = m_NoOfItems - n; } } 2.2) #ifndef FOODPRODUCT_H #define FOODPRODUCT_H #include \"product.h\" class FoodProduct : public Product { public: FoodProduct(QString d, double p, int n, QDate sbd) :Product(d, p, n), m_SellByDate(sbd) { } void sell(int n); private: QDate m_SellByDate; }; #endif // FOODPRODUCT_H // foodproduct.cpp #include \"product.h\" void FoodProduct::sell(int n) { if(QDate::currentDate() >= m_SellByDate) { Product::sell(n); } } 2.3) Polymorphism is a mechanism by which a function call is resolved at runtime. Dynamic binding (or runtime) always occurs through an indirect call (via pointer) to a method by an instance of a class. Static (or compile time) binding occurs either through an indirect call or a direct call to a member function. To get dynamic binding, the member function must be declared as virtual. Product* p1 = new Product(\"Bread\", 10.50, 10); p1->sell(5); //This invokes Product:sell() Product* p1 = new FoodProduct(\"Pencil\", 2.50, 50, QDate:currentDate()); p1->sell(20);//This invokes FoodProduct::sell() 2.5) Virtual functions have a body and this function may be re-implemented in derived classes, but is not required. // virtual function virtual void sell(int n); pure virtual functions have no body, and must be implemented in a derived class. //pure virtual function virtual void sell(int n) = 0; Question Three 3.1) Serializer pattern. 3.2) It is designed to input or output the state of an object of some class (whether to and from the console, or to and from the file), since it is not recommended to include this code in the class definition. 3.3) Class1 is used for Saving and Restoring. Class1Writer saves the state of Class1 objects. Class1Reader restores the state of Class1 objects. 3.4) The client program uses an instance of Class1. If it wants to input the state of this instance (from a file or from a console) it declares an instance of Class1Reader and calls its read() member function with the objet as argument. If it want to output this instance of Class1, it declares an instance of Class1Writer and calls its write() method with object as argument. 3.5) Class1Writer uses Class1 data members and writes that information to a file. Class1Reader uses Class1 data members to read information from a file. But neither Class1Reader nor Class1Writer can access data members of Class1 directly, this is done via public member functions. 3.6) class FilmWriter { public : FilmWriter() bool write(Film f); }; bool FilmWriter :: write(Film&f) { QFile filmFile(\"filmFile.dat\"); filmFile.open (QioDevice::WriteOnly); f(& filmFile); f << getTitle(); filmFile.close(); return true; } 3.7) #include <QTextStream> QTextStream cout(& filmFile); int main (){ Film F (\"filmFile.dat\") FilmWrite F; writer << F; } Question Four bmiviewer.h public Slots: void calculateBmi(); private QLCDNumber* result; //bmiviewer.cpp heightEntry = new QLineEdit(); result = new QLCDNumber(); QLabel*bmi = new Qlabel(\"BMI\"); QPushButton* calculate = new QPushButton(\"calculate\"); layout->addWidget(calculate,2,1); layout->addWidget(result,3,1); // extra code, not needed heightEntry->setMaxlenght(20); heightEntry->setAlignment(Qt::AlignRight); weightEntry->setMaxlenght(20); weightEntry->setAlignment(Qt::AlignRight); // required code, needed connect(calculate,SIGNAL(clicked()),this,Slot(calculateBmi())); layout->addWidget(bmi,3,0); layout->addWidget(calculate,2,2); layout->addWidget(result,3,1); void BmiViewer:: calculateBmi(){ Qstring wstr = weightEntry->text(); Qstring hstr = heightEntry->text(); bool ok; double w = wstr.toDouble(&ok); double h = hstr.toDouble(&ok); if (!ok){ error = new QErrorMessage(this); error->showMessage(\"Please enter a valid number\"); } Else { double Bmi = w/h*h; result->display(Bmi); } } Question Five 5.1) Observer pattern 5.2) This design helps to define a one-to-many dependency between objects so that when one object changes state, all its dependencies are notified and updated automatically. . 5.3) QObject class represents the application of a simplified form of the Observer pattern, in particular in its implementation of signals and slots. QObject has a static member function connect() (similar to attach() in the classic Observer pattern) used to connect a subject to an observer. It also allows us to specify which change of state (the signal) should cause to which update (the slot). Numerous observers can be connected to a single subject, and one observer can be connected to numerous subjects.","libVersion":"0.2.3","langs":""}