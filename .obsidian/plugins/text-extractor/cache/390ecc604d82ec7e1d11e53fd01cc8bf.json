{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/SORT/Prev Sem/COS3711/Drive/COS3711/Exam Papers/Oct_Nov 2013.pdf","text":"Oct/Nov 2013 COS2614 Question 01 1.1 QString name = QInputDialog::getText(0,\"Name Input\", \"Enter your name\"); 1.2 This program reshuffles characters or strings. //Input File = Choose subjects randomly (./ishuffle COS2614 INF3708 COS3711) Output: COS3711 COS2614 INF3708 1.3 a) There could be insufficient arguments in argv[] b) Input other than text could be supplied. /*Needed improvements...*/ //check for sufficient arguments if (argc < 3) { cout << \"Insufficient arguments\" << \"\\n\"; } //Limit to text input ............................................. else { cout << \"Input is not recognized....\" << \"\\n\"; } Question 02 2.1) Head is added to the child list of Stack. Class Stack makes use of Qt child management facility which provides the object with setParent() which automatically adds an object to a child list of another. 2.2) No, this is not a problem. This program makes use of child management facility offered by QObject, and we see this as Stack inherits from QObject. Every time the new Node is pushed (added onto) the Stack, the new Node will set the Stack as its parent. Therefore the missing destructor for the Stack, allows the inherited destructor to deallocate all its children. 2.3) Composite pattern. Stack maintains a list of its children and calls on SetParent() to add an object to its child list. Question 03 3.1) It is an abstract class. 3.2) class Shape { public: virtual double area()const = 0.0; virtual double resize(double f) const = 0.0; }; 3.3) ShapeList inherits from QList<Shape*>, QList has member function append() which in this case can be used to add Shape to the list. 3.4) To delete all the Shapes in ShapeList. A destructor will affectively deallocate all the children from its parent. ShapeList::~ShapeList() { qDeleteAll(this); } 3.5) Polymorphic assignment: foreach(Shape* s, *this) // In ShapeList A pointer of type Shape (superclass) is made to point to an instance of its concrete subclass (ShapeList). Polymorphism: sum += s->area(); A function is invoked in Shape* which results in the invocation of averageArea() function implemented in the class of the object pointed to by Shape* 3.6) Function resize() in Shape is an abstract function therefore will not return anything (no implementation), resize in Circle, and Rectangle will adjust the size of these objects by a given factor. resizeAll() in ShapeList will adjust the size of all the objects in the list by a required factor. 3.7) /* main.cpp..*/ #include<QTextStream> #include \"rectangle.h\" #include \"circle.h\" #include \"shapelist.h\" int main(int argc, char *argv[]) { QTextStream cout(stdout); Shape* s1 = new Circle(4.2) Shape* s2 = new Rectangle(5.0, 2.0); ShapeList list; //instance of ShapeList list.append(s1); list.append(s2); cout << \"Average areas of shapes in the list\" << list.average() << endl; list.resizeAll(s1); cout << \"Average areas of shapes in the list\" << list.averageArea() << endl; return 0; } NOT REQUIRED, but if you had add() in ShapeList, this is how you would implement it /* add() in ShapeList*/ class ShapeList : public QList<Shape*> { public: void add(Shape* s); } /*implementation of add()....to a shape to the list*/ void ShapeList::add(Shape *s) { this->append(s); } Question 04 (chapter 12 Concurrency) 4.1) QWidget – every widget inherits from QWidget. QLineEdit – to allow the user specify time intervals. QVBoxLayout – for positioning of objects in a widget. QLabel – for timer label. 4.2) Q_OBJECT macro supports the use of signals and slots, which are needed in this application. This is also a safe way of managing memory. 4.3) We declare variables as data members for reference in the code and initialize them so to set their starting values at the beginning of a program. Declaring a variable in a member function or constructor allows the programmer to manipulate or manage the data members. Example: QTimer* timer // to store values of timer timer = new QTimer(this); //declare variable in a member function void addFile(const QString& filename); 4.4) 3 slots. //to display colour of the next traffic light void nextFrame(); //to add a file void addFile(const QString& filename); //to set time interval void setInterval(int newDelay); 4.5) It helps to manage the time between different colours of the traffic light. Allows the user to specify or set the time interval. QTimer will emit signal show to display the next frame with different colour. 4.6) /* To display the next colour on the traffic light....*/ connect(show, SIGNAL(timeOut()), this, SLOT(nextFrame())); /* To access file names.....*/ connect(&picFile, SIGNAL(foundFile(const QString&)), this, SLOT(addFile(const QString&))); /* To set the timer interval between different colours displayed on the traffic light...*/ connect(intervalChanged, SIGNAL(intervalChanged(int)), tLight, SLOT(setInterval(int))); 4.7) /*..trafficLight.h */ public slots: void addFile(const QString& filename); private: // to store the file name QVector<QPixmap> pics; int current; /*..traffic.cpp */ void trafficLight::nextFrame() { current = (current + 1) % pics.size(); emit show(&pics[current]); } void trafficLight::addFile(const QString& filename) { pics << QPixmap(filename) } Question 05 (chapter 12 on Qt GUI Widgets) /* DialogColors.h..*/ public slots: void actionEvent(QAction* act); protected: QAction* addChoice(QString name); private: QActionGroup* actionGroup; QToolBar *toolbar; /* dialogColors.cpp*/ DialogColors::DialogColors() : actionGroup(new QActionGroup(this)) { actionGroup->setExclusive(false); colorsMenu->addAction(addChoice(\"colorGreen\", \"Green\")); colorsMenu->addAction(addChoice(\"colorBlue\", \"Blue\")); colorsMenu->addSeparator(); colorsMenu->addAction(addChoice(\"colorsGreenBlue\", \"Green\\tBlue\")); QMainWindow::menuBar()->addMenu(colorsMenu); toolbar = new QToolBar(\"Choice ToolBar\", this); toolbar->addActions(actionGroup->actions()); QMainWindow::addToolBar(Qt::LeftToolBarArea area, toolbar); } QAction* DialogColors::addChoice(QString name, QString text) { QAction* retval = new QAction(text, this); retval->setObjectName(name); retval->setEnabled(false); retval->setCheckable(true); actionGroup->addAction(retval); return retval; } Question 06 6.1) Reusability – design patterns introduces classes that specify where changes need to be made.this helps when writing large applications where a developer does not have to go through thousands of lines of code. Extensibility – a measure of how easy it is to add enhancements to an application. One of the standard ways of making code extensible is to provide classes which can easily be subclassed. 6.2) Every QObject maintains a list of its children, this is reflected through the data members of Composite. You can make one object the child of another by calling setParent(), which automatically adds it to the list of children of its parent. Furthermore, QObject doesn't have an operation() member function, but it does implement a destructor that recursively destructs all its children. The lifetime of children is therefore dependent on the lifetime of their parent, and so we have a composition relationship between parent and children, not aggregation as in the classic Composite pattern. 6.3) These are techniques described by the Model-View pattern of separating the underlying data (the model) from the class that presents the user with a GUI (the view). It is a clean separation between model classes that represent data and view code that presents a user interface.","libVersion":"0.2.3","langs":""}