{"path":"Subjects/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/some slides/Chapt-6-Constraint-Satisfaction.pdf","text":"1 Constraint Satisfaction Problems (CSP) (Where we delay difficult decisions until they become easier) y) R&N: Chap. 6 (These slides are primarily from a course at Stanford University – any mistakes were undoubtedly added by me.) 8-Queens: Search Formulation #1  States: all arrangements of 0, 1, 2, ..., or 8 queens on the board  Initial state: 0 queen on the board  Successor function: each of the successors is obtained by adding one queen in a non- empty square  Arc cost: irrelevant  Goal test: 8 queens are on the board, with no two of them attacking each other  64x63x...x53 ~ 3x1014 states 8-Queens: Search Formulation #2  States: all arrangements of k = 0, 1, 2, ..., or 8 queens in the k leftmost columns with no two queens attacking each other  Initial state: 0 queen on the board  Successor function: each successor is obtained by adding one queen in any square that is not attacked by any queen already in the board, in the leftmost empty column  Arc cost: irrelevant  Goal test: 8 queens are on the board 2,057 states Issue  Previous search techniques make choices in an often arbitrary order, even if there is still little information explicitly available to choose well.  There are some problems (called constraint  There are some problems (called constraint satisfaction problems) whose states and goal test conform to a standard, structured, and very simple representation.  This representation views the problem as consisting of a set of variables in need of values that conform to certain constraint. Issue  In such problems, the same states can be reached independently of the order in which choices are made (commutative actions)  These problems lend themselves to general- purpose rather than problem specific purpose rather than problem-specific heuristics to enable the solution of large problems  Can we solve such problems more efficiently by picking the order appropriately? Can we even avoid having to make choices? Constraint Propagation  Place a queen in a square  Remove the attacked squares from future consideration 2 6 6 5 5 55 5 5 5 6 7 Constraint Propagation 5 5 6  Count the number of non-attacked squares in every row and column  Place a queen in a row or column with minimum number  Remove the attacked squares from future consideration 3 4 4 43 3 3 4 5 Constraint Propagation 3 3 5  Repeat 4 3 33 3 4 3 Constraint Propagation 2 3 4 4 2 33 3 1 Constraint Propagation 2 1 3 2 2 22 1 Constraint Propagation 1 Constraint Propagation 2 1 2 1 3 Constraint Propagation 1 1 Constraint Propagation What do we need?  More than just a successor function and a goal test  We also need: • A means to propagate the constraints imposed by • A means to propagate the constraints imposed by one queen’s position on the the positions of the other queens • An early failure test  Explicit representation of constraints  Constraint propagation algorithms Constraint Satisfaction Problem (CSP)  Set of variables {X1, X2, …, Xn}  Each variable Xi has a domain Di of possible values. Usually, Di is finite  Set of constraints {C1 C2 Cp}Set of constraints {C1, C2, …, Cp}  Each constraint relates a subset of variables by specifying the valid combinations of their values  Goal: Assign a value to every variable such that all constraints are satisfied 8-Queens: Formulation #1  64 variables Xij, i = 1 to 8, j = 1 to 8  The domain of each variable is: {1,0}  Constraints are of the forms: • X = 1  X = 0 for all k = 1 to 8 kj• Xij = 1  Xik = 0 for all k = 1 to 8, kj • Xij = 1  Xkj = 0 for all k = 1 to 8, ki • Similar constraints for diagonals • i,j[1,8] Xij = 8 Binary constraints (each constraint relates only 2 variables) 8-Queens: Formulation #2  8 variables Xi, i = 1 to 8  The domain of each variable is: {1,2,…,8}  Constraints are of the forms: • Xi = k  Xj  k for all j = 1 to 8, ji • Similar constraints for diagonals All constraints are binary 4 Map Coloring WA NT SA Q NSW V WA NT SA Q NSW V  7 variables {WA,NT,SA,Q,NSW,V,T}  Each variable has the same domain: {red, green, blue}  No two adjacent variables have the same value: WANT, WASA, NTSA, NTQ, SAQ, SANSW, SAV,QNSW, NSWV TT Constraint graph • Constraint graph: nodes are variables, arcs are constraints A Cryptarithmetic Problem • Here each constraint is a square box connected to the variables it constrains • allDiff; O + O = R + 10 * X1;… Street Puzzle 1 2 34 5 Ni = {English, Spaniard, Japanese, Italian, Norwegian} Ci = {Red, Green, White, Yellow, Blue} Di = {Tea, Coffee, Milk, Fruit-juice, Water} Ji = {Painter, Sculptor, Diplomat, Violinist, Doctor} Ai = {Dog, Snails, Fox, Horse, Zebra} The Englishman lives in the Red house Who owns the Zebra? The Spaniard has a Dog The Japanese is a Painter The Italian drinks Tea The Norwegian lives in the first house on the left The owner of the Green house drinks Coffee The Green house is on the right of the White house The Sculptor breeds Snails The Diplomat lives in the Yellow house The owner of the middle house drinks Milk The Norwegian lives next door to the Blue house The Violinist drinks Fruit juice The Fox is in the house next to the Doctor’s The Horse is next to the Diplomat’s Who owns the Zebra? Who drinks Water? Street Puzzle 1 2 34 5 Ni = {English, Spaniard, Japanese, Italian, Norwegian} Ci = {Red, Green, White, Yellow, Blue} Di = {Tea, Coffee, Milk, Fruit-juice, Water} Ji = {Painter, Sculptor, Diplomat, Violinist, Doctor} Ai = {Dog, Snails, Fox, Horse, Zebra} The Englishman lives in the Red house (Ni = English)  (Ci = Red) The Spaniard has a Dog The Japanese is a Painter The Italian drinks Tea The Norwegian lives in the first house on the left The owner of the Green house drinks Coffee The Green house is on the right of the White house The Sculptor breeds Snails The Diplomat lives in the Yellow house The owner of the middle house drinks Milk The Norwegian lives next door to the Blue house The Violinist drinks Fruit juice The Fox is in the house next to the Doctor’s The Horse is next to the Diplomat’s (Ni = Japanese)  (Ji = Painter) (N1 = Norwegian) left as an exercise (Ci = White)  (Ci+1 = Green) (C5  White) (C1  Green) Street Puzzle 1 2 34 5 Ni = {English, Spaniard, Japanese, Italian, Norwegian} Ci = {Red, Green, White, Yellow, Blue} Di = {Tea, Coffee, Milk, Fruit-juice, Water} Ji = {Painter, Sculptor, Diplomat, Violinist, Doctor} Ai = {Dog, Snails, Fox, Horse, Zebra} The Englishman lives in the Red house (Ni = English)  (Ci = Red) The Spaniard has a Dog The Japanese is a Painter The Italian drinks Tea The Norwegian lives in the first house on the left The owner of the Green house drinks Coffee The Green house is on the right of the White house The Sculptor breeds Snails The Diplomat lives in the Yellow house The owner of the middle house drinks Milk The Norwegian lives next door to the Blue house The Violinist drinks Fruit juice The Fox is in the house next to the Doctor’s The Horse is next to the Diplomat’s (Ni = Japanese)  (Ji = Painter) (N1 = Norwegian) (Ci = White)  (Ci+1 = Green) (C5  White) (C1  Green) unary constraints 5 Street Puzzle 1 2 34 5 Ni = {English, Spaniard, Japanese, Italian, Norwegian} Ci = {Red, Green, White, Yellow, Blue} Di = {Tea, Coffee, Milk, Fruit-juice, Water} Ji = {Painter, Sculptor, Diplomat, Violinist, Doctor} Ai = {Dog, Snails, Fox, Horse, Zebra} The Englishman lives in the Red house i,j[1,5], ij, Ni  Nj ij[1 5] ij C  CThe Spaniard has a Dog The Japanese is a Painter The Italian drinks Tea The Norwegian lives in the first house on the left The owner of the Green house drinks Coffee The Green house is on the right of the White house The Sculptor breeds Snails The Diplomat lives in the Yellow house The owner of the middle house drinks Milk The Norwegian lives next door to the Blue house The Violinist drinks Fruit juice The Fox is in the house next to the Doctor’s The Horse is next to the Diplomat’s i,j[1,5], ij, Ci  Cj ... Street Puzzle 1 2 34 5 Ni = {English, Spaniard, Japanese, Italian, Norwegian} Ci = {Red, Green, White, Yellow, Blue} Di = {Tea, Coffee, Milk, Fruit-juice, Water} Ji = {Painter, Sculptor, Diplomat, Violinist, Doctor} Ai = {Dog, Snails, Fox, Horse, Zebra} The Englishman lives in the Red house The Spaniard has a Dog The Japanese is a Painter The Italian drinks Tea The Norwegian lives in the first house on the left  N1 = Norwegian The owner of the Green house drinks Coffee The Green house is on the right of the White house The Sculptor breeds Snails The Diplomat lives in the Yellow house The owner of the middle house drinks Milk  D3 = Milk The Norwegian lives next door to the Blue house The Violinist drinks Fruit juice The Fox is in the house next to the Doctor’s The Horse is next to the Diplomat’s Street Puzzle 1 2 34 5 Ni = {English, Spaniard, Japanese, Italian, Norwegian} Ci = {Red, Green, White, Yellow, Blue} Di = {Tea, Coffee, Milk, Fruit-juice, Water} Ji = {Painter, Sculptor, Diplomat, Violinist, Doctor} Ai = {Dog, Snails, Fox, Horse, Zebra} The Englishman lives in the Red house  C1  Red The Spaniard has a Dog  A1  Dog The Japanese is a Painter The Italian drinks Tea The Norwegian lives in the first house on the left  N1 = Norwegian The owner of the Green house drinks Coffee The Green house is on the right of the White house The Sculptor breeds Snails The Diplomat lives in the Yellow house The owner of the middle house drinks Milk  D3 = Milk The Norwegian lives next door to the Blue house The Violinist drinks Fruit juice  J3  Violinist The Fox is in the house next to the Doctor’s The Horse is next to the Diplomat’s Finite vs. Infinite CSP  Finite CSP: each variable has a finite domain of values  Infinite CSP: some or all variables have an infinite domainan infinite domain E.g., linear programming problems over the reals:  We will only consider finite CSP   ni,ni,1 1 i,2 2 i,0 nj,nj,1 1 j,2 2 j,0 for i = 1, 2, ..., p : a x +a x +...+a x a for j = 1, 2, ..., q : b x +b x +...+b x b What does CSP Buy You?  Each of these problems has a standard pattern – a set of variables that need to be assigned values that conform to a set of constraints.  Successors function and a Goal test predicate p can be written that works for any such problem.  Generic Heuristics can be used for solving that require NO DOMAIN-SPECIFIC EXPERTISE  The constraint graph structure can be used to simplify the search process. CSP as a Search Problem  n variables X1, ..., Xn  Valid assignment: {Xi1  vi1, ..., Xik  vik}, 0 k  n, such that the values vi1, ..., vik satisfy all constraints relating the variables Xi1, ..., Xik S lid i States: valid assignments  Initial state: empty assignment (k = 0)  Successor of a state: {Xi1vi1, ..., Xikvik}  {Xi1vi1, ..., Xikvik, Xik+1vik+1}  Goal test: complete assignment (k = n) 6 How to solve?  States: valid assignments  Initial state: empty assignment (k = 0)  Successor of a state: {Xi1vi1, ..., Xikvik}  {Xi1vi1, ..., Xikvik, Xik+1vik+1}  Goal test: complete assignment (k = n)Goal test: complete assignment (k n)  NOTE: If “regular” search algorithm is used, the branching factor is quite large since the successor function must try (1) all unassigned variables, and (2) for each of those variables, try all possible values A Key property of CSP: Commutativity The order in which variables are assigned values has no impact on the assignment reached Hence: 1) One can generate the successors of a node by first selecting one variable and then assigning every value in the domain of this variable [ big reduction in branching factor]  4 variables X1, ..., X4  Let the current assignment be: A = {X1  v1, X3  v3}  (For example) pick variable X4  Let the domain of X4 be {v41, v42, v43}4 { 4,1 4,2 4,3}  The successors of A are {X1  v1, X3  v3 , X4  v4,1 } {X1  v1, X3  v3 , X4  v4,2 } {X1  v1, X3  v3 , X4  v4,3 } A Key property of CSP: Commutativity The order in which variables are assigned values has no impact on the assignment reached Hence: 1) One can generate the successors of a node by first selecting one variable and then assigning every value in the domain of this variable [ big reduction in branching factor] 2) One need not store the path to a node  Backtracking search algorithm Backtracking Search Essentially a simplified depth-first algorithm using recursion Backtracking Search (3 variables) Assignment = {} 7 Backtracking Search (3 variables) X1 v11 Assignment = {(X1,v11)} Backtracking Search (3 variables) X1 v11 X Assignment = {(X1,v11), (X3,v31)} v31 X3 Backtracking Search (3 variables) X1 v11 X Then, the search algorithm Assignment = {(X1,v11), (X3,v31)} v31 X3 X2 Assume that no value of X2 leads to a valid assignment backtracks to the previous variable and tries another value Backtracking Search (3 variables) X1 v11 X Assignment = {(X1,v11), (X3,v32)} X3 v32v31 X2 Backtracking Search (3 variables) X1 v11 X The search algorithm backtracks to the previous variable (X3) and tries another value. But assume th t X hs l t Assignment = {(X1,v11), (X3,v32)} X3 v32 X2 Assume again that no value of X2 leads to a valid assignment that X3 has only two possible values. The algorithm backtracks to X1v31 X2 Backtracking Search (3 variables) X1 v11 X v12 Assignment = {(X1,v12)} X3 v32 X2 v31 X2 8 Backtracking Search (3 variables) X1 v11 X v12 X Assignment = {(X1,v12), (X2,v21)} X3 v32 X2 v31 X2 v21 X2 Backtracking Search (3 variables) X1 v11 X v12 X Assignment = {(X1,v12), (X2,v21)} X3 v32 X2 v31 X2 v21 X2 The algorithm need not consider the variables in the same order in this sub-tree as in the other Backtracking Search (3 variables) X1 v11 X v12 X Assignment = {(X1,v12), (X2,v21), (X3,v32)} X3 v32 X2 v31 X2 v21 X2 v32 X3 Backtracking Search (3 variables) X1 v11 X v12 X Assignment = {(X1,v12), (X2,v21), (X3,v32)} X3 v32 X2 v31 X2 v21 X2 v32 X3 The algorithm need not consider the values of X3 in the same order in this sub-tree Backtracking Search (3 variables) X1 v11 X v12 X Assignment = {(X1,v12), (X2,v21), (X3,v32)} X3 v32 X2 v31 X2 v21 X2 v32 X3 Since there are only three variables, the assignment is complete Backtracking Algorithm CSP-BACKTRACKING(A) 1. If assignment A is complete then return A 2. X  select a variable not in A 3. D  select an ordering on the domain of X 4. For each value v in D do dd ( ) a. Add (Xv) to A b. If A is valid then i. result  CSP-BACKTRACKING(A) ii. If result  failure then return result 5. Return failure Call CSP-BACKTRACKING({}) [This recursive algorithm keeps too much data in memory. An iterative version could save memory (left as an exercise)] 9 Map Coloring {} WA=red WA=green WA=blue WA=red NT=green WA=red NT=blue WA=red NT=green Q=red WA=red NT=green Q=blue WA NT SA Q NSW V T Critical Questions for the Efficiency of CSP-Backtracking CSP-BACKTRACKING(a) 1. If assignment A is complete then return A 2 X  select a variable not in A2. X  select a variable not in A 3. D  select an ordering on the domain of X 4. For each value v in D do a. Add (Xv) to A b. If a is valid then i. result  CSP-BACKTRACKING(A) ii. If result  failure then return result 5. Return failure Critical Questions for the Efficiency of CSP-Backtracking 1) Which variable X should be assigned a value next? The current assignment may not lead to any solution, but the algorithm still does know it. Selecting the right variable to which to assign a value may help gg y p discover the contradiction more quickly 2) In which order should X’s values be assigned? The current assignment may be part of a solution. Selecting the right value to assign to X may help discover this solution more quickly More on these questions in a short while ... 1) Which variable X should be assigned a value next? The current assignment may not lead to any solution, but the algorithm still does not know it. Selecting the right variable to which to assign a value may help Critical Questions for the Efficiency of CSP-Backtracking gg y p discover the contradiction more quickly. 2) In which order should X’s values be assigned? The current assignment may be part of a solution. Selecting the right value to assign to X may help discover this solution more quickly. More on these questions in a short while ... 1) Which variable X should be assigned a value next? The current assignment may not lead to any solution, but the algorithm still does not know it. Selecting the right variable to which to assign a value may help Critical Questions for the Efficiency of CSP-Backtracking gg y p discover the contradiction more quickly. 2) In which order should X’s values be assigned? The current assignment may be part of a solution. Selecting the right value to assign to X may help discover this solution more quickly. More on these questions in a short while ... Critical Questions for the Efficiency of CSP-Backtracking 1) Which variable X should be assigned a value next? The current assignment may not lead to any solution, but the algorithm still does not know it. Selecting the right variable to which to assign a value may help gg y p discover the contradiction more quickly. 2) In which order should X’s values be assigned? The current assignment may be part of a solution. Selecting the right value to assign to X may help discover this solution more quickly. More on these questions in a short while ... 10 Propagating Information Through Constraints • Our search algorithm considers the constraints on a variable only at the time that the variable is chosen to be given a valuevalue. • If we can we look at constraints earlier, we might be able to drastically reduce the search space. Forward Checking Assigning the value 5 to X1 ld t i l f 1 2 3 A simple constraint-propagation technique: leads to removing values from the domains of X2, X3, ..., X8 3 4 5 6 7 8 X1 X2 X3 X4 X5 X6 X7 X8 A simple constraint-propagation technique: Forward Checking Assigning the value 5 to X1 leads to removing values from the domains of X2, X3, ..., X8 1 2 3 4 5 6 7 Whenever a variable X is assigned, forward checking looks at each unassigned variable Y that is connected to X by a constraint, and removes from Y’s domain any value that is inconsistent with the value chosen for x. 8 X1 X2 X3 X4 X5 X6 X7 X8 Forward Checking in Map Coloring T WA NT SA Q NSW V WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB T WA NT SA Q NSW V Forward Checking in Map Coloring WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB RRGB RGB RGB RGB RGB RGB Forward checking removes the value Red of NT and of SA Forward Checking in Map Coloring T WA NT SA Q NSW V WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB R GB RGB RGB RGB GB RGB R GB G RGB RGB GB RGB 11 Forward Checking in Map Coloring T WA NT SA Q NSW V WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB R GB RGB RGB RGB GB RGB R B G RB RGBB RGB R B G RBB B RGB Forward Checking in Map Coloring Empty set: the current assignment {(WA  R), (Q  G), (V  B)} does not lead to a solution WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB R GB RGB RGB RGB GB RGB R B G RB RGBB RGB R B G RBB B RGB Forward Checking (General Form) When a pair (Xv) is added to assignment A do: For each variable Y not in A do: For every constraint C relating Y to X do:X do: Remove all values from Y’s domain that do not satisfy C Modified Backtracking Algorithm CSP-BACKTRACKING(A, var-domains) 1. If assignment A is complete then return A 2. X  select a variable not in A 3. D  select an ordering on the domain of X. D gm f X 4. For each value v in D do a. Add (Xv) to A b. var-domains  forward checking(var-domains, X, v, A) c. If a variable has an empty domain then return failure d. result  CSP-BACKTRACKING(A, var-domains) e. If result  failure then return result 5. Return failure Modified Backtracking Algorithm CSP-BACKTRACKING(A, var-domains) 1. If assignment A is complete then return A 2. X  select a variable not in A 3. D  select an ordering on the domain of X. D gm f X 4. For each value v in D do a. Add (Xv) to A b. var-domains  forward checking(var-domains, X, v, A) c. If a variable has an empty domain then return failure d. result  CSP-BACKTRACKING(A, var-domains) e. If result  failure then return result 5. Return failure No need any more to verify that A is valid Modified Backtracking Algorithm CSP-BACKTRACKING(A, var-domains) 1. If assignment A is complete then return A 2. X  select a variable not in A 3. D  select an ordering on the domain of X. D gm f X 4. For each value v in D do a. Add (Xv) to A b. var-domains  forward checking(var-domains, X, v, A) c. If a variable has an empty domain then return failure d. result  CSP-BACKTRACKING(A, var-domains) e. If result  failure then return result 5. Return failure Need to pass down the updated variable domains 12 1) Which variable Xi should be assigned a value next? Most-constrained-variable heuristic (also called minimum remaining values heuristic)  Most-constraining-variable heuristic 2) In which order should its values be assigned?  Least-constraining-value heuristicg Keep in mind that all variables must eventually get a value, while only one value from a domain must be assigned to each variable. The general idea with 1) is, if you are going to fail, do so as quickly as possible. With 2) it is give yourself the best chance for success. Most-Constrained-Variable Heuristic 1) Which variable Xi should be assigned a value next? Select the variable with the smallest dremaining domain [Rationale: Minimize the branching factor] 8-Queens New assignment Forward checking 4 3 2 3 4 Numbers of values for each un-assigned variable 8-Queens Forward checking 4 2 1 3 New numbers of values for each un-assigned variable New assignment Map Coloring WA NT SA Q NSW WA NT SA  SA’s remaining domain has size 1 (value Blue remaining)  Q’s remaining domain has size 2  NSW’s, V’s, and T’s remaining domains have size 3  Select SA V T Most-Constraining-Variable Heuristic 1) Which variable Xi should be assigned a value next? Among the variables with the smallest remaining domains (ties with respect to remaining domains (ties with respect to the most-constrained variable heuristic), select the one that appears in the largest number of constraints on variables not in the current assignment [Rationale: Increase future elimination of values, to reduce branching factors] 13 Map Coloring WA NT SA Q NSWSA V T  Before any value has been assigned, all variables have a domain of size 3, but SA is involved in more constraints (5) than any other variable  Select SA and assign a value to it (e.g., Blue) Least-Constraining-Value Heuristic 2) In which order should X’s values be assigned? Select the value of X that removes the smallest number of values from the domains of those variables which are not in the current assignmentnot in the current assignment [Rationale: Since only one value will eventually be assigned to X, pick the least-constraining value first, since it is the most likely one not to lead to an invalid assignment] [Note: Using this heuristic requires performing a forward-checking step for every value, not just for the selected value] Map Coloring WA NT SA Q NSW WA NT {} V T  Q’s domain has two remaining values: Blue and Red  Assigning Blue to Q would leave 0 value for SA, while assigning Red would leave 1 value Map Coloring WA NT SA Q NSW WA NT {Blue} V T  Q’s domain has two remaining values: Blue and Red  Assigning Blue to Q would leave 0 value for SA, while assigning Red would leave 1 value  So, assign Red to Q Constraint Propagation … … is the process of determining how the constraints and the possible values of one variable affect the possible values of other variables It is an important form of “least-commitment” reasoning Forward checking is only one simple form of constraint propagation When a pair (Xv) is added to assignment A do: For each variable Y not in A do: For every constraint C relating Y to variables in A do: Remove all values from Y’s domain that do not satisfy C 14 Forward Checking in Map Coloring Empty set: the current assignment {(WA  R), (Q  G), (V  B)} does not lead to a solution WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB R GB RGB RGB RGB GB RGB R B G RB RGBB RGB R B G RBB B RGB Forward Checking in Map Coloring T WA NT SA Q NSW V Contradiction that forward checking did not detect WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB R GB RGB RGB RGB GB RGB R B G RB RGBB RGB R B G RBB B RGB Forward Checking in Map Coloring T WA NT SA Q NSW V Contradiction that forward checking did not detect Detecting this contradiction requires a more powerful constraint propagation technique WA NT Q NSW V SA T RGB RGB RGB RGB RGB RGB RGB R GB RGB RGB RGB GB RGB R B G RB RGBB RGB R B G RBB B RGB pf pp g q Constraint Propagation for Binary Constraints REMOVE-VALUES(X,Y) 1. removed  false 2. For every value v in the domain of Y do – If there is no value u in the domain of X such that th t i t ( ) i ti fi d ththe constraint on (x,y) is satisfied then a. Remove v from Y‘s domain b. removed  true 3. Return removed Constraint Propagation for Binary Constraints AC3 1. contradiction  false 2. Initialize queue Q with all variables 3. While Q  and contradiction do a. X  Remove(Q) b. For every variable Y related to X by a constraint do – If REMOVE-VALUES(X,Y) then i. If Y’s domain =  then contradiction  true ii. Insert(Y,Q) Complexity Analysis of AC3  n = number of variables  d = size of initial domains  s = maximum number of constraints involving a given variable (s  n-1)given variable (s  n 1)  Each variables is inserted in Q up to d times  REMOVE-VALUES takes O(d2) time  AC3 takes O(n s d3) time  Usually more expensive than forward checking 15 Is AC3 all that we need?  No !!  AC3 can’t detect all contradictions among binary constraints X Y XY {1 2}{1 2} X Z Y XZ YZ {1, 2} {1, 2}{1, 2} Is AC3 all that we need?  No !!  AC3 can’t detect all contradictions among binary constraints X Y XY {1 2}{1 2} X Z Y XZ YZ {1, 2} {1, 2}{1, 2} Is AC3 all that we need?  No !!  AC3 can’t detect all contradictions among binary constraints X Y XY {1 2}{1 2} X Z Y XZ YZ {1, 2} {1, 2}{1, 2} Is AC3 all that we need?  No !!  AC3 can’t detect all contradictions among binary constraints X Y XY {1 2}{1 2}  Not all constraints are binary X Z Y XZ YZ {1, 2} {1, 2}{1, 2} Tradeoff Generalizing the constraint propagation algorithm increases its time complexity Tradeoff between backtracking and Tradeoff between backtracking and constraint propagation A good tradeoff is often to combine backtracking with forward checking and/or AC3 Modified Backtracking Algorithm with AC3 CSP-BACKTRACKING(A, var-domains) 1. If assignment A is complete then return A 2. var-domains  AC3(var-domains) 3. If a variable has an empty domain then return failure 4. X  select a variable not in A 5. D  select an ordering on the domain of X 6. For each value v in D do a. Add (Xv) to A b. var-domains  forward checking(var-domains, X, v, A) c. If a variable has an empty domain then return failure d. result  CSP-BACKTRACKING(A, var-domains) e. If result  failure then return result 7. Return failure 16 Modified Backtracking Algorithm with AC3 CSP-BACKTRACKING(A, var-domains) 1. If assignment A is complete then return A 2. var-domains  AC3(var-domains) 3. If a variable has an empty domain then return failure 4. X  select a variable not in A 5. D  select an ordering on the domain of X 6. For each value v in D do a. Add (Xv) to A b. var-domains  forward checking(var-domains, X, v, A) c. If a variable has an empty domain then return failure d. result  CSP-BACKTRACKING(A, var-domains) e. If result  failure then return result 7. Return failure AC3 and forward checking prevent the backtracking algorithm from committing early to some values A Complete Example: 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 1) The modified backtracking algorithm starts by calling AC3, which removes no value 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 2) The backtracking algorithm then selects a variable and a value for this variable. No heuristic helps in this selection. X1 and the value 1 are arbitrarily selected 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 3) The algorithm performs forward checking, which eliminates 2 values in each other variable’s domain 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 4) The algorithm calls AC3 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} X2 = 3 is inc mp tibl 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 4) The algorithm calls AC3, which eliminates 3 from the domain of X2 incompatible with any of the remaining values of X3 17 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 4) The algorithm calls AC3, which eliminates 3 from the domain of X2, and 2 from the domain of X3 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 4) The algorithm calls AC3, which eliminates 3 from the domain of X2, and 2 from the domain of X3, and 4 from the domain of X3 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 5) The domain of X3 is empty  backtracking 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 6) The algorithm removes 1 from X1’s domain and assign 2 to X1 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 7) The algorithm performs forward checking 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 8) The algorithm calls AC3 18 4-Queens Problem 1 3241 X1 {1,2,3,4} X2 {1,2,3,4} 3 2 4 X3 {1,2,3,4} X4 {1,2,3,4} 8) The algorithm calls AC3, which reduces the domains of X3 and X4 to a single variable Dependency-Directed Backtracking  Assume that CSP-BACTRACKING has successively picked values for k-1 variables: X1, then X2, ..., then Xk-1  It then tries to assign a value to Xk, but each remaining value in Xk’s domain leads to a contradiction, that is, an empty domain for another variable  Chronological backtracking consists of returning to Xk-1 (called the “most recent” variable) and picking another value for it  Instead, dependency-directed backtracking consists of: 1. Computing the conflict set made of all the variables involved in the constraints that have led either to removing values from Xk’s domain or to the empty domains which have caused the algorithm to reject each remaining value of Xk 2. Returning to the most recent variable in the conflict set Exploiting the Structure of CSP If the constraint graph contains several components, then solve one independent CSP per component T WA NT SA Q NSW V Exploiting the Structure of CSP If the constraint graph is a tree, then : 1. Order the variables from the root to the leaves  (X1, X2, …, Xn) 2 For j = n n-1 2 call X Y Z2. For j = n, n 1, …, 2 call REMOVE-VALUES(Xj, Xi) where Xi is the parent of Xj 3. Assign any valid value to X1 4. For j = 2, …, n do Assign any value to Xj consistent with the value assigned to Xi, where Xi is the parent of Xj Y Z U V W  (X, Y, Z, U, V, W) Exploiting the Structure of CSP Whenever a variable is assigned a value by the backtracking algorithm, propagate this value and remove the variable from th st i t hthe constraint graph WA NT SA Q NSW V Exploiting the Structure of CSP Whenever a variable is assigned a value by the backtracking algorithm, propagate this value and remove the variable from th st i t h WA NT Q NSW V the constraint graph If the graph becomes a tree, then proceed as shown in previous slide 19 Finally, don’t forget local search (see slides on Heuristic Search) Repeat n times: 1) Pick an initial state S at random with one queen in each column 2) Repeat k times: a) If GOAL?(S) then return S b) Pick an attacked queen Q at random c) Move Q it in its column to minimize the number of attacking queens is minimum  new S [min-conflicts heuristic]qm m m [m f] 3) Return failure 1 2 3 3 2 2 3 2 2 2 2 2 0 2 Applications of CSP  CSP techniques are widely used  Applications include: • Crew assignments to flights • Management of transportation fleetManagement of transportation fleet • Flight/rail schedules • Job shop scheduling • Task scheduling in port operations • Design, including spatial layout design • Radiosurgical procedures Constraint Propagation • The following shows how a more complicated problem (with constraints among 3 variables) can be solved by constraint satisfactionconstraint satisfaction. • It is merely an example from some old Stanford Slides just to see how it works… Semi-Magic Square  9 variables X1, ..., X9, each with domain {1, 2, 3}  7 constraints X1 X2 X3 This row must sum to 6 X4 X5 X6 This row must sum to 6 X7 X8 X9 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 Semi-Magic Square 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 Semi-Magic Square  We select the value 1 for X1  Forward checking can’t eliminate any value [only one variable has been assigned a value and every constraint involves 3 variables] 1 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 20 C.P. in Semi-Magic Square  But the only remaining valid triplets for X1, X2, and X3 are (1, 2, 3) and (1, 3, 2) 1 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. in Semi-Magic Square  But the only remaining valid triplets for X1, X2, and X3 are (1, 2, 3) and (1, 3, 2)  So, X2 and X3 can no longer take the value 1 1 2, 3 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 1, 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  In the same way, X4 and X7 can no longer take the value 1 1 2, 3 2, 3 This row must sum to 6 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 2, 3 1, 2, 3 1, 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  In the same way, X4 and X7 can no longer take the value 1  ... nor can X5 and X9 1 2, 3 2, 3 This row must sum to 6 2, 3 2, 3 1, 2, 3 This row must sum to 6 2, 3 1, 2, 3 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  Consider now a constraint that involves variables whose domains have been reduced 1 2, 3 2, 3 This row must sum to 6 2, 3 2, 3 1, 2, 3 This row must sum to 6 2, 3 1, 2, 3 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  For instance, take the 2nd column: the only remaining valid triplets are (2, 3, 1) and (3, 2, 1) 1 2, 3 2, 3 This row must sum to 6 2, 3 2, 3 1, 2, 3 This row must sum to 6 2, 3 1, 2, 3 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 21 Semi-Magic Square  For instance, take the 2nd column: the only remaining valid triplets are (2, 3, 1) and (3, 2, 1)  So, the remaining domain of X8 is {1} 1 2, 3 2, 3 This row must sum to 6 2, 3 2, 3 1, 2, 3 This row must sum to 6 2, 3 1 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  In the same way, we can reduce the domain of X6 to {1} 1 2, 3 2, 3 This row must sum to 6 2, 3 2, 3 1 This row must sum to 6 2, 3 1 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  We can’t eliminate more values  Let us pick X2 = 2 1 2, 3 2, 3 This row must sum to 6 2, 3 2, 3 1 This row must sum to 6 2, 3 1 2, 3 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6 C.P. Semi-Magic Square  Constraint propagation reduces the domains of X3, ..., X9 to a single value  Hence, we have a solution 12 3 This row must sum to 6 23 1 This row must sum to 6 31 2 This row must sum to 6 This column must sum to 6 This column must sum to 6 This column must sum to 6 This diagonal must sum to 6","libVersion":"0.2.3","langs":""}