{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Notes/more notes.pdf","text":"COS3711/MO001/4/2018 1 MO001/4/2018 Advanced Programming COS3711 Semesters 1 and 2 School of Computing IMPORTANT INFORMATION: This document contains important information about your module. 2 CONTENTS Page 1 Introduction 3 2 Home page 3 3 Unit 0 – Orientation 5 4 Unit 1 – Libraries 10 5 Unit 2 – Meta Objects, Properties and Reflective Programming 12 6 Unit 3 – Models and Views 14 7 Unit 4 – Validation and Regular Expressions 16 8 Assignment 1 17 9 Unit 5 – Parsing XML 19 10 Unit 6 – More Design Patterns 25 11 Unit 7 – Concurrency 31 12 Unit 8 – Networking and the Web 34 13 Assignment 2 35 COS3711/MO001/4/2018 3 1 Introduction Dear student As noted in tutorial letter 101, this is a blended module, and therefore much of your module is available on myUnisa. However, in order to support you in your learning process, we also provide this study material in printed format. Below you will find all the material that is available on the COS3711 site on myUnisa. 2 Home page COS3711 - Advanced Programming Welcome to COS3711 – a module on advanced programming concepts – from your lecturer, Mr Colin Pilkington. Major concepts The major concepts you will learn include:  Using libraries  Understanding and implementing design patterns (there are many design patterns, and you will focus on only a few this year)  XML parsing  Validating input  Reflective programming  Concurrency using threads and processes  Network and Web programming Assumed background knowledge It is assumed that you are proficient in the following skills (which you should have gained in your previous studies):  C++: creating classes and objects, inheritance and polymorphism, pointers, templates, reading from and writing to files, .h and .cpp file usage, and the use of public/protected/private  Qt: console and GUI applications, signals and slots, Qt container classes  Understanding UML diagrams  Design patterns: understanding of some design patterns such as Composite, Observer, Serializer, Flyweight, Monostate, and Command Assessment You will be assessed in various ways in this module. The 2 assignments are practical assignments, and you will have to design, code, compile, and run applications in preparation for submission. The exam, however, is a written exam (with no practical component), and you will be expected to understand the theory behind what you are doing, as well as writing code to implement concepts. You will continue using the Qt framework that has been used in COS2614 since 2010. We trust that you will enjoy this semester as you extend your C++ skills. Your responsibility A quick note about your responsibility as a student: you need to work through the prescribed textbook, tutorial letters and learning units, do all the exercises, and also do all the assignments – both the parts that are submitted for marking and the self-assessment parts. This will not guarantee success, but without it, it will be very difficult to pass. 4 Checking in with the technology ... In order to get started on this journey together, we need to make sure that you know what tools we will be using throughout the semester:  Home page: This is the page you are currently on, and you will always start on this landing page of the myUnisa site.  Learning Units: This is where you will find all the work for this semester, including what has to be studied and extra notes.  Announcements are added regularly, so please keep checking these.  The Calendar will remind you of important current events and information.  Official Study Material is where you will find past exams and some official tutorial letters.  A Questions and Answers tool allows you to post a question on the site. If this is of general interest to the whole group, the question and answer will be published for everyone to see and learn from. Contacting us Please feel free to contact one of us if you need help, and we look forward to guiding you through your studies this semester. Please also check on our availability on the Osprey server (http://osprey.unisa.ac.za/reg.htm). Take a look at the comic strip below that provides some guidelines when contacting us. Our equivalent of a T.A. is an e-tutor. \"Piled Higher and Deeper\" by Jorge Cham www.phdcomics.com Colin Pilkington Science campus, Florida Park GJ Gerwel building (old C block), 4-14 011-471-2130 Contact times: Monday to Friday, from 8:00 till 14:00 pilkicl@unisa.ac.za COS3711/MO001/4/2018 5 3 Unit 0 – Orientation Introduction Welcome Welcome to the Learning Units that will make up your study material for the semester. Here you will find out about the prescribed book, the work that you are expected to study from it, and the assignments that need to be done. It is important that you check the assessment and study plan page, as here you will find a guide to getting through all the material in the allotted time (as well as getting the assignments in on time). The first unit (Unit 0) covers more general topics that relate to the module. The rest of the learning units will guide you through the work that has to be studied as part of this module. You can use the Table of Contents to move to the unit that you want to view. Once you start moving around these pages, you can always return to the Table of Contents by clicking the link at the top or bottom centre of each page. There are also links here to the previous and next page in the sequence of pages in the Learning Units. Purpose COS3711 is a final year undergraduate module. We are obliged to offer a course that is comparable in standard to what other universities in the world offer in advanced programming concepts at this level. In the School of Computing, we opted for an advanced programming course using the public domain framework Qt 5. This module teaches a selection of design patterns to improve your existing object-oriented programming knowledge, new programming aspects such as concurrency, XML handling, and regular expressions as well as the reuse of open-source libraries and tools, using the Qt 5 framework. In addition, some network programming will be included. The topics covered in this module require a good working knowledge of C++ as well as object-oriented programming knowledge as covered in the first- and second-level programming modules. A more detailed list of what you are expected to know can be found on the home page for this module. After completing this module, you should have a deeper understanding of both the C++ language and the Qt libraries, as well as of the design patterns used in developing applications with them. Outcomes After completing this module you should be able to:  Understand, recognise and implement a number of design patterns  Understand and reuse libraries  Understand and implement concurrent programming techniques  Use regular expressions in an application environment  Generate and parse XML files  Understand and implement reflective programming  Write programs that connect to a network Books Prescribed book The prescribed book for COS3711 is: An Introduction to Design Patterns in C++ with Qt, Second edition. Alan Ezust and Paul Ezust Prentice Hall ISBN: 978-0-13-282645-7 6 Note that we are using the second edition of this book, and that it differs substantially from the various electronic copies of the book that you might find online. It also differs substantially from the version that was used in COS3711 in 2012. Hence you need to purchase a copy of the second edition. A picture of the book in included so that you can be sure that you are getting the correct book. The following chapters from Ezust are covered in COS3711:  Chapter 7 Libraries and Design Patterns  Chapter 12 Meta Objects, Properties, and Reflective Programming  Chapter 13 Models and Views  Chapter 14 Validation and Regular Expressions  Chapter 15 Parsing XML  Chapter 16 More Design Patterns  Chapter 17 Concurrency Part II of the prescribed book contains a C++ Language Reference which you can consult during your study. Recommended books The following two books can be used as additional references:  J. Blanchette & M. Summerfield. C++ GUI programming with Qt 4. Prentice-Hall.  E. Gamma, R. Helm, R. Johnson & J.M. Vlissides. Design Patterns: Elements of Reusable Object- Oriented Software. Addison-Wesley. Books online You can also find books on Qt (including the prescribed textbook and the Blanchette & Summerfield book) in the online resources from the Library.  Go to oasis.unisa.ac.za  Click on Library Links  Search for Information Resources  A-Z list of electronic resources  s  Safari Business and Tech Books Online  In the search box at the top right of the page, search the entire site for “Qt”.  You can then click on a book’s title, which should take you to the Table of Contents for that book. From here you can click on the chapter you want to read. Electronic resources Computer and internet access Students who register for COS3711 must have access to a suitable computer. The operating system must be MS Windows XP, service pack 2 or later. It is possible to use a computer with a Unix variant (such as Linux) but unfortunately we will not be able to provide assistance if you do. Prescribed software You should have received a disk from Unisa, referred to as Disk 2017, which includes all the software necessary to compile and run your applications for COS3711. The prescribed software for COS3711 is Qt 5. The disk contains a comprehensive software development kit (SDK) comprising a C++ compiler, the Qt 5 framework, and the Qt Creator IDE (as well as some other tools). You must install this software on your computer and use it for the programming exercises and assignments for this course. The prescribed software is also installed on the computers in all Unisa computer laboratories. If you did not receive Disk 2017 with your study package, or your disk was corrupted in some way, you can get a copy of it on the Osprey web server of the School of Computing at http://osprey.unisa.ac.za/download/Disk/. You could also go to http://qt-project.org/downloads to download the necessary files. COS3711/MO001/4/2018 7 Installing the software Instructions for installing and using the prescribed software are provided in tutorial letter 102, which you can find under Additional Resources on myUnisa. Using Qt 5 Note that although we are using the Qt 5 framework, the prescribed textbook is based on Qt 4. You can have a look at the Qt wiki site The Transition from Qt 4.x to Qt 5 (http://qt- project.org/wiki/Transition_from_Qt_4.x_to_Qt5) for more details on what changes need to be made. However, we have already made the necessary changes to the example code in the chapters that you need to study, and you can download these from the Additional Resources page (UpdatedSourceFiles.zip). Osprey web server The School of Computing also uses the Osprey web server (http://osprey.unisa.ac.za/). The purpose of this server is to provide information about the School. It does not offer student administration services. There is also a discussion forum here that can be used. Assessment and study plans Assessment plan You will be assessed in several ways in this module.  There are 2 assignments. o These are practical assignments that require you to design, code, compile, and run applications. o These should be done individually, and not in groups. o These each count 50% towards the semester mark. o Together, these 2 assignments count 20% towards the final module mark. In effect, each assignment counts 10% towards the final module mark.  There is 1 written exam. o This exam counts 80% towards the final module mark. o You must submit at least the first assignment by the due date to get admission to the exam. Assignments are not merely to give you admission to the exam, or to determine a year mark. The real purpose of assignments is to get you to engage with the material and to understand it. And there is no better way to learn the concepts and techniques of programming than to develop programs and get them to work. It is essential that you complete both assignments in preparation for the exam. It is a great pity that each semester there are students who pass the exam, but due to not having done well in the assignments, or not having done one of the assignments at all, they do not get the required 50% to pass the module. Make sure that this does not happen to you. Due dates Due dates and unique assignment numbers can be found in tutorial letter 101. Study plan There is a study plan available in tutorial letter 101 (also available as a PDF document in the Additional Resources), that you can use to guide your studies through the semester, and following it should ensure that you get both assignments in by the due dates. Plagiarism of assignments When your assignment has been marked, a percentage will be awarded. This is an indication of how correct your answers were, as well as the quality of your assignment. Copying other students’ solutions, or the official solutions from a previous or current semester, is plagiarism, which is a punishable offence 8 that may lead to expulsion from the university. At the very least you will receive 0 for a plagiarised assignment. Policy on extensions The time available for study is limited, so please adhere to the assignment due dates. We understand that there are sometimes reasons why you cannot submit an assignment by the due date, so the following allowance has been made:  If you submit Assignment 1 within one week after the due date, it will still be accepted and marked.  Assignments that are submitted after the one-week extension may be marked, but may not count towards your year mark.  We can unfortunately not allow extensions for assignment 2, as there is not enough time after the submission date to get all assignments marked and the marks submitted in time. Examination Use your my Studies @ Unisa brochure for general examination guidelines and examination preparation guidelines. Note the following:  Owing to regulatory requirements, in order to be considered for examination admission a student must submit at least Assignment 1.  The examination consists of one examination paper.  The examination paper is a 2-hour paper, and will be set in English only.  You will be examined on all the content covered in the assignments (including the self-assessment parts of the assignments), as well as all the content in the prescribed book, unless specifically stated otherwise.  Examination guidelines will be made available to all students before the examination.  Previous examination papers are available to students on myUnisa under Official Study Material. Activity One of the things that myUnisa does not have is the ability for you to create an online profile for yourself. This means that other students (and even your lecturers) know very little about you. Please take the time to go the Discussion forum, and to the Introductions forum. In a new topic, please introduce yourself to the group.  Tell us who you are: your name, and age (if you want to)  Maybe tell us a little about your background: where are you from, in which city do you currently live, do you have a full-time job, and so on.  What programming experience do you have? Have you ever heard of Qt? What is your opinion of it?  Also, read some of the introductions and respond to the introductions of the other students. Progressing through the study units Each of the learning units that follows this introductory section is broken into three parts:  Outcomes: This section tells you what you can expect to learn in the unit.  Study material: Here you will find which chapter of the prescribed book you are expected to study in the unit, to meet the assessment outcomes mentioned in the first section. There will also be an indication of how long you have to work with the material in this unit if you are to keep up to date with your studies.  Notes: Any particular points of interest will be picked up in this section, and so it may provide extra reading and other material that you should have a look at. The units that deal with the assignments will be structured differently, and here you will find the following:  Scope: This section will detail what work must be completed in order to attempt the assignment, as well as information on how to submit your answers. COS3711/MO001/4/2018 9  Assignment questions: This section will list all the questions that you will have to answer for the assignment. The questions will also be made available as a PDF file in the Additional Resources.  Assignment solutions: After the closing date, a discussion of the assignment will be posted as a tutorial letter (we will let you know that it has been posted via an announcement), and the sample solutions will be posted to the Additional Resources page. 10 4 Unit 1 - Libraries Outcomes After completing this chapter, you should be able to:  Know different containers of code and how they support code reuse  Install and use the libraries which accompany the prescribed book  Understand the concept of frameworks and APIs  Understand, identify, and implement the Serializer pattern  Describe the concept of an antiPattern Study Material Ezust You need to study Chapter 7 from the prescribed book. Time allocated You will need a week to study this unit. Notes Section 7.2: Installing Libraries Read through this section without downloading or installing any libraries suggested in this section. The installation of the Ezust libraries is detailed in tutorial letter 102, which you can download from the Official Study Material page. Section 7.4.1: Serializer Pattern The version of the Serializer pattern in Ezust does not follow the classic pattern. Rather use the description of it below. When you need to input or output the state of an object of some class (whether to and from the console, or to and from a file) it is not a good idea to include this code in the class definition. It is better to apply the Serializer pattern, and implement either or both Reader and Writer classes which do this on behalf of the class. Note that the pattern is not designed to handle input and output on behalf of Class1, it is used to store/load the state of Class1 objects. In this diagram, the client program uses an instance of Class1. If it wants to input the state of this instance (from a file or from the console) it declares an instance of Class1Reader, and calls its read() member function with the object as argument. A similar process is followed if the client program wants to output an instance of Class1. Take note: for this pattern to work efficiently, Class1 must be able to provide its complete state to Class1Writer, and it must allow Class1Reader to set its state fully. In C++, it is common to overload the stream extraction and insertion operators >> and << to input and output the state of an object of a given class. These can be written extremely simply in terms of Class1, Class1Reader and Class1Writer if the Serializer pattern has been applied. COS3711/MO001/4/2018 11 Watch the videos on myUnisa that revise topics from COS2614 that will be relevant in COS3711 again.  Polymorphism and polymorphic assignment  Qt’s child management facility  Signals and slots  Stack and heap memory 12 5 Unit 2 – Meta Objects, Properties and Reflective Programming Outcomes After completing this chapter, you should be able to:  Understand the MetaObject pattern  Understand Qt’s implementation of MetaObject  Implement reflective programming  Understand Qt’s support for run-time type identification  Understand the use of QMetaType Study Material Ezust You need to study Chapter 12 from the prescribed book. Time allocated You will need a week to study this unit. Notes Section 12.2: Type Identification (playlists.pro) Use the example in the playlists folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. This application may not want to compile, as the ui_mainwindow.h (created by Qt) cannot find the playlistsveiw.h or playlistview.h files, even though they are in the correct folder. This has to do with folder structures, and once you have built the application you may have to change the two lines #include \"playlistsview.h\" #include \"playlistview.h\" to #include \"..\\..\\playlists\\playlistsview.h\" #include \"..\\..\\playlists\\playlistview.h\" (or something similar, depending on where the ui_mainwindow.h file is located in relation to the two files it is looking for). Section 12.4: QVariant Class (properties.pro) Use the example in the properties folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. This application uses Qt’s testing capabilities to check customer properties. The output is either displayed in the Application Output window in the bottom pane of Qt Creator, or (if Run in terminal is checked) it will display in a console window. Section 12.6: MetaTypes The src\\metatype folder contains the fraction.h and metatype.cpp files needed for this example. To run this example, you will need to set up your own console project and add these two files to it. You need to make some changes before the program will compile and run:  In metatype.pro: make sure that QT += gui is included.  In fraction.h: Comment out the three overloaded << and >> operator functions below the class (or implement them yourself).  In metatype.cpp: There is a ; missing at the end of the qDebug() statement in the middle of main().  Also in metatype.cpp: in createTest(), change QMetaType::construct(fracType) to QMetaType::create(fracType).  Check the Run in terminal checkbox. COS3711/MO001/4/2018 13 Watch the videos on the using the meta-object and dynamic properties on myUnisa. 14 6 Unit 3 – Models and Views Outcomes After completing this chapter, you should be able to:  Understand and identify the Model-View-Controller pattern  Design and implement applications with separated models and views  Have an overview of Qt’s in-built models and views  Use Qt’s in-built model and view classes  Understand the role of delegates in Qt’s model/view framework  Understand the value of smart pointers Study Material Ezust You need to study Chapter 13 from the prescribed book. Time allocated You will need a week to study this unit. Notes Section 13.2.1: QFileSystemModel (filesystem.pro) Use the example in the filesystem folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 13.2.2: Multiple views (multiview.pro) Use the example in the multiview folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 13.2.3: Delegate Classes (stardelegate.pro) The example (figure 13.8) refers to $QTDIR/examples/modelview/stardelegate. This should be C:\\Qt\\Qt5.3.0\\Examples\\Qt-5.3\\widgets\\itemviews\\stardelegate. It produces the following output. Figure 13.8 is a modified version of the example: The examples in 13.5 and 13.6 refer to files in the playlist folder – again, use the folder that we have supplied, rather than the original, as the files have been updated to run in Qt 5. Section 13.3: Table models (page 414) Use the example in the shortcutmodel-standarditem folder that has been provided in UpdatedSourceFiles.zip (that you can get from the Additional Resources), to test the Examples13.10 to 13.12. This is a version that has been corrected and updated for Qt 5. COS3711/MO001/4/2018 15 Section 13.4: Tree Models (objectbrowser.pro) Use the example in the objectbrowser folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been corrected and updated for Qt 5. The model test was not working correctly, and has been commented out. Section 13.4.1: Trolltech Model Testing Tool You can simply read through this section; the programme does not work correctly in a Windows environment (and there are also problems with getting a debugger to work in a Windows environment). Section 13.5: Smart Pointers (dataobjects.pro) Add the following line to the .pro file: QT += widgets When you run this code, you will get several errors that indicate that QString has no member named toAscii – this function has been deprecated and replaced with toLatin1. You need to make all these changes in the dataobject.cpp file (lines 37, 159, 167, and 197), the qobjectreader.cpp file (line 63, 89 and 96), and the country.cpp file (line 30). Also, qVariantValue is deprecated. In qobjectreader.cpp, line 41, replace QTime t = qVariantValue<QTime>(val); with QTime t = val.value<QTime>();. Also, in qobjectwriter.cpp, line 72 onwards, change if (result == QString()) result = Qt::escape(val.toString()); else result = Qt::escape(result); return result; to if (result == QString()) result = QString(val.toString()).toHtmlEscaped(); else result = QString(result).toHtmlEscaped(); return result; Also, in qobjectwriter.cpp, line 107, change qFindChildren<QObject*>(obj, QString()); to obj->findChildren<QObject*>(QString()); This project has no executable file defined, so it will not actually run, but there should be no more compile errors. 16 7 Unit 4 – Validation and Regular Expressions Outcomes After completing this chapter, you should be able to:  Use input masks to control user input  Know the purpose of validators and Qt’s support for validators  Know how to set validators for input widgets in Qt  Know the purpose of regular expressions and an overview of the regular expression syntax  Understand the relationship between validators and regular expressions  Be able to write simple regular expressions for validation of input in Qt Study Material Ezust You need to study Chapter 14 from the prescribed book. Time allocated You will need a week to study this unit. Notes Section 14.1 Input Masks Use the example in the inputmask folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.2 Validators Use the example in the numvalidate folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.3 Regular Expressions At the bottom of page 443 there is a reference to a regular expression tester from Nokia in the src/regex- tester folder. Note that although the folder is there, there is no code for you to use. However, you can find the code in your Qt installation folder in C:\\Qt\\Qt5.3.0\\Examples\\Qt-5.3\\widgets\\tools\\regexp. Section 14.3.2 Regular Expressions: Phone Number Recognition (regexp.pro) Use the example in the regex folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.4 Regular Expression Validation Use the example in the regexval folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. Section 14.5 Subclassing QValidator Use the example in the palindrome folder that has been provided in UpdatedSourceFiles.zip that you can get from the Additional Resources. This is a version that has been updated for Qt 5. COS3711/MO001/4/2018 17 8 Assignment 1 Assignment 1 scope What is covered? This assignment is a practical assignment, and covers chapters 7, 12, 13 and 14 of Ezust. The assignment has two parts:  Part A should be submitted for marking.  Part B is for self-assessment purposes only, and should not be submitted. Note that concepts from it may be included in the exams. We will provide model solutions to both parts of the assignment. Both parts are equally important, and we strongly recommend that you tackle all the questions of both parts of the assignment, to gain the full benefit from it. How to submit the assignment As the assignments will be marked from running versions of your answers, you have to submit a .zip file containing all the code (.h and .cpp files), the project file (.pro), and any text or other files (if applicable). The .zip file should not contain any .exe or .o files (so do not include the build-desktop folder), and you can delete the .pro.user file as well. If there is additional information that you feel the lecturer needs to take note of, please include a readme.txt in the .zip file. Each question of the assignment should be submitted in a separate, appropriately named folder. All the .h, .cpp, and .pro files relating to a single question should be saved in the folder. Also, your project will only be tested in the prescribed software of this module. Hence you should make sure that your project runs in the prescribed software. Ensure that your submission is virus free! When marking your assignments, your .zip file will be unzipped, the project file will be built and the functionality of your application will be tested. Note that there are often marks awarded for submitting an assignment answer that builds and runs. Thus, even if you cannot complete all sections of a question, make sure that you have done what you can that still results in a running version of the program (even if it has limited functionality). No marks will be awarded for a project that does not build successfully. You should submit your assignment by post or electronically via myUnisa.  Electronic submission (the preferred route) o Create a .zip file of your assignment submission (as explained above). o Upload your single .zip file on myUnisa.  Postal or assignment-box submission o Create a CD with your assignment submission (in the format explained above) and place it in an assignment cover included in your study package. o Place your assignment in an envelope and submit it using the postal mail or one of Unisa’s assignment mailboxes. Time allocated You will need a week to complete this assignment. Due date Check tutorial letter 101 for the due date and unique assignment number for this assignment. 18 Assignment 1 questions The assignment questions can be found in tutorial letter 101. Assignment 1 solutions After the closing date, a discussion of the assignment will be posted as a tutorial letter, and the sample solutions will be posted to the Additional Resources page. COS3711/MO001/4/2018 19 9 Unit 5 – Parsing XML Outcomes After completing this chapter, you should be able to:  Understand Qt’s support for parsing XML  Have an understanding of SAX and DOM parsing in Qt  Implement parsing using the SAX-parser  Generate XML files using DOM  Implement parsing using DOM Study Material Ezust You need to study Chapter 15 from the prescribed book. Time allocated You will need a week to study this unit. Notes Working with XML Note that XML files can be set up in 2 different ways: one format uses tags (like book) with attributes (like title and pages): <library> <book title=”Computer Algorithms” pages=”688” /> <book title=”C++ unleashed” pages=”918” /> </library> or, using tags (book, title, and pages) with text (like Computer Algorithms and 688) <library> <book> <title>Computer Algorithms</title> <pages>688</pages> </book> <book> <title> C++ unleashed</title> <pages>918</pages> </book> </library> An element is anything from the start tag to the end tag of an element. So, library is an element, as is pages. Strictly speaking, attributes are supposed to supply extra information that is not part of the data (or text). However, there are no rules about when to use attributes and when to use elements. Some argue that using attributes is more limiting, and that using elements is more extensible. Note also that the indenting of the above text is simply to make it more readable. Further, taking the tree (or hierarchical) structure of XML seriously, an XML document must contain a root element, although it does not matter what this element’s name is: <root> .... </root> 20 This root then has branches that are called children: <root> <child> <sub_child> ... </sub_child> <sub_child> ... </sub_child> </child> <child> ... </child> </root> Section 15.2: SAX Parsing (sax1.pro) Use the example in the sax1 folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been updated for Qt 5. There are several things you need to note about running this example (which should run as given):  Note that the xml file that you want to parse should maybe be placed in the build-desktop folder instead of in its debug folder – it depends on which folders Qt will use as its default folder.  You can place several xml files here, and then list them in the Arguments edit box in Run Settings – remember to type at least one name (the samplefile.xml file, for example) in the Arguments box if you want the program to run.  If you are getting slightly garbled output, then use the samplefile1.xml that is also supplied in the sax1 folder – there is sometimes a problem with the new line and carriage return characters. The example given here simply parses the xml file and displays it. Suppose you had a Person class that had a name and an age. An xml file for this could look as follows: <people> <person name=”Xin” age=”12” /> <person name=”Ndou” age=”21” /> </people> You thus know the structure of the xml file. If you now wanted to parse this file and then create instances of your Person class, you could do something along the lines of the following: bool StockReader::startDocument() { return true; } bool StockReader::startElement(const QString &namespaceURI, const QString &localName, const QString &qName, const QXmlAttributes &atts) { if (qName == \"person\") { QString name = atts.value(0); //QString name = atts.value(“name”); //this is also a valid method int age = atts.value(1).toInt(); p.setName(name); p.setAge(age); } return true; Set values in an object Check the name of the tag We know that its first attribute is the name, and the second is the age COS3711/MO001/4/2018 21 } bool StockReader::endElement(const QString &namespaceURI, const QString &localName, const QString &qName) { return true; } bool StockReader::endDocument() { return true; } You would obviously have to have some way of dealing with p, the Person object that was created, and that would depend on your individual program. However, if the xml file is not based on attributes but on text, we could have the following: <people> <person> <name>Xin</name> <age>12</age> </person> <person> <name>Ndou</name> <age>21</age> </person> </people> Parsing this is different, and would involve something along the lines of the following. The variables used in the example (inName and inAge) would need to be members of the XMLHandler class: bool XMLHandler::startDocument() { inName = false; inAge = false; return true; } bool XMLHandler::startElement(const QString &namespaceURI, const QString &localName, const QString &qName, const QXmlAttributes &atts) { if (qName == \"name\") inName = true; if (qName == \"age\") inAge = true; return true; } bool XMLHandler::characters(const QString& text) { if (inName) { objectList.append(text); inName = false; } if (inAge) { objectList.append(text); inAge = false; Set flags so that we know which tag we are in Set the appropriate flag Handle the text between the opening and closing tag, and reset the flag 22 } return true; } bool XMLHandler::endElement(const QString &namespaceURI, const QString &localName, const QString &qName) { if (qName == \"person\") { p.setName(objectList[0]); p.setAge(objectList[1].toInt()); pl.append(p); objectList.clear(); } return true; } bool XMLHandler::endDocument() { return true; } Section 15.3.1: DOM Tree Walking (domwalker.pro) Use the example in the domwalker folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been updated for Qt 5. Remember to put the samplefile.xml file in the build-desktop folder, so that the example can read this file. This example uses a form of the classic Visitor pattern, but as you are not expected to know this design pattern, this will not be discussed further. Section 15.3.2: Generation of XML with DOM (dombuilder.pro) Note the comment at the top of page 472 (the first paragraph of this section): it is better to generate XML documents using an API, than hard coding the output to ensure that the output is parsable. Thus, while you can do this: toFile << \"<people>\" << endl; toFile << \" <person name=\\\"\" << name << \"\\\" age=\\\"\" << age; toFile << \"\\\" />\" << endl; toFile << \"</people>\" << endl; it is better to use the more complicated DOM approach. Use the example in the dombuilder folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been corrected. Example 15.15 refers to folder src/libs/docbook/ – this can be found in the c:\\projects\\libs\\docbook folder, and you can find the files referred to there. Example 15.14 is a Linux alternative. XSL stands for EXtensible Stylesheet Language, and XSLT stands for XSL Transformations – transforming XML (whose tags are not well understood by browsers) documents to other formats like XHTML (whose tags are well understood by browsers). Windows has its own command line XSLT processor, named msxsl.exe. This file can be downloaded from http://www.microsoft.com/en-za/download/details.aspx?id=21714. As you can see from the screenshot below, to use msxsl you need to give the name of the source file and the name of the stylesheet that defines the styles. If you would like to learn XSLT, look at the tutorial at http://www.w3schools.com/xsl/. Once we are back at the closing tag for person, we have all the detail we need to instantiate an object COS3711/MO001/4/2018 23 More on generation of XML with DOM If you wanted to manually construct XML from an object, you can use the following outline. Say we wanted to create the following XML document: <people> <person> <name>Xin</name> <age>12</age> </person> <person> <name>Ndou</name> <age>21</age> </person> </people> You will need to create the document and a root: QDomDocument doc; QDomElement rootElement = doc.createElement(\"people\"); doc.appendChild(rootElement); Then, for each child, you would create it as follows: QDomElement personElement = doc.createElement(\"person\"); rootElement.appendChild(personElement); QDomElement nameElement = doc.createElement(\"name\"); personElement.appendChild(nameElement); QDomText nameText = doc.createTextNode(name); nameElement.appendChild(nameText); QDomElement ageElement = doc.createElement(\"age\"); personElement.appendChild(ageElement); QDomText ageText = doc.createTextNode(age [as a string]); ageElement.appendChild(ageText); This then creates the XML document in a manner that you can be certain will be parsable. Section 15.4: XML Streams (streambuilder.pro) Use the example in the streambuilder folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a version that has been updated for Qt 5. Root element 1st child 2nd child Create root element Create document Add root to document Create child element and add it to the root Create name element and add it to person Create the text and add it to the name element Now do the same for age 24 Tutorial There is a very nice, concise introduction to SAX and DOM XML parsing in Qt at http://www.digitalfanatics.org/projects/qt_tutorial/chapter09.html. Although it is part of a larger tutorial, it is clear enough to follow. One could, of course, go back to some of the previous tutorials and build the address book application that is used. COS3711/MO001/4/2018 25 10 Unit 6 – More Design Patterns Outcomes After completing this chapter, you should be able to:  Understand, identify and implement the Factory Method pattern  Understand, identify and implement the Abstract Factory pattern  Understand, identify and implement the Singleton pattern  Understand, identify and implement the Memento pattern  Understand, identify and implement the Façade pattern  Understand, identify and implement the Strategy pattern  Understand, identify and implement the Adapter/Wrapper pattern Study Material Ezust You need to study Chapter 16 from the prescribed book. Time allocated You will need a week to study this unit. Notes Section 16.1: Creational Patterns Ezust discusses both the  Factory Method, and  Abstract Factory design patterns. Watch the videos on these patterns on myUnisa, and then make sure that you can describe the differences between these patterns beyond what is given in Ezust. Further notes on creational patterns (1) Factory Method Pattern This design pattern is applicable when a class needs to create objects but doesn’t know which objects to create, and the responsibility for creating objects can be transferred to the subclasses. So, this design pattern defines a class with a function for creating an object, but the subclasses implement this function to create appropriate objects. The UML structure of this design pattern is given below: The main classes included in the UML diagram are: 26 Product: defines the interface of the objects to be created by the Factory. ConcreteProduct: implements the Product interface, which is created by the ConcreteFactory. Factory: declares the factoryMethod(), which returns an object of type Product. ConcreteFactory: overrides the factoryMethod() to return an instance of type ConcreteProduct. There are a number of variations of this design pattern. Firstly, the FactoryMethod() in Factory may provide a default implementation of the factory method, and it may call the FactoryMethod in one of its functions (operation()). This means the Factory is not always necessarily abstract. Secondly, the factory method could take parameters and based on them, several different objects can be created. This means a ConcreteFactory may create more than one type of object. (2) Abstract Factory Pattern This design pattern is applicable when you need to create families of related or dependent objects. This design pattern mainly has two hierarchies: (1) Hierarchies of product classes, whose objects are meant to be used together. (2) Then you have a hierarchy of factory classes to facilitate creation of the product classes. The UML structure of the design pattern is given below: The main classes included in the UML diagram are: AbstractProductA and AbstractProductB: abstract classes of two related product classes. ProductA1 and ProductA2: concrete product A classes. ProductB1 and ProductB2: concrete product B classes. AbstractFactory: abstract factory class that declares functions for creating product A and B objects. ConcreteFactory1 and ConcreteFactory2: concrete factories, which implement functions declared in the AbstractFactory to create concrete product A and B classes. Client: it only uses the functions declared in AbstractProductA, AbstractProductB and AbstractFactory. Using this design pattern, the client does not know about the implementation details of the concrete product families and it can interchangeably use any of the concrete factories to create the appropriate concrete products. (3) Singleton This design pattern is applicable when you want to have a class which has only one instance, and this single instance can be accessed via a global access point. This is generally achieved by making the constructor of the class private, creating one instance, and a function that can be used to return the single instance. COS3711/MO001/4/2018 27 Since there is only one class involved, a UML diagram is not include here. Instead, one way of implementing Singleton is demonstrated below: Class definition class A{ public: static A* getInstance(); private: A(); static A* onlyInstance; }; Class implementation A* A::onlyInstance = NULL; A::A(){} A* A::getInstance(){ if(onlyInstance == 0) onlyInstance = new A(); return onlyInstance; } As demonstrated in the code, the single instance of A is stored in the static variable onlyInstance. When a request for an A instance is made via getInstance(), an instance of A is created and stored in onlyInstance. All subsequent calls to getInstance() do not create new instances but rather return the only instance of A stored in onlyInstance. Section 16.1.4: Polymorphism from Constructors You will need to create your own project to test this little program. Remember to check the Run in terminal box on the Run Settings tab. Otherwise, the program should run as described in Ezust. Section 16.2: Memento Pattern According to the Gang of Four (E. Gamma, R. Helm, R. Johnson & J.M. Vlissides: Design Patterns: Elements of Reusable Object-Oriented Software), a memento is an object that stores a snapshot of the internal state of another object, and this state can only be “read” by the original object. This allows an object’s state to be restored at some later point, allowing for an “undo” or a rollback operation. What we have in this section is not the memento pattern, but rather an implementation of the serializer pattern. The Gang of Four do not include the serializer pattern in their set of patterns, although other authors do. Serializer is used to stream objects into other data structures (writing), and is also responsible for restoring objects from such a data structure (reading). It is commonly used to write and restore the state of an object to a file or database, allowing for storage and retrieval. Go back and have a look at the notes in Unit 1; see also section 7.4.1 on page 249. A comment here about QObjectReader and QObjectWriter. These follow the idea of a serializer well, in that neither knows anything about the structure of the objects passed to it, and serializes the object as it finds it. The StockControl project in the UpdatedSourceFiles.zip is a running version of an application that uses the QObjectWriter and QObjectReader classes. Note also that the files referred to in examples 16.11-14 can be found in C:\\projects\\libs\\dataobjects. Further notes on the Memento Pattern The Memento pattern is a behavioural pattern. This design pattern is applicable when the state of an object needs to be saved so that its state can be restored later without violating the encapsulation of the class. The data members of the class, which determine the state of its objects, may not all be accessible (via setters and getters) outside the class. Hence the class itself has to be involved in saving and restoring the state of its objects. 28 The UML structure of the design pattern is given below: The main classes involved in the UML diagram are: Originator: state of the objects of this class are being saved and restored. To save the state of an object, it creates a snapshot of its state by creating a Memento, via the createMemento() function. To restore the state of the object, it uses a Memento via the setMemento() function. Memento: stores the state of an Originator. Caretaker: it keeps the Memento. The role of the Caretaker is only to store the Memento, and it is not allowed to access the state of the Originator saved in the Memento. One way of achieving this is by making the getState(), setState(),and even the constructor of Memento, private, so that the Caretaker cannot access the state of the Originator. However Orginator needs to be able to access the constructor, getState(), and setState() of Memento. One way of achieving this is by making Originator a friend of Memento. Caretaker requests a snapshot of an Originator using the createMemento() function. The Originator in turn creates a snapshot of its state by passing its state to Memento, and thus creating a Memento, which is then passed to the Caretaker. If the state of the Originator has to be restored, then Caretaker can invoke the setMemento() function to restore the state of the Originator. See also the video on the Memento pattern in the Additional Resources. Section 16.3: Façade Pattern Note also that the files referred to in examples 16.15-19 can also be found in C:\\projects\\libs\\metadata and C:\\projects\\libs\\filetagger. Further notes on the Façade Pattern The Façade pattern is a structural pattern. The Façade pattern is applicable when you would like to provide a simplified interface to a complicated set of systems but yet allowing the client to access the functionality of the underlying system. This design pattern defines a Façade that interacts and invokes the subsystems to satisfy the request of the client. A simplified diagram of this design pattern is given below: COS3711/MO001/4/2018 29 More design patterns Behavioural Patterns: Strategy pattern The Strategy pattern is applicable when there is a family of algorithms that needs to be made interchangeable based on the context. Using this design pattern, each algorithm is encapsulated in a class, and the run time selection of a relevant algorithm is made possible. The UML diagram of this design pattern is given below: The classes involved in this UML diagram are: Strategy: It is the class which defines a common interface (here the function Algorithm()) for the classes that represents the family of algorithms. It is generally an abstract class, and is sometimes referred to as an abstract strategy. StrategyOne, StrategyTwo and StrategyThree: These are the concrete strategies, which each define the Algorithm() function. These classes are sometimes referred to as concrete strategies. Context: Context has a reference to a Strategy, and it can decide on the concrete strategy to choose, based on the requirement. See also the videos on the Strategy pattern, as well as a combination of the Strategy and Factory Method patterns, in the Additional Resources. Structural Patterns: Adapter/Wrapper Pattern This design pattern is applicable when the functionality of a class can be reused but the interface of the class is not compatible with the existing classes. So, this design pattern converts the interface of an existing class into another, as expected by the client. This design pattern is sometimes called a Wrapper pattern, since it can be seen as wrapping around an existing class to present a different interface to other classes. 30 There are two forms (Class Adapter and Object Adapter) of the Adapter pattern, and the UML diagrams of both forms of the Adapter pattern are given below: Class Adapter: Object Adapter: The main classes included in the UML diagram are: Client: uses objects conforming to the Target interface Target: defines the domain-specific interface used by the Client Adaptee: defines the interface of an existing class to be reused Adapter: adapts the interface of Adaptee to the Target interface In a Class Adapter, Adapter adapts the interface of Adaptee by inheriting from Adaptee. In the Request() function of the Adapter, it simply invokes the SpecificRequest() function in Adaptee. Here the client call operates on an Adapter instance, which in turn calls Adaptee operations (SpecificRequest(), for instance), which carry out the operation. In an Object Adapter, Adapter adapts the interface of Adaptee by creating an instance of Adaptee (adaptee). In the Request() function of the Adapter, it simply invokes the SpecificRequest() function on the instance of Adaptee. Here the client call operates on an Adapter instance, which in turn calls operations on the Adaptee instance to carry out the operation. References See the following sources for more information on design patterns: E. Gamma, R. Helm, R. Johnson & J.M. Vlissides. (1995). Design Patterns: Elements of Reusable Object-Oriented Software. Addision-Wesley. C.G. Lasater. (2007). Design Patterns. Wordware Applications Library. COS3711/MO001/4/2018 31 11 Unit 7 - Concurrency Outcomes After completing this chapter, you should be able to:  Know the different classes in Qt for implementing concurrency  Understand and implement multiprocessing using the QProcess class  Understand and implement multithreading using the QThread class  Understand thread safety and the classes available in Qt for thread safety Study Material Ezust You need to study Chapter 17 from the prescribed book. Time allocated You will need a week to study this unit. Notes Section 17.1: QProcess and Process Control (randomNumbers.pro and logRandom.pro) The LogTail project, as included in Ezust, does not produce the desired output on Windows, because the command tail is only applicable on a UNIX variant operating system. A new example is provided in UpdatedSourceFiles.zip (in the QProcess and process control folder) to demonstrate starting, controlling, and communicating with other processes similar to LogTail. To test the new project, follow the instructions below.  Firstly, open, build, and run the randomNumbers project so that randomNumbers.exe is generated in the debug folder of the project. This project should display 10 random numbers. You can now close this project.  Secondly, open and build the logRandom project. Before you execute the project, copy and paste randomNumbers.exe from the debug folder of the randomNumbers project RandomNumbers into the build (or debug, depending on where Qt will look for it) folder of the logRandom project. Run the project to view the output. Section 17.1.1: Processes and Environment (environment.pro) Use the example in the QProcess and process control\\environment folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a modified version of this example, which works exactly as described in Ezust. Test the project using the command line argument –f NULL. The only difference is that the Windows version uses putenv rather than setenv, and different environment variables are used (ones that are known in a Windows environment). Section 17.1.2: Qonsole (qonsole1.pro) Use the example in the qonsole1 folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is a corrected version that includes a project file. In a Windows environment, you can use commands like  dir (to list directory contents)  cd (to change to another directory)  md (to make a directory)  date (to get the current date; you will need to press <Enter> a second time to bypass updating the date)  help (to get help) 32 to check that the example is working. Please remember to type in the command exit before you close the window, to exit the command line process. Section 17.1.3: Qonsole with keyboard events (keyevents.pro) Use the example in the keyevents folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is an updated version for Qt 5. Section 17.2.2: Parallel prime number calculators (PrimeThreads.pro) Use the example in the PrimeThreads folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is an updated version for Qt 5. Section 17.2.3: Concurrent map/reduce example (life.pro) Use the example in the life folder that has been provided in UpdatedSourceFiles.zip, which you can get from the Additional Resources. This is an updated version for Qt 5. An alternate approach to threading There are many who have argued that the way threading is shown in older Qt documentation is incorrect, and that there are better ways of doing it. The argument about the way threading is shown in the Qt documentation being wrong, relates to the way things were done in earlier versions of Qt (when QThread was abstract and subclassing it was required), that have now been changed in later versions (from Qt 4.4). The issue arises around what is known as thread affinity and the signal/slot system: Qt needs to check in which thread the sending and receiving objects are, and simply creating an instance of a class that is subclassed from QThread does not mean that it will, in fact, run in a separate thread. What is being done (subclassing QThread) works, but it is not how QThread was designed to be used; note also that it is not wrong, but may be bad object-orientated programming practice. QThread was designed as an interface (or control point), and not as a place to put code that is meant to be run in a thread. Also, QThread functions were intended to be called from the creating thread, and not the thread that QThread starts. Further, if you think about it, in OOP we create objects to do specific work, and making it part of a QThread hierarchy by subclassing QThread implies that this work is somehow an extension of QThread, which it really is not. Thus, this new approach keeps the thread code and the code of your specific object separate and encapsulated – a good OOP principle. Realise that QThread itself is an object, not a thread; it is just a wrapper around a thread that allows you to control the thread. So, the thread affinity of the QThread object is not necessarily the same as the actual thread (that is, the QThread object may be running in a different thread from the thread that is being created: the QThread object’s affinity will be the same as the thread that constructed the object, which would be the main thread). It has been argued that it is not necessary to subclass QThread at all. We present a brief example of this alternative approach, based on a PrimeFinder class that is used to find prime numbers, where PrimeFinder is implemented as a thread. Thus we get class PrimeFinder : public QObject { Q_OBJECT public slots: findPrime(); signals: finished(); //and so on }; int main() { COS3711/MO001/4/2018 33 PrimeFinder pf; QThread t; pf.moveToThread(&t); QObject::connect(&t, SIGNAL(started()), &pf, SLOT(findPrime())); QObject::connect(&pf, SIGNAL(finished()), &t, SLOT(quit())); t.start(); // and so on } As PrimeFinder is a QObject, its thread affinity is the same as that which created it – in this case the main thread. If you want it to run in a different thread, then you use the moveToThread() function. The moveToThread() function tells Qt that the event handlers, and the signals and slots, are dealt with from the indicated thread context. The started() signal of the thread is connected to the function in PrimeFinder that does the work; this function in PrimeFinder should emit a finished() signal once it is done. Then, the finished() signal of the PrimeFinder object is linked to the quit() slot of the thread. It is possible to have multiple instances of the PrimeFinder class assigned to a single thread, or multiple instances of several different classes assigned to a single thread. There is no need to tie a single instance of a class to a single thread. There is a really good video at http://www.voidrealms.com/viewtutorial.aspx?id=76 which demonstrates this quite well, and is worth having a look at. This was put together from the following sources, and reading these will also give you some more insight: http://exys.org/blog/entries/2010/QThread_affinity.qt.html http://blog.qt.digia.com/blog/2010/06/17/youre-doing-it-wrong/ http://stackoverflow.com/questions/4093159/what-is-the-correct-way-to-implement-a-qthread-example- please http://codethis.wordpress.com/2011/04/04/using-qthread-without-subclassing/ 34 12 Unit 8 – Networking and the Web Outcomes After completing this learning unit, you should be able to:  Know how to integrate Qt applications and the Web  Create a web plugin  Know the difference between, and use of, various networking protocols, including FTP, TCP, and UDP  Understand and implement the process and tools Qt provides to handle networked applications Study Material Extra notes You need to study the extra notes that are available as tutorial letter 103 in Official Study Material. The necessary source code to compile and run the code examples can be found in the UpdatedSourceFiles.zip file. Time allocated You will need a week to study this unit. Notes 2: Creating a simple web browser You may get a warning of leaks when you close the dialog window (if you have actually navigated to a web page). This is a bug in Qt 5, and is only related to building a Debug configuration, and does not happen if you build a Release configuration. COS3711/MO001/4/2018 35 13 Assignment 2 Assignment 2 scope What is covered? This assignment is a practical assignment and covers chapters 15, 16, 17 of Ezust and the notes on programming for networks and the Web. The assignment has two parts. Part A should be submitted for marking, but Part B should not. Part B is for self-assessment purposes only (and concepts from it may be included in the exams). We will provide model solutions to both parts of the assignment. Both parts are equally important, and we strongly recommend that you tackle all the questions of both parts of the assignment, to gain the full benefit from it. How to submit the assignment As the assignments will be marked from running versions of your answers, you have to submit a .zip file containing all the code (.h and .cpp files), the project file (.pro), and any text or other files (if applicable). The .zip file should not contain any .exe or .o files (so do not include the build-desktop folder), and you can delete the .pro.user file as well. If there is additional information that you feel the lecturer needs to take note of, please include a readme.txt in the .zip file. Each question of the assignment should be submitted in a separate, appropriately named folder. All the .h, .cpp, and .pro files relating to a single question should be saved in the folder. Also, your project will only be tested in the prescribed software of this module. Hence you should make sure that your project runs in the prescribed software. Ensure that your submission is virus free! When marking your assignments, your .zip file will be unzipped, the project file will be built and the functionality of your application will be tested. Note that there are often marks awarded for submitting an assignment answer that builds and runs. Thus, even if you cannot complete all sections of a question, make sure that you have done what you can that still results in a running version of the program (even if it has limited functionality). No marks will be awarded for a project that does not build successfully. You should submit your assignment by post or electronically via myUnisa.  Electronic submission (the preferred route) o Create a .zip file of your assignment submission (as explained above). o Upload your single .zip file on myUnisa.  Postal or assignment-box submission o Create a CD with your assignment submission (in the format explained above) and place it in an assignment cover included in your study package. o Place your assignment in an envelope and submit it using the postal mail or one of Unisa’s assignment mailboxes. Time allocated You will need a week to complete this assignment. Due date Check tutorial letter 101 for the due date and unique assignment number for this assignment. 36 Assignment 2 questions The assignment questions can be found in tutorial letter 101. Assignment 2 solutions After the closing date, a discussion of the assignment will be posted as a tutorial letter, and the sample solutions will be posted to the Additional Resources page. © UNISA 2018","libVersion":"0.2.3","langs":""}