{"path":"Subjects/COS2601 - Theoretical Computer Science II/Unsorted/Assignments/COS2601-2018-1-202.pdf","text":"COS2601/202/1/2018 Tutorial letter 202/1/2018 Theoretical Computer Science II COS2601 Semester 1 School of Computing Discussion of Assignment 2 BARCODE COS2601/202/1/2018 2 Dear student Solutions to the questions of assignment 2 are provided in this tutorial letter. For this assignment, the following questions were used for calculating a mark for the assignment. Question 1 13 marks Question 2 14 marks Question 3 6 marks Question 5 7 marks TOTAL 40 marks The rest of the questions were only commented on, and not allocated a mark. Remember to do the â€œAutomataâ€ and â€œPumping lemmasâ€ tutorials which are available on a CD that you should have received. Everything of the best with your studies! Regards COS2601 team Question 1 A recursive definition for the language EVENnotAAA over the alphabet ï“ = {a b} must be compiled where EVENnotAAA consists of all words of even length and not containing the substring aaa. Give (i) an appropriate universal set, (ii) the generator(s) of EVENnotAAA, and (iii) an appropriate function on the universal set, and then (iv) use these concepts to write down a recursive definition of the language EVENnotAAA. Answer (i) The set Î£ = {a b}* will be suitable because it contains, along with other words, all the words that are in the language EVENnotAAA. (ii) The generators should be of even length and should not contain the substring aaa. One possible choice is ïŒ. Another possible choice is ïŒ, aa, ab, ba and bb. Note that zero is an even number. (iii) The function CONCAT as defined in the notes in the learning units, will be suitable. (iv) We give two possible recursive definitions (the first one where letters are concatenated at the end of words, the second one where they are concatenated at the start of words). Note that all words in EVENnotAAA should have an even number of letters. The generators all have an even number of letters, therefore, to keep the length of new words even, we concatenate two letters at a time. EVENnotAAA is the smallest subset of {a b}* such that ïŒ ïƒ EVENnotAAA and if w ïƒ EVENnotAAA, then also CONCAT(w, bb) and CONCAT(w, ba) ïƒ EVENnotAAA, if w ïƒ EVENnotAAA and w does not end on an a, then CONCAT(w, aa) ïƒ EVENnotAAA, and if w ïƒ EVENnotAAA and w does not end on an aa, then CONCAT(w, ab) ïƒ EVENnotAAA. or Rule 1: ïŒ, aa, ab, ba, bb ïƒ EVENnotAAA. Rule 2: If w ïƒ EVENnotAAA, then also COS2601/202/1/2018 3 CONCAT(bb, w), CONCAT(ab, w) ïƒ EVENnotAAA, if w ïƒ EVENnotAAA and w does not start on an a, then CONCAT(aa, w) ïƒ EVENnotAAA, and if w ïƒ EVENnotAAA and w does not start on an aa, then CONCAT(ba, w) ïƒ EVENnotAAA Rule 3: Only words produced by rules 1 and 2 are in EVENnotAAA. Note that we have used the case where letters are added to the end of words for the first alternative answer, and where letters are added to the front of words in the second alternative answer. It would not be wrong to include both options (that is, letters added to the front and back) in an answer, but it is not necessary. Question 2 This question has three parts and tests mathematical induction. (i) Give a recursive definition of the set P of all positive integers greater than 0, (ii) formulate the applicable induction principle and then (iii) apply the induction principle to prove that, for all integers n ïƒ N. 1 1 . 4 + 1 4 . 7 + â‹¯ + 1 (3ğ‘› âˆ’ 2)(3ğ‘› + 1) = ğ‘› (3ğ‘› + 1) Note that this may also be written as âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) ğ‘› ğ‘–=1 = ğ‘› (3ğ‘› + 1) Answer (i) P is the smallest subset of Z such that 1 ïƒ P and if n ïƒ P, then also n + 1 ïƒ P. (ii) If a subset A of P is such that 1 ïƒ A and if k ïƒ A, then also k + 1 ïƒ A, then A = P. (iii) Define A ïƒ P as follows: ğ´ = {ğ‘› âˆˆ P| âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) ğ‘› ğ‘–=1 = ğ‘› (3ğ‘› + 1) , ğ‘› âˆˆ â„•} The first step is to find out whether 1 ïƒ A: LHS: 1/(1)(4) = 1/4 RHS: 1/(4) = 1/4 This means that LHS = RHS, so, 1 ïƒ A. The next step is to assume that k ïƒ A. Thus, we assume âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) ğ‘˜ ğ‘–=1 = ğ‘˜ (3ğ‘˜ + 1) The third step is to show that k + 1 ïƒ A, i.e. we need to show that âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) ğ‘˜+1 ğ‘–=1 = ğ‘˜ + 1 (3(ğ‘˜ + 1) + 1) = ğ‘˜ + 1 (3ğ‘˜ + 4) COS2601/202/1/2018 4 Starting with the LHS, we split it into the sum to k and the (k+1) part, replace the sum to k part with our assumption, and then simplify. We eventually reach the RHS as required. âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) ğ‘˜+1 ğ‘–=1 = âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) + ğ‘˜ ğ‘–=1 1 (3(ğ‘˜ + 1) âˆ’ 2)(3(ğ‘˜ + 1) + 1) = ğ‘˜ (3ğ‘˜ + 1) + 1 (3ğ‘˜ + 1)(3ğ‘˜ + 4) = ğ‘˜(3ğ‘˜ + 4) (3ğ‘˜ + 1)(3ğ‘˜ + 4) + 1 (3ğ‘˜ + 1)(3ğ‘˜ + 4) = ğ‘˜(3ğ‘˜ + 4) + 1 (3ğ‘˜ + 1)(3ğ‘˜ + 4) = 3ğ‘˜2 + 4ğ‘˜ + 1 (3ğ‘˜ + 1)(3ğ‘˜ + 4) = (3ğ‘˜ + 1)(ğ‘˜ + 1) (3ğ‘˜ + 1)(3ğ‘˜ + 4) = (ğ‘˜ + 1) (3ğ‘˜ + 4) We have shown that k+1 ïƒ A. From the induction principle above, it follows that A = P. Thus, for all integers integers n ïƒ N âˆ‘ 1 (3ğ‘– âˆ’ 2)(3ğ‘– + 1) ğ‘› ğ‘–=1 = ğ‘› (3ğ‘› + 1) Question 3 Construct a regular expression that defines the language L containing all words beginning with exactly double a or exactly double b. That is, L contains all words that start with only 2 aâ€™s or bâ€™s. Words in L are at least of length 2 and words such as aa, bb, bbababa and aabaabbabbbabb do belong to L; words such as a, b, babababa, bbbababa and aaaabbabbbabb do not belong to L. Answer Remember that the required regular expression should generate ALL the words belonging to L and NO words that do not belong to L. We have to provide a regular expression that can generate all and only the words belonging to L, i.e. all and only words beginning with exactly two aâ€™s or exactly two bâ€™s. How do we approach such a task? Find the smallest words that belong to L, then consider the longer words belonging to L. Consider all types of words belonging to L, for example, may words begin with and end with an a or a b, do repetitive similar groups of substrings appear, and also look for specific properties that words in L should have. Write down examples of all types of words that you identified and then construct a regular expression that can generate all these words. Words belonging to L begin with exactly two aâ€™s or exactly two bâ€™s and may end on an a or a b. The words aa and bb are in L. When a word begins with aa, a b should follow this aa-substring and when a word begins with bb, an a should follow this bb-substring to ensure that words start with a double aa- or bb- substring. Any possible substrings formed by concatenations of aâ€™s or bâ€™s together or separately, or ïŒ, may follow the first two letters in words belonging to L. COS2601/202/1/2018 5 Possible suitable regular expressions: aab(a + b)* + bba(a + b)* + aa + bb OR aa(bb*a*)* + bb(aa* b*)* OR aab(a*b*)* + bba(a*b*)* + aa + bb These are possible answers. You might have provided a different but correct regular expression. Question 4 Give a possible regular expression that generates the language L consisting of all words in which all words ï‚· either contain no aâ€™s at all, or ï‚· when there are aâ€™s, they occur in clumps of three or more aâ€™s, and ï‚· when there are aâ€™s, there are an even number of such clumps of aâ€™s. For instance, words such as b, bbbbbaaaabaaaaabbb and aaabbbaaaaaabaaabaaab are words in this language, and words such as aaaa and aaabaa are not words in the language. Answer Remember that the regular expression should generate ALL the words of the required language and NO words that are not in the required language. Also, the words may start and end with either a's or b's and your expression must make provision for this. In addition, where there are clumps of aâ€™s, they should come in pairs separated by at least one b (possibly more), and there should be at least three aâ€™s in each clump (possibly more). Furthermore, you have to decide whether the empty word, ïŒ, should be included in this language. As strings with no occurrence of a's should be allowed, and there is no requirement concerning the number of bâ€™s in a word in L, the empty word MUST be in the language. The first possible regular expression is b*(aaaa*bb*aaaa*bb*)*. This allows ïŒ to be generated and a word to start with some bâ€™s (if any) followed by pairs of three or more aâ€™s, separated by at least one b. However, this regular expression cannot generate words that end on a clump of three or more aâ€™s. So it is necessary to allow for the generation of another pair of three or more aâ€™s separated by at least one b at the end of the regular expression: b*(aaaa*bb*aaaa*bb*)*(aaaa*bb*aaaa*). The problem here is that words now cannot end on a b, and ïŒ cannot be generated. So we make one further correction: b*(aaaa*bb*aaaa*bb*)*(aaaa*bb*aaaa* + ïŒ). This now allows words to start and/or end with some bâ€™s or a clump of three or more aâ€™s, and the clumps of three or more aâ€™s are always in pairs. It can also generate ïŒ. This is of course not the only possibility. Question 5 Build an FA that accepts the language L of all words that contain the substring aa and have an odd number of letters. Remember that an FA has an a- and a b-edge for every state. Answer The question requires an FA to be built. The shortest words that should be accepted by the FA are aaa, baa, and aab. COS2601/202/1/2018 6 Once these have been accepted, the FA should accept any string that follows these letters. Note that we have maintained the odd length requirement when adding these extra edges. Now all that remains to do is to fill in the extra edges to ensure that we build an FA. Remember to ensure that any path leading to a final state contains an aa-substring, and has an odd number of steps. Question 6 Build an FA that accepts only those words that begin and end with the same double letter. Thus words to be accepted should either: ï‚· begin and end with the aa-substring OR ï‚· begin and end with the bb-substring. Note that the length of the shortest word(s) to be accepted is 4. Answer We should build an FA which accepts only words that begin and end with an aa-substring OR begin and end with a bb-substring. Letâ€™s say all these words belong to language M. The smallest words belonging to M have a length of 4: aaaa and bbbb. Possible arbitrary substings of aâ€™s or bâ€™s, or both, may appear after the first 2 letters and before the last 2 letters in the words belonging to M. Words can be of odd or even length. We look at some words that must be accepted by the FA: aaaa, bbbb, bbabb, aaabaa,â€¦, bbabababbbaabb,â€¦,aaabaaabbbbbabaabbbbaaabaa,â€¦ The words in language M can be represented by the following expression: aa(arbitrary string)aa + bb(arbitrary string)bb COS2601/202/1/2018 7 We will build the required FA in phases. Firstly we build an (incomplete) FA that accepts words beginning with and ending on a double a. Suppose x1 is the start state where we read an a then we move to state x2 (say). If we now read an a in state x2 then we move to state x3 (say). If we read an a in state x3 then we move to state x4 (say). The state x4 may not be a final state because we have only read 3 aâ€™s. If we read an a in state x4 then we move to the final state x5 where we can stay when we read any further number of aâ€™s, thus we draw a loop with label a on the final state x5. An incomplete FA: We should also consider the possibility that arbitrary stings of aâ€™s and/or bâ€™s may appear after the first 2 aâ€™s are read but before the last 2 aâ€™s are read. As we saw previously, after we had read an a in the start state x1 we moved to state x2. A string with b as the second letter may not be accepted by the FA, thus, if we read a b in state x2 then we move to a dead-end such as state x10 (say) where we stay. We therefore draw a loop with label a, b at state x10. If we read an a in state x2 then we move to state x3 where we can read any number of bâ€™s. We therefore draw a loop with label b at state x3. If we read an a in state x3 then we move to state x4. If we read an a in state x4 then we move to the final state x5, or if we read a b in state x4 we must move back to state x3. We cannot move to the final state x5 if we read a b in state x4 because strings containing a b as second last letter may not be accepted by the FA. As we saw previously, if we read an a in state x4 then we move to the final state x5 where we may stay. Words may not end on a b, thus, if we read a b in state x5 we must move back to state x3 to ensure that the last two letters in a string is a double a. An incomplete FA: We have built an incomplete FA that accepts words beginning with and ending on aa. The final FA also has to accept words beginning with and ending on bb. We include a type of mirror image of the above FA, but only words beginning with and ending on a double b will be accepted by this mirror part. A possible FA that accepts only words beginning and ending with an aa-substring OR beginning and ending with a bb-substring. COS2601/202/1/2018 8 Question 7 Build a TG that accepts the language of all strings that contain the baa substring and that end in the bb substring. Use as few states as possible. Answer A Transition Graph (TG) differs from an FA in various ways. These differences include the facts that TGs are not deterministic and may have strings from the alphabet as labels on their edges. The substring baa does not end on a bb, thus the smallest word that should be accepted by the TG is baabb. The question requires of us to use as few states as possible. A possible TG that accepts the language of all strings containing the baa substring and ending in the bb- substring, is provided below. Â© UNISA 2018","libVersion":"0.2.3","langs":""}