{"path":"Subjects/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Solution 2 - 2019.pdf","text":"BAR CODE Deﬁne Tomorrow. university of south africa Tutorial Letter 202/1/2019 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 Department of Computer Science School of Computing CONTENTS Model solutions for Assignment 02 COS3751/202/1/2019 ASSIGNMENT 2 Solution Total Marks: 82 Unique Assignment Number: 772587 Study material: Chapters 5, 6, 7, 8. You may skip sections 5.5, 5.6, and 5.7. Question 1: 10 Marks (1.1) (2)Clearly explain what a utility function is, and why it is used during adversarial searches. A utility function provides an indication of the apparent numerical value of a state s for player p. It is used to ﬁnd the best available move for a player. (1.2) (3)Is the ideal strategy only available if we have perfect information? Explain your answer. No. Agents can still get the ideal strategy when playing without all the information . This means the ideal strategy includes the notion of limited information, however, an agent that has perfect information will most likely outperform and agent that has limited/imperfect information for the same problem. (1.3) (3)Explain how forward pruning works. Provide at least one approach to forward pruning in your explanation, as well as a problem that may be encountered with forward pruning. Forward pruning means that some nodes are pruned without even considering them. Beam search [others are also considered] only considers a sample of the best moves at each ply, but this may lead to the best move being pruned away. (1.4) (2)Does the order in which nodes are examined in minimax matter? Explain your answer. Only if we prune. Otherwise minimax is an exhaustive search (for the parameters such as depth – plys – it is conﬁgured for) and node orders do not matter. Question 2: 14 Marks Consider Figure 1 and answer the questions that follow. (The utility value of the leaf nodes are provided below the in brackets in the leaf node.) (2.1) (5)Provide the minimax values for all the non-leaf nodes. A = 5, B = 5, C = 3, G = 3, E = 8 (2.2) (2)Which move should MAX make? Explain your answer. B. The utility value for MAX for move B is higher than that of move C. (2.3) (5)Write down the α/β values for all the nodes (except the leaf nodes) if alpha/beta pruning is applied to the tree. 2 COS3751/202/1/2019 A B D 5 E I 8 J -1 F 10 C G K -5 L 3 H 20 Figure 1: Minimax, alpha/beta Provided below is < node >= (α, β): 3 A B D 5 E I 8 J -1 F 10 C G K -5 L 3 H 20 v ≥ β: J cut v ≤ α: H cut v = \b\b−∞ 5 α = \b\b−∞ 5 β = ∞ v =ˆ∞ 5 α = −∞ β =ˆ∞ 5 v =ˆ∞ 3 α = 5 β = ∞ v = \b\b−∞ 8 α = −∞ β = 5 v = \b\b−∞ ˆˆ−5 3 α = 5 β = ∞ (1) (2) (3) 5 (4) (5) (6) 8 (7) 8 (8) (9) 10 (10) 5 (11) (12) (13) (14) -5 (15) (16) 3 (17) 3 (18) 3 The ﬁnal values are: A = (5, ∞), B = (−∞, 5), E = (−∞, 5), C = (5, ∞), G = (5, ∞) (2.4) (2)Write down which nodes were cut and what type of cut was made in each case (alpha, or beta). J was beta-cut, and H was alpha-cut. Question 3: 12 Marks Consider the subtraction game: two players (A and B) take turns removing items from a heap (just one heap). Each player may remove either one, two, or three items from the heap. The heap starts oﬀ with 21 items, and player A moves ﬁrst. The objective of the game is to be the last player to remove items from the heap. That is, if it is your turn to move, and the heap is empty, you’ve lost the game1. The Initial state for the game is (A, 21) indicating that it is A’s turn to move and there are 21 items on the heap. In general then, a state is represented as (P, n) where P ∈ {A, B}, and 0 ≤ n ≤ 21. The evaluation function for non-terminal nodes is a simple threshold function deﬁned as: eval(S) = { −1 if S.n mod (k + 1) = 0, 1 otherwise 1visit https://youtu.be/aonCsvi0LKc to see how the game is played. 4 COS3751/202/1/2019 S.n refers to the number of items left in the heap in state S, and mod is the integer modulo function. (3.1) (7)Draw the entire game tree, starting from the initial state, down to depth two (the initial state is at depth 0), and provide the evaluation for each state at depth 2. (A,21) (B,20) (A,19) (A,18) (A,17) (B,19) (A,18) (A,17) (A,16) (B,18) (A,17) (A,16) (A,15) (3.2) (4)Using the minimax algorithm, provide the backed-up values for states at depth 1 and 0. (Hint: Since you don’t have the entire game tree, and thus no terminal states, you cannot use a utility value to calculate the backed up values. However, you do have an evaluation function.) There are ﬁve diﬀerent states on depth two (which is a max level): (A, 19), (A, 18), (A, 17), (A, 16), and (A, 15). eval((A, 19)) = 1, since (19 mod (3 + 1) = 19 mod 4 = 3, eval((A, 18)) = 1, eval((A, 17)) = 1, eval((A, 16)) = −1, eval((A, 15)) = 1. At depth one (a MIN level), (B, 20) ≡ M IN (eval((A, 19)), eval((A, 18)), eval((A, 17)) ≡ M IN (1, 1, 1) ≡ 1. (B, 19) ≡ M IN (eval((A, 18)), eval((A, 17)), eval((A, 16)) ≡ M IN (1, 1, −1) ≡ −1. (B, 18) ≡ M IN (eval((A, 17)), eval((A, 16)), eval((A, 15)) ≡ M IN (1, −1, 1) ≡ −1. Finally, at depth zero, (A, 21) ≡ M AX(1, −1, −1) ≡ 1. (3.3) (1)Which node(s) would not have been evaluated at depth 2 if alpha/beta pruning was employed? Below (B,18): (A,15) (cut because α = 1, and v = −1 from (A,16). Thus (A,15) is cut. Question 4: 6 Marks Answer the following questions on Constraint Satisfaction Problems (CSPs). (4.1) (1)Deﬁne the Least Constraining Value (LCV) heuristic. The heuristic prefers values that rule out the fewest choices for neighbours (it tries not to limit the number of choices that remain for neighbours). 5 (4.2) (1)Explain why establishing strong k-consistency is a problem. This means we must show that the graph is k-consistent, k − 1-consistent and so on. This can only be done in exponential time which makes large problems intractable. (4.3) (1)Deﬁne the degree heuristic. This heuristic attempts to reduce the branching factor on future choices. (4.4) (2)If no legal assignments for a variable remain during a solution to a CSP, does it mean that the algorithm will be able to ﬁnd a solution by simply backtracking? Explain your answer. No. It may very well be that there is no answer (there is no form of consistency for the problem given the constraints, resulting in no solution). (4.5) (1)Explain what forward checking for a CSP is. It is a domain reduction technique which establishes arc consistency. (Or: it re- moves values from the domain of the neighbours of the variable for which the forward checking is being done – also acceptable answer.) Question 5: 19 Marks CSPs are especially useful when trying to solve scheduling problems. Consider the problem of determining how to assign aircraft in a ﬂeet to particular ﬂights. A ﬂight (or a leg) is simply a scheduled transference of passengers from a departing airport to a destination airport (with no stops inbetween). In order to transfer passengers between the source and destination airport a ﬂight needs an aircraft. Additionally, aircraft have a minimum turn-around time of 30 minutes. That is, an aircraft cannot arrive, and then simply take of again. It has to taxi to the gate, passengers should debark, the aircraft should be cleaned, and the new passengers should embark. Only then can the aircraft taxi to the assigned runway and then take-oﬀ. The airline in question operates a small ﬂeet of short-haul aircraft, and all ﬂights are only for 9 or fewer passengers. Consider the following ﬂight schedule: Flight Departs Lands QQ144 9:15 10:45 QQ144 14:00 14:45 QQ169 12:15 13:15 QQ108 10:45 11:45 QQ256 09:30 10:15 QQ254 11:15 13:30 QQ099 11:15 13:30 QQ512 13:15 14:15 QQ056 11:15 11:45 QQ134 10:00 10:45 QQ134 14:00 14:45 6 COS3751/202/1/2019 You can assume that departure happens from the same airport (you don’t have to worry about the location of the aircraft). The airline owns several Cessna 208 Grand Caravans (208B), which are: 1. XAX-143, 2. XAX-884, 3. XAX-547, 4. XAX-344, 5. XAX-254, 6. XAX-983, 7. XAX-124 (5.1) (1)The ﬁrst step when representing a problem as a CSP is to deﬁne the variables. The variables are those elements in the problem that get assigned something else from the problem. Read the above problem description carefully to determine which elements from the problem are variables. Now provide these variables for the problem. Remember to use the correct notation! Hint: In most cases the variables are those elements from the problem which will require the use of a limited item available. The variables are simply the ﬂights: X = {QQ144, QQ169, QQ108, QQ256, QQ254, QQ099, QQ512, QQ056, QQ134}. (5.2) (1)Once the variables have been deﬁned, we proceed to deﬁning the domain for each variable. That is, the ‘value’ that each variable can take. Deﬁne the domain for each variable in the CSP. The domain for each variable will be the ﬂight that it can take on. DX = { XAX- 143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124 } (5.3) (7)The constraints determine the ‘restrictions’ placed on variables. Deﬁne the constraints for the variables in the CSP. 1. QQ144 ̸= QQ108 ̸= QQ256 ̸= QQ512 ̸= QQ134 2. QQ169 ̸= QQ254 ̸= QQ099 ̸= QQ512 3. QQ108 ̸= QQ254 ̸= QQ099 ̸= QQ056 ̸= QQ134 4. QQ256 ̸= QQ134 5. QQ254 ̸= QQ099 ̸= QQ512 ̸= QQ056 6. QQ099 ̸= QQ512 ̸= QQ056 7. QQ512 ̸= QQ134 7 (5.4) (2)Provide the constraint graph for this problem. Graph must have: correct nodes , correct constraints QQ144 QQ169 QQ108 QQ256 QQ254 QQ099 QQ512 QQ056 QQ134 (5.5) (8)Provide the solution to the problem. Use the Minimum Remaining Values (MRV) heuris- tic, and at each step establish arc-consistency for the variables. Show how the solution is calculated in a step by step fashion. Provide the variables and their associated values as your ﬁnal answer! Using MRV we easily choose any of the variables, and we can easily assign any aircraft to them. Choose QQ144 = XAX-143. • DQQ099,QQ056,QQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983,XAX-124} • DQQ108,QQ512,QQ256,QQ134 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} Using MRV we now select any of the variables that had their domain reduced from the previous step. Choose QQ256 = XAX-884. • DQQ099,QQ056,QQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983,XAX-124} • DQQ108,QQ512 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ134 = {XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ134 since it now has the MRV. Choose QQ134 = XAX-547. • DQQ099,QQ056,QQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ108,QQ512 = {XAX-884, XAX-344, XAX-254, XAX-983, XAX-124} 8 COS3751/202/1/2019 QQ108 and QQ512 have the MRV, so we arbitrarily choose: QQ108 = XAX-884 We choose QQ099 since it now has the least remaining values. Choose Q099 = XAX-344. • DQQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX- 124} • DQQ254,QQ099,QQ056 = {XAX-143, XAX-547, XAX-344, XAX-254, XAX-983, XAX- 124} • DQQ512 = {XAX-884, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ512 since it now has the MRV. Choose QQ512 = XAX-884. • DQQ169,QQ254,QQ099,QQ056 = {XAX-143, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ169 arbitrarily. Choose QQ169 = XAX-143. • DQQ056 = {XAX-143, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ254,QQ099 = {XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ254. Choose QQ254 = XAX-547. • DQQ056 = {XAX-143, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ099 = {XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ099 since it now has the least remaining values. Choose QQ099 = XAX-344. • DQQ056 = {XAX-143, XAX-254, XAX-983, XAX-124} QQ056 is our last remaining variable. Choose Q056 = XAX-143. The problem is thus solved. QQ144 QQ169 QQ108 QQ256 QQ254 QQ099 QQ512 QQ056 QQ134 9 Flight Plane QQ144 XAX-143 QQ169 XAX-143 QQ108 XAX-884 QQ256 XAX-884 QQ254 XAX-547 QQ099 XAX-344 QQ512 XAX-884 QQ056 XAX-143 QQ134 XAX-547 Question 6: 17 Marks Prove that A ⇔ (B ∧ C) |= (A ⇒ B) ∧ (A ⇒ C) using resolution. Hint: First convert the premise and the negation of the goal to Conjunctive Normal Form (CNF), and then apply the resolution rule to try to attain the empty clause. We ﬁrst convert the premise to CNF. • Eliminate iﬀ: (A ⇒ (B ∧ C)) ∧ ((B ∧ C) ⇒ A) • Eliminate implication: (¬A ∨ (B ∧ C)) ∧ (¬(B ∧ C) ∨ A) • Move ¬ inwards: (¬A ∨ (B ∧ C)) ∧ (¬B ∨ ¬C ∨ A) • Distribute over ∧: (¬A ∨ B) ∧ (¬A ∨ C) ∧ (¬B ∨ ¬C ∨ A) Next we convert the negation of the goal to CNF: • Eliminate implication: ¬((¬A ∨ B) ∧ (¬A ∨ C)) • Move ¬ inwards: (A ∧ ¬B) ∨ (A ∧ ¬C) • Undistribute over ∧: A ∧ (¬B ∨ ¬C) The CNF of the premise consists of three clauses, and the negation of the goal consists of two clauses. We write each clause separately, as follows: 1. ¬A ∨ B premise 2. ¬A ∨ C premise 3. ¬B ∨ ¬C ∨ A premise 4. A negation of goal 5. ¬B ∨ ¬C negation of goal Now we apply the resolution rule to pairs of clauses that contain complementary literals, as many times as needed to get the empty clause: 6. B 1&4 7. C 2&4 8. ¬C 5&6 9. ∅ 7&8 10 COS3751/202/1/2019 Note that you may not apply the resolution rule to a pair of clauses that contain two (or more) complementary literals. For example, you may not combine clauses 1 & 3. Since we have attained the empty clause, clauses 1 to 5 were unsatisﬁable. From this we conclude that the goal is entailed by the premise, i.e. s A ⇔ (B ∨ C) |= (A ⇒ B) ∧ (A ⇒ C). Question 7: 4 Marks Do exercise 8.9 a, c, e, f in the textbook. The translation is straight forward using the vocabulary provided. a Occupation(Emily, Surgeon) ∨ Occupation(Emily, Lawyer) c ∀p(Occupation(p, Surgeon) ⇒ Occupation(p, Doctor)) e ∃p(Boss(p, Emily) ∧ Occupation(p, Lawyer)) f ∃p(Occupation(p, Lawyer) ∧ ∀q(Customer(q, p) ⇒ Occupation(q, Doctor))) Copyright c⃝UNISA 2019 (v2019.1.3) 11","libVersion":"0.2.3","langs":""}