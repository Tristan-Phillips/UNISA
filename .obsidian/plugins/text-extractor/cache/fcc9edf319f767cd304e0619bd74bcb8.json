{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Notes/downstudocu.com_parsing-xmltutorial-ch-15-01.pdf","text":"Parsing XML with Qt DOM and SAX Tutorial Contents 1 Short introduction to XML 2 Creating a simple XML file with Qt DOM 3 Loading a simple XML file using Qt DOM 4 Loading XML documents using Qt and the SAX parser 1 Short introduction to XML XML is a general structured format to store and exchange hierarchical data. If you know HTML, you'll find XML quite similar (in fact, after some small modifications, a HTML file is a valid XML file): XML uses nested tags of the form <tagname>...</tagname> for tags with contents and <tagname/> for tags without content. Each tag can contain other tags, and the tag itself can have attributes of the form <tagname attribute=value>...</tagname>. The name of the tags is not restricted (unlike HTML, which only defines a given set of proper HTML tags), so you can choose whatever name fits your needs. As an example, let us assume that you want to store holiday information into a file and use Qt to load or modify it. To get a feeling for how XML looks like, here is one possible format for such a holiday file: <?xml ?>version encoding='1.0' ='UTF-8' <holidayset >country=\"at\" <name> </name>Holidays for Austria <holiday> <name> </name>New Year's Day <date> </date>2007-01-01 </holiday> <holiday> <name> </name>Christmas <date> </date>2007-12-24 </holiday> </holidayset> This file defines a holiday set for Austria (notice the country=\"at\" attribute to the holidayset tag). The holiday set, enclosed in <holidayset>...</holidayset> contains two holidays, each enclosed with <holiday>...</holiday>. Each of these holiday elements contains the settings for that holiday enclosed in appropriately named tag. Such an XML file can be represented as a tree structure, with the XML document being the root of the tree, and each subelement/attribute/text value is a child of it's enclosing XML element. The tree structure corresponding to the holiday file above looks like the following: As you can see, there are different types of nodes: • elements: they are of the form <tagname>...</tagname> • attributes: they are attributes inside element tags: <tagname attribute=value> • text nodes: the text content of element tags, the text between <tagname> and </tagname> • processing instructions: they tell the xml parser / transformer / viewer how to interpret something, their form is <? instruction attribute=value ?> • comments: <!-- comment --> • document type: specifies the type of the document (e.g. html 4 transitional), its form is <!DOCTYPE name > Notice that we did use the same tag <name> inside the <holidayset> and inside the <holiday> tags. We used quite generic names for the tags, which might become a problem with complexer structure, when we want to use the same name for different purposes. For this reason, XML also defines namespaces to allow for the same name (but from a different namespace, so they are actually different names) used in different context. In a later section we will look at these .namespaces Also note that we implicitly used specially formatted (ISO-formatted) contents for the date tags, without yet specifying it. Of course we could give any other value, say <date>I hope never</date>, and it would still be a valid XML file, but the parser will not be able to interpret the value as a date. Add such constraints and specific formats / values / value ranges for elements is possible using either a or an . If you have such a definition, a validatingDTD XML Schema parser can check whether a given XML file really adheres to the document structure defined in that schema. Unfortunately, the Qt XML/DOM classes are not validating parsers, so you cannot validate XML documents against a given schema with Qt. We will use the example from above throughout this tutorial. In our application, we want to store the holiday set in the following class: class Holiday { public: Holiday() {} ~Holiday() {} QDate mDate; QString mName; }; class HolidaySet { public: HolidaySet mCountry( ) : const QString &c ( ) {}c ~HolidaySet() {} QString mCountry, ; mName QList< ;Holiday> mHolidays }; 2 Creating a simple XML file with Qt DOM Let us first look at how to use the Qt classes to generate the XML for the holiday file from the HolidaySet class that you have in memory. For this purpose, Qt offers the classes Q Do m D o c u m e n t QD o m N o d e to represent the whole document and and Q Do m E l e m e n t to represent each individual tag and attribute. The XML document is described by an object of the class Q D o m D o c u m e n t with methods to create new elements. The general flow of building up a DOM tree is as follows: 1. Create the DOM document 2. For each element of the dom tree: 1. Create the element using the methods from QDomDocument. The element does not yet have any position within the DOM tree. 2. Insert the element into its parent node. 3. If the element should have contents, set the contents, set the attributes, etc. Let us look at some sample code to generate the DOM tree from the HolidaySet class: 1. /* Helper function to generate a DOM Element for the given DOM document 2. and append it to the children of the given node. */ 3. QDomElement addElement( QDomDocument &doc, QDomNode & ,node 4. const QString & ,tag 5. value const QString & = )QString::null 6. { 7. el tag QDomElement = doc.createElement( ); 8. node. el appendChild( ); 9. if ( !value.isNull() ) { 10. txt value QDomText = doc.createTextNode( ); 11. el. txt appendChild( ); 12. } 13. return el; 14. } 15. 16. HolidaySet hs QString holidaySetToXML( const & ) 17. { 18. QDomDocument doc; 19. instr QDomProcessingInstruction = doc.createProcessingInstruction( 20. \"xml\", \"version='1.0' encoding='UTF-8'\"); 21. doc.appendChild(instr); 22. 23. // generate holidayset tag as root, add country attribute if needed 24. holidaySetElement QDomElement = addElement( doc, doc, \"holidayset\" ); 25. if ( !hs.mCountry.isEmpty() ) 26. holidaySetElement.setAttribute( , \"country\" hs.mCountry ); 27. 28. // Add the <name> and <comment> elements to the holidayset 29. if ( !hs. .mName isEmpty() ) 30. addElement( doc, holidaySetElement, , \"name\" hs.mName ); 31. 32. // Add each holiday as a <holiday>..</holiday> element 33. QList<Holiday>::iterator i; 34. i i for ( = hs. .mHolidays begin(); != hs.mHolidays.end(); ++i) { 35. h QDomElement = addElement( doc, holidaySetElement, );\"holiday\" 36. addElement( doc, h, , (*\"name\" i .) mName ); 37. addElement( doc, h, , (*\"date\" i . .) mDate toString( ) );Qt::ISODate 38. } 39. 40. return doc.toString(); 41. } Let us now slowly step through the code: • The whole step 2) is done with the addElement helper function (lines 3-14) using the defined DOM methods. The addElement function needs the DOM document to create the new element, it needs the parent node to insert the new element, and it needs the tag name and possible value for the new element. Let's assume the function was called as addE lement ( doc, node, \"t a g\", \" cont ent s\" ) Line 7 creates the new element by calling the QDomElement::createElement method. This creates the <tag> tag, without any contents or attributes. The new tag is also not yet positioned anywhere in the DOM tree. • Line 8 inserts the newly created tag as the child of an already existing node, by calling the QDomNode::appendChild with the new tag as argument. • Lines 9-12: In the DOM representation, the contents of a tag (i.e. the text between <tag> and </tag> in the XML) is represented as a DOM object of type text and is a child of the enclosing tag. • Line 13: As we will need the new node to set attributes or insert children, we return it. • The holidaySetToXML method (lines 17-40) does the actual conversion of the holiday set to a DOM tree. • First it creates an empty DOM document (line 19) • The processing instruction <?xml ...?> is created in line 20 and inserted as the first child of the document in line 21. • The root element (<holidayset>...</holidayset>) is then created using the addElement helper function (line 24). Here the DOM document and the parent are the same (doc). The holidaySetElement is still empty, i.e. we now have an XML representation <hol i dayset /> • which is the same as <holidayset></holidayset> • To set an attribute (country=\"at\") for the DOM node, QDomElement::setAttribute( key, value ) (line 26) is called. the document now has the XML representation <hol idayset count ry=\"at \" / > • To populate the holidayset with the <holiday>...</holiday> entries, a new element is created (line 36) for each of the holidays in a loop. The parent of all these elements is the holiday set element. After line 36 we have an XML document You can now create the XML file contents simply via // Create the data structure HolidaySet hs(\"at\"); hs.mName= ;\"Holidays for Austria\" Holiday h; h.mDate = QDate( 2007, 01, );01 h.mName = QString( );\"New Year\" hs. .mHolidays append( );h h.mDate = QDate( 2006 12, , ); 24 h.mName = QString( );\"Christmas\" hs. .mHolidays append( );h // convert to the XML string QString output hs = holidaySetToXML( ); // output that XML string qDebug()<< ;output 3 Loading a simple XML file using Qt DOM Let us now look at loading an XML file into memory and parsing it into our HolidaySet memory structure. There are two different strategies for loading XML documents: • A (Simple API for XML) walks through the XML file sequentially, calling SAX parser methods like startTag and endTag whenever an opening or closing tag is encountered. There is no hierarchy involved yet (which you can still introduce when building your memory structures in the startTag/endTag methods), but the advantage is that there is no need to keep the whole XML document in memory. • DOM (Document Object Model) on the other hand, loads the whole document into memory, splitting it into different nodes and building a hierarchical tree. The advantage is that you do not need to build the hierarchy yourself, while on the other hand the whole document needs to be in memory. For huge documents this can be a real problem, but for the rather small holiday files, we will use DOM. From the description above it is clear that SAX can only be used to load an XML file, while DOM can also be used to build up or modify existing XML files. In fact, we already did exactly that in the previous section where we created the holiday file. In this section we will now look at how we can parse the XML holiday set into the HolidaySet structure using the DOM method. The parsing using a SAX parser will be treated in the next section The usual way to parse an XML document into a DOM tree is to use the method QDomDocument::setContent. If this method is successful, the QDomDocument object contains the DOM tree in the usual DOM structure. If an error occurs, the error message and the exact position of the error is stored into the parameters of the call: 1. QFile f( argv[1] ); 2. QDomDocument doc; 3. QString errorMsg; 4. int errorLine, errorColumn; 5. errorColumn if ( doc.setContent( &f, &errorMsg, &errorLine, & ) ) { 6. result doc = parseXMLwithDOM( ); 7. } The resulting QDomDocument now contains the whole DOM tree, similar to the one that we created in the previous section. The DOM tree represents the hierarchical structure as shown in the image above. To obtain an element with a given tag name, one can use the QDomNode::namedItem( \"tagname\" ) method of the parent node object, which returns a QDomNode (this class is the base type to describe any of the DOM nodes). As we are interested in the element, we have to convert it to a DOM element by the toElement() method. To extract the holiday data from the DOM tree, we write the function parseXMLwithDOM: HolidaySet parseXMLwithDOM domTree ( QDomDocument & ) { HolidaySet hs( );QString::null We first obtain the DOM element that represents the <holidayset>...</holidayset> element using the namedItem and toElement methods. If no child node named \"holidayset\" exists or it is not an element (e.g. because it is a processing instruction or an attribute), a null element is returned: QDomElement set = domTree. .namedItem( )\"holidayset\" toElement(); if ( () ) {set.isNull qWarning() << \"No <holidayset> element found at the top-level \" << ;\"of the XML file!\" return hs; // no holiday set found } This element possibly has an attribute named \"country\". This can be checked using the QDomNode::hasAttribute method and the attribute can be obtained using the QDomNode::attribute method: if ( ) ) {set.hasAttribute(\"country\" hs. set.mCountry = attribute( );\"country\" } We can also have a <name>...</name> child element, which can be obtained similar to the holidayset element. We retrieve the text of the element between the enclosing tags by a call to QDomElement::text(): // Search for a given element (only the first matching is returned): QDomElement name = set. .namedItem( )\"name\" toElement(); if ( ! () ) { name.isNull // We have a <name>..</name> element in the set hs. name.mName = text(); } The namedItem method will always return the first child that matches the given name. While this might be fine for the <name> child element, we cannot use this for the <holiday>...</holiday> elements, which will appear more than once. For this reason, there are iterator-like calls firstChild() and and nextSibling() to walk through all child nodes and firstChildElement(\"tagname\") and nextSiblingElement(\"tagname\") to walk only through all child elements with the given tag name. If no further child can be found, a null node is returned: // Way 1: Loop through all child nodes with a given tag name. QDomElement e = set.firstChildElement( );\"holiday\" for ( ; ! (); = ( ) ) {e.isNull e e.nextSiblingElement \"holiday\" Holiday h; // e is the <holiday>...</holiday> element.... // Load the contents of e into h hs. .mHolidays append( );h } // Way 2: Loop through all child nodes and check if it is an element // with one of the wanted tagnames QDomNode nd = set.firstChild(); for ( ; ! (); = () ) {nd.isNull nd nd.nextSibling if ( () && () == ) nd.isElement nd. .toElement() tagName \"holiday\" { QDomElement e = nd.toElement(); Holiday h; // Same code as above... // e is the <holiday>...</holiday> element.... // Load the contents of e into h hs. .mHolidays append( );h } } The first method is of course the better and simpler choice. However, if the <holidayset> element can have various different child elements, it's often easier and faster to loop through all children only once and condition the code on the name of the tag, which is done in the second example. Now that we have the QDomElement of the <holiday>...</holiday> element, we can easily load its contents into the Holiday structure, using only methods that we have already seen: Holiday h; QDomElement v = e. .namedItem( )\"name\" toElement(); if ( ! () ) = ();v.isNull h.mName v.text v = e. .namedItem( )\"date\" toElement(); if ( ! () ) {v.isNull h. v.mDate = QDate::fromString( text(), Qt::ISODate ); } hs. .mHolidays append( );h This concludes our method for loading the holiday set data from the DOM tree representation into the HolidaySet data structure. The whole parseXMLwithDOM function thus reads: 1. HolidaySet parseXMLwithDOM domTree ( QDomDocument & ) 2. { 3. HolidaySet hs( );QString::null 4. 5. set QDomElement = domTree. .namedItem( )\"holidayset\" toElement(); 6. if ( set.isNull() ) { 7. qWarning() << \"No <holidayset> element found at the top-level \" 8. << ;\"of the XML file!\" 9. return hs; // no holiday set found 10. } 11. 12. if ( set.hasAttribute(\"country\") ) { 13. hs.mCountry = set.attribute( );\"country\" 14. } 15. 16. // Way 1: Explicitly search for a given element: 17. name QDomElement = set. .namedItem( )\"name\" toElement(); 18. if ( !name.isNull() ) { // We have a <name>..</name> element in the set 19. hs.mName = name.text(); 20. } 21. 22. // Way 2: Loop through all child nodes with a given tag name. 23. n QDomElement = set.firstChildElement( );\"holiday\" 24. n for ( ; !n.isNull(); = n.nextSiblingElement( ) ) {\"holiday\" 25. Holiday h; 26. e QDomElement = n.toElement(); 27. v QDomElement = e. .namedItem( )\"name\" toElement(); 28. if ( !v.isNull() ) h.mName = v.text(); 29. v = e. .namedItem( )\"date\" toElement(); 30. if ( !v.isNull() ) { 31. h.mDate = ( QDate::fromString v.text(), );Qt::ISODate 32. } 33. hs. h mHolidays append. ( ); 34. } 35. 36. // Way 3: Loop through all child nodes and check if it is an element 37. // with one of the wanted tagnames 38. nd QDomNode = set.firstChild(); 39. nd for ( ; !nd.isNull(); = nd.nextSibling() ) { 40. if ( nd.isElement() && nd. .toElement() tagName() == ) {\"holiday\" 41. n QDomElement = nd.toElement(); 42. // Same code as above... 43. } 44. } 45. 46. return hs; 47. } 4 Loading XML documents using Qt and the SAX p arser While the DOM classes we have used so far are a very convenient method to work with XML documents, they also have their drawbacks. In particular, when we simply want to load an XML document into our own data structure, going the DOM way will build up and keep the whole tree structure of the data in memory! And that tree will use even more resources than the pure-text representation of the XML, which can be crucial for large XML documents. After reading the XML into the DOM tree, all we do is copy the corresponding values from the tree into our own data structure and discard the whole DOM tree again. Surely, that's quite a waste of resources and there has to be a more efficient way to simply load the XML. One possible solution comes in the form of SAX (simple API for XML), which reads through the XML sequentially and calls methods of a QXmlDefaultHandler-derived class. For example, when an opening tag is encountered, the method QXmlDefaultHandler::startElement( nsURI, localName, qName, attributes ) is called. Similarly, QXmlDefaultHandler::startElement is called for a closing element, and QXmlDefaultHandler::characters( string ) is called for the text contents of an element. Note that you have to keep track of all context information (e.g. enclosing tags/elements etc.) yourself. SAX simply lets you know that it encountered a particular element, not where exactly it happened or what comes before or afterwards in the XML. Using this SAX classes, we have to implement our own QXmlDefaultHandler-derived class, named HolidayHandler in our case, and reimplement its methods where needed. The SAX parsing happens using the QXmlSimpleReader class, where we first have to register our QXmlDefaultHandler-derived class as the SAX handler. The QXmlSimleReader::parse method finally triggers the XML parsing. class public HolidayHandler : QXmlDefaultHandler { public: HolidayHandler holiday holidayset() : QXmlDefaultHandler(), (0), ( ::QString null) {} bool const const startElement( QString &/*namespaceURI*/, QString & ,localName const const QString &/*qName*/, QXmlAttributes & )atts { if ( == ) {localName \"holidayset\" QString country = atts.value( );\"value\" if ( ! () ) = ;country.isEmpty holidayset.mCountry country } ( == ) {else if localName \"holiday\" if new ( ! ) = holiday holiday Holiday; } content.clear(); return true; } virtual bool const const endElement ( QString &/*namespaceURI*/, QString & localName, )const QString &/*qName*/ { if ( == ) {localName \"name\" if ( ) = ;holiday holiday->mName content else holidayset. contentmName = ; } ( == ) {else if localName \"date\" QDate d = QDate Qt::fromString( content, ::ISODate ); if ( () && ) = ;d.isValid holiday holiday->mDate d } ( == ) {else if localName \"holiday\" holidayset. .mHolidays append( * );holiday holiday = ;0 } content.clear(); return true; } bool const characters( QString & )str { content += str; return true; } bool const fatalError( QXmlParseException & )exception { qDebug() << << \"Parse error at line \" exception.lineNumber() << << () << \", column \" exception.columnNumber \": \"\\n << ();exception.message return false; } HolidaySet holidaySet() { return holidayset; } protected: Holiday *holiday; HolidaySet holidayset; QString content; }; int int char main( argc, * [])argv { if ( < ) {argc 2 qWarning() << << \"Please give the XML file as argument!\"<<endl \"Usage: qtdom_parse_dom filename.xml\"<< ;endl return EXIT_FAILURE; } HolidaySet result( );QString::null HolidayHandler handler; QXmlSimpleReader reader; reader. handlersetContentHandler(& ); reader. handlersetErrorHandler(& ); QFile file argv( [ ]);1 if (! ( :: ::file.open QFile ReadOnly | QFile Text)) { QMessageBox:: (warning 0, ,\"QtDOM SAX example\" QString( )\"Cannot read file %1:\\n%2.\" .arg(argv[1]) .arg(file.errorString())); return EXIT_FAILURE; } QXmlInputSource xmlInputSource file(& ); if ( ) ) {reader. xmlInputSourceparse( result = handler.holidaySet(); } {else return EXIT_FAILURE; }","libVersion":"0.2.3","langs":""}