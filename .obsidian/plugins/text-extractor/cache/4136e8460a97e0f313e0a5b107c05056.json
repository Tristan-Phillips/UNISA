{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Studocs/downstudocu.com_cos3711-june-2020-question-paper.pdf","text":"[TURN OVER] EXAMINATION PANEL: FIRST: MR CL PILKINGTON SECOND: MR K HALLAND EXTERNAL: DR L MARSHALL (UNIVERSITY OF PRETORIA) Instructions 1. Answer all questions. 2. The mark for each question is given in brackets next to each question. 3. Note that no pre-processor directives are required unless specifically asked for. This examination paper consists of 5 pages. Good luck! 2 COS3711 May/June 2020 [TURN OVER] Thousands of people take flights each day. For each fight, the origin, destination, and flight number are stored. Additionally, for each passenger, the passenger name and ID number are stored. Question 1 [30 marks] The UML class diagram below has been proposed as a design for the Flight class. 1.1 Which anti-pattern can be identified in the design of the Flight class? (1) 1.2 Using a UML class diagram, redesign the solution, adding any classes that you deem necessary. You should take the functions and data members that are already present in the UML class diagram into account when designing your updated solution, and add functions where necessary to make new class interactions clear. Note that you are not required to include passengers at this point yet. (8) 1.3 A valid flight number is of one of the following forms: exactly three uppercase alphabetic characters followed by 3 digits (CAW463, for example) or exactly two uppercase alphabetic characters followed by 4 digits (BA6423, for example). Provide a regular expression that would check whether a given flight number is valid. (7) 1.4 One way of storing the list of passengers on a flight is to use Qt’s parent-child facility. Thus, a Passenger instance is a child of a Flight instance, where a Passenger class is used to model passenger objects. 1.4.1 Write the class header for the Flight class so that it may be used as the parent for Passenger items. Include only the necessary code to implement the parent-child functionality; you do not need to include the functions and data members from your answer in 1.2. (1) 1.4.2 Write the class header for a Passenger class so that it may be used as a child instance of a Flight instance. It should have a passenger name and ID number as data members, both of which are initialised via a parameterised constructor. (3) 1.4.3 Explain two ways you could use to add the Passenger p object as a child of a Flight object named f. Provide example Qt code to show how these would be achieved. (5) 1.5 As an alternative to the parent-child approach in 1.4, the list of Passengers could be stored in one of the following: QStandardItemModel, QAbstractTableModel, or QTableWidget. 1.5.1 Explain the differences between these three approaches. (3) 1.5.2 Which of these three would you recommend, stating why you say so? (2) 3 COS3711 May/June 2020 [TURN OVER] Question 2 [29 marks] The Passenger child objects of a Flight instance need to be written to an XML file using QXmlStreamWriter; use the steps set out in this question to guide you. The XML file should have the following format. <passengerList> <passenger> <name>one</name> <identityNumber>1</identityNumber> </passenger> <passenger> <name>two</name> <identityNumber>2</identityNumber> </passenger> </passengerList> 2.1 Write the code necessary to access the child objects of the Flight object named f (in 1.4.3). Store this list in a variable named list that has the appropriate type. It is this list that will be passed to the function that will write the XML file. (2) 2.2 You need to use meta-objects to gain read access to the properties of each Passenger instance. Rewrite the class header (from 1.4.2) to make this possible. (4) Passenger 2.3 Using the following code fragment as a guide, indicate how you would access the Passenger child objects of a Flight instance stored in list. You should use the meta- object to iterate through the child object’s properties so that they may be written to an XML file. You need only write the code for the write() implementation. class XMLWriter { public: XMLWriter(QString fn); void write(/* appropriate type */ list); private: QXmlStreamWriter writer; QString filename; }; XMLWriter::XMLWriter(QString fn): filename(fn) { } // This is the code that you need to implement fully. // Use the comments to guide your implementation. void XMLWriter::write(/* appropriate type */ list) { QFile file(filename); if (!file.open(QIODevice::WriteOnly)) { return; } writer.setDevice(&file); writer.setAutoFormatting(true); 4 COS3711 May/June 2020 [TURN OVER] writer.writeStartDocument(); // create the root element for (int i=0; i< /* insert limit here */; i++) { // create appropriate XML opening and closing tags // get the Passenger object and its meta-object, then // loop through all the properties and create the // necessary XML tags (as per the example) } // close root tag writer.writeEndDocument(); file.close(); } (15) 2.4 What two important benefits are there to using the meta-object to write an object’s properties rather than the object’s getters? (2) 2.5 This writing to an XML file partly follows the Serializer design pattern. 2.5.1 Explain in detail how this follows the Serializer design pattern and why only partly so. (2) 2.5.2 How do the encapsulation requirements of the Serializer design pattern differ from those of the Memento design pattern? (4) Question 3 [21 marks] Along with flights and passengers, a database of available aircraft is also needed. The following Aircraft UML class diagram and AircraftDatabase class have been proposed. The QMap in the aircraft database maps an aircraft registration number to the Aircraft instance for that particular registration. The sequence numbers provide a unique number for each aircraft. class AircraftDatabase { public: AircraftDatabase(); QString aircraftDetails(QString regnum) const; private: QMap<QString, Aircraft> aircraft; static long sequenceNumber; }; 5 COS3711 May/June 2020 3.1 It has been suggested that this database should follow a Singleton design pattern. 3.1.1 Why would a Singleton be a good idea in such a case? (2) 3.1.2 Does this suggested class meet the requirements of a Singleton design pattern? If yes, explain in detail why you say so; if no, explain what the problem is, and how the Singleton should be implemented. You may include explanatory code if you find it necessary to explain your answer. (5) 3.2 A search function, search(QString reg), receives a QString parameter representing an aircraft registration number, searches an AircraftDatabase instance, and outputs the Aircraft data associated with the registration number to the standard output. This search function needs to be run as a separate process, with its output managed by the function void Data::acceptAircraft(). Write the code necessary to start the search function as a separate process (passing \"A6-EEY\" as a parameter) and have its output managed by the acceptAircraft() function. Use the start() function declaration below to guide you. void QProcess::start(const QString &program, const QStringList &arguments, QIODevice::OpenMode mode = ReadWrite) You should include instance creation where necessary. (7) 3.3 The design team decided that a Factory Method design pattern should be used to move the responsibility for creating Aircraft instances to a separate class (CreateAircraft). Assuming that the class definition for this class exists, write the code for the function that will implement the Factory Method pattern (as it would appear in the CreateAircraft implementation file). You may assume that only two types of aircraft will be involved (where the class names are given in brackets and are derived from Aircraft): Boeing 373-800 (B738), and Airbus A380-800 (A388). (3) 3.4 Considering all the functionality that has been included in this scenario (flights, reading and writing lists of flights, passengers on flights, managing and writing passenger lists, an aircraft database), describe how a Façade design pattern may be of use. (4) © UNISA 2020","libVersion":"0.2.3","langs":""}