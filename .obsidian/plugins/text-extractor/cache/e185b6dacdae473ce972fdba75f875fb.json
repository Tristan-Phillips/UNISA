{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Lecturer Notes/Assignment Feedback/61138010-A1-COS3751-2023.pdf","text":"Student Number: 61138010 COS3751 - Assignment 01 Student number: 61138010 UAN: 533732 Due date: 29 May 2023 Queson 1 1.1 - A task environment is eﬀecvely fully observable if the sensors detect all aspects that are relevant to the choice of acon. In a parally observable environment, the enre state of the system is not fully visible to an external sensor, because of noisy and inaccurate sensors or because parts of the state are simply missing from the sensor data. 1.2 - In a determinisc environment the outcome of an acon or event is enrely predictable and known in advance. \" If the next state of the environment is completely determined by the current state and the acon executed by the agent(s), then we say the environment is determinisc \" A Stochasc environment is, the outcomes are inﬂuenced by random or probabilisc factors. Thus, the exact outcome or results of an acon cannot be predicted with certainty. 1.3 - 1 - Chess: Determinisc - Moves are clearly deﬁnes, and the outcomes of each players moves can be completely determined 2 - Soccer: Stochasc - Weather and wind can inﬂuence the outcome of a basic acon such as kicking the ball. 3 - Self-driving car: Stochasc - A self-driving car on a public road is subject to road condions, as well as responding to the driving quality of other drivers. Queson 2 2.1 - A well-deﬁned problem has the following ﬁve components 1 - A start or inial state : The inial state represents the starng point of the problem. It deﬁnes the condion or conﬁguraon in which the problem is presented to the problem solver. 2 - A descripon of acons available to an agent : Acons available refer to the set of allowable acons or operaons that can be applied to transform the one state to another. 3 - A descripon of what each acon does, the transion model : Captures the cause-and- eﬀect relaonship between acons and state changes. 4 - A goal test : Deﬁnes the criterion or condion that determines whether a given state is a goal state, achieved the desired soluon. 5 - Path cost : Represents the cost associated with taking a parcular acon or moving from one state to another. 443540% Student Number: 61138010 2.2 - Search space encompasses all possible states that can be explored during the problem-solving process, including valid and invalid states. The goal space represents the subset of states within the search space that sasfy the speciﬁed goal or objecve. The search space covers the enre soluon space, the goal space focuses speciﬁcally on the states that meet the desired criteria for a soluon 2.3 - The primary funcon is to keep track of the states that have already been visited or explored during the search process. The explored set helps prevent redundant or repeated exploraon of states 2.4 - The state space refers to the set of all possible states that an environment can have. The search space refers to the subset of the state space that is explored during the search process to ﬁnd a soluon. We could consider the following scenarios in which the state space is ﬁnite but the search space becomes inﬁnite: -> The state space may have a ﬁnite number of states, but the branching factor from each state is very high or unbounded. This means that from each state, there are a large number of possible acons or transions that can be taken -> Even though the state space itself is ﬁnite, the search space becomes inﬁnite due to the vast number of possible paths that can be taken For example in a puzzle, there can be a ﬁxed number of puzzle conﬁguraons, thus the state space is ﬁnite. However, if the puzzle has a high branching factor, the search space can become inﬁnite. Such as in a Rubik's cube. Each move leads to many other possible states. Thus, a state space itself can be ﬁnite, the search space can become inﬁnite if the branching factor from each state is high or unbounded, leading to an exponenally growing number of possible paths or sequences to explore. 2.5 - node.STATE: the state to which the node corresponds; node.PARENT: the node in the tree that generated this node; node.ACTION: the acon that was applied to the parent’s state to generate this node. node.PATH-COST: the total cost of the path from the inial state to this node. Queson 3 3.1 - State: State = (Anele_eggs, Busi_eggs, Chan_eggs, Basket_locaon) Key: - Anele_eggs = the number of eggs Anele is currently holding - Busi_eggs = the number of eggs Busi is currently holding - Chan_eggs == the number of eggs Chan is currently holding 1284 Student Number: 61138010 - Basket_locaon = the locaon of the basket, which can contain one of the following four values: \"with Anele\", \"with Busi\", \"with Chan\", \"empty\" If Anele has 10 eggs, Busi has 8 eggs, Chan has 1 egg, and the basket is being held by Chan then the state can be represented as: (10, 8, 1, \"with Chan\") During the search process, this notaon can be employed to represent and manipulate diﬀerent states by updang the number of eggs each sibling has based on the allowed acons or transions. It enables the search algorithm to keep track of the state changes and progress towards the goal state where each sibling has their fair share of eggs. 3.2 - Start State: (15, 9, 6, \"empty\") Goal State: (15, 9, 6, \"empty) 3.3 - Cost of carrying the eggs: 1 Cost of carrying more eggs than your individual share: 10 for each egg Cost of carrying more eggs than there are in total: 100 for each egg 3.4 - //Empty 3.5 - //Empty Queson 4 4.1 - The main diﬀerences between tree and graph search are the following: Tree Search: Only explores states generated from the inial state. Does not check for duplicate states or revisit already explored states. Can have high space complexity due to potenal redundancy in storing states. Not inherently complete as it can get stuck in inﬁnite branches or cycles. Does not guarantee opmality as it does not consider the cost of reaching each state. Graph Search: Explores states generated from the inial state and avoids duplicate states. Checks for duplicates and avoids revising already explored states. Reduces space complexity by eliminang redundancy in storing states. Typically designed to be complete by avoiding inﬁnite loops or revising states. Can be designed to ﬁnd opmal soluons by considering the cost of reaching each state. Graph search extends tree search by avoiding duplicate states and ensuring completeness while oﬀering the potenal for opmality. By explicitly tracking explored states and prevenng redundant exploraon, graph search improves eﬃciency and reduces space complexity compared to tree search. 4.2 - Breadth-First Search (BFS) rates as follows in terms of the four criteria for measuring the performance of problem-solving algorithms: 3114 Student Number: 61138010 Completeness: BFS is complete, meaning that it is guaranteed to ﬁnd a soluon if one exists within a ﬁnite depth limit. It explores all possible states at each depth level before moving deeper into the search space. Opmality: BFS is opmal when the step costs between states are uniform. It explores all states at a certain depth level before moving to deeper levels, ensuring that the opmal soluon, if it exists, will be found at the shallowest possible depth. Time Complexity: The me complexity of BFS is exponenal in the search depth. It explores all states at each depth level, resulng in a potenally large number of state exploraons. However, BFS can be eﬃcient when the soluon is located near the root of the search tree. Space Complexity: The space complexity of BFS is also exponenal in the search depth. It needs to maintain a froner or queue to store the generated but unexplored states at each level. The memory requirements of BFS can become prohibive for large or deep search spaces 4.3 - In the 4x4 sliding-block puzzle that has unique alphabecal leers in each cell except for one empty cell, we can calculate the number of disnct states as follows: For the ﬁrst cell, we have 15 opons to choose from (since one cell is empty). For the second cell, we have 14 opons remaining (since one cell is already occupied and one is empty). For the third cell, we have 13 opons remaining, and so on. Connuing this process for all 16 cells, the total number of disnct states can be calculated as follows: 15 * 14 * 13 * ... * 2 * 1 = 15! Therefore, for the given 4x4 sliding-block puzzle, the number of disnct states is 15!. Queson 5 5.1 - //Empty Queson 6 6.1 - Uniform Cost Search (UCS) is a search algorithm used to ﬁnd the opmal path from a start state to a goal state in a graph or tree. It expands the nodes with the lowest cumulave cost from the start state, ensuring that the path with the minimum cost is discovered. 4 Student Number: 61138010 Assume we have the following graph, with the weight of each path being represented by the respecve number Using UCS we start wit A at a cost of 0. The expansion process proceeds as follows: 1 - Expand A (cost 0). Add B (cost 5) and C (cost 3) to the priority queue 2 - Expand C (cost 3). Add F (cost 9) to the queue 3 - Expand B (cost 5). Add D (cost 7) and E (cost 99) to the queue 4 - Expand D (cost 7) 5 - Expand E (cost 9) 6 - Expand F (cost 9). Add G (cost 10) to the queue 7 - Expand G (cost 10) The search terminates when the goal state G is expanded. The opmal path found is A->C->F->G, with a total cost of 10. Queson 7 7.1 - A consistent heurisc provides addional guarantees by maintaining a consistent relaonship between the heurisc values of states and their neighbors. Admissible heuriscs guarantee opmality, while consistent heuriscs can improve the eﬃciency of search algorithms Queson 8 8.1 - //Empty 8.2 - //Empty 8.3 - //Empty 8.4 - //Empty 42","libVersion":"0.2.3","langs":""}