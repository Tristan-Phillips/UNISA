{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Virtual Classes/VC_Assignment1_Revision.pdf","text":"COS3711 – Advanced Programming Virtual Class: COS3711 - 22 - ALL Revision – Chapters 7, 12, 13 Lecturer: Dr C Pilkington Tutor: Ron Barnard Revision Assignment 1 Chapter 7 - Libraries Building Ezust libraries only required to do the examples in the prescribed book. To build the libraries - • Only need to add the CPPLIBS environment variable in Qt, not actually required in the operating system. ◦ Projects / Build environment / Details. • Can add library to project by using Qt's 'Add library'. ◦ Right click on project name / Add library / External library / Follow instructions. • Copy .dll file into project build directory. • Include library header file in class / file where required - ◦ #include \"dataobjecttablemodel.h\" Revision Assignment 1 Chapter 12 - Reflection • Reflection – The self-examination of an object's members – provides information about the properties and methods of an object. • Meta object – An object that describes the structure of another object. • QVariant – Acts like a Union for most Qt data types. A Union is a special C++ class type that can hold only one of its non-static data members at a time. A QVariant object holds a single value of a single type at a time. Types can be multi-valued eg: QStringList. • QObject – Base Class of all Qt objects. Useful methods - ◦ metaObject() - returns a pointer to the object's meta-object; ◦ setProperty(name, value) – Set fixed / dynamic properties; ◦ property(QString propertyName) – returns QVariant of property value; ◦ dynamicPropertyNames() - returns a QList of dynamic property names. Revision Assignment 1 Chapter 12 - Reflection class Customer : public QObject { Q_OBJECT Q_PROPERTY(QString name READ getName) Q_PROPERTY(QString id READ getId WRITE setId) Q_PROPERTY(QString phone READ getPhone WRITE setPhone NOTIFY phoneChanged) public: Customer(QString name, QObject *parent = 0); QString getName() const; QString getId() const; void setId(QString id); QString getPhone() const; void setPhone(QString phone); signals: void phoneChanged(QString newPhone); private: QString m_name, m_id, m_phone; }; Revision Assignment 1 Chapter 12 - Reflection Write Fixed properties - Customer *cust = new Customer(\"Joe Bloggs\"); // Set fixed properties cust->setId(\"12345678\"); // cust->setProperty(“id”, “12345678”); cust->setPhone(\"555-67890\"); cust->setObjectName(\"Harry\"); // QObject default property Read Fixed properties - // Declare pointer to Object's metaObject const QMetaObject *metaObj = cust->metaObject(); // Determine how many properties the Object has int count = metaObj->propertyCount(); // Loop through the properties, extracting name and value for (int index = 0; index < count; ++index) { QMetaProperty metaProp = metaObj->property(index); const char *propName = metaProp.name(); QVariant propValue = cust->property(propName); out << \"Name: \" << propName << \"\\t\" << \"Value: \" + propValue.toString() << Qt::endl; } Revision Assignment 1 Chapter 12 - Reflection • Fixed properties - ◦ are defined at compile time; ◦ are stored in QMetaObject; ◦ all objects of Class have same meta-object – same properties NOT same values; • Dynamic properties - ◦ are handled at run-time; ◦ are added to QObject, not QMetaObject; ◦ are specific to each object - objects all have same meta properties, but different dynamic properties; ◦ Use QObject::setProperty(name, value) to set dynamic properties. QObject::property(propName) to read properties. (Same as fixed properties). Revision Assignment 1 Chapter 12 - Reflection Read Dynamic properties - // Display dynamic properties out << \"\\n\\n\" << \"Dynamic Properties\" << \"\\n\" << Qt::endl; // Use dynamicPropertyNames() method of QObject // Returns QList<QByteArray> of all properties added dynamically foreach(QByteArray dpName, cust->dynamicPropertyNames()) { QString name = Qstring(dpName); QString value = cust->property(dpName).toString(); out << \"Name: \" << name << \"\\t\" << \"Value: \" << value << Qt::endl; } Revision Assignment 1 Chapter 13 – Models and Views M-V-C – Divides application logic into three components, based on their responsibilities. Decouples data from on-screen representation and user input – ◦ reduces complexity; ◦ promotes flexibility and code re-use; ◦ allows multiple views of the same data; ◦ separation of concerns; • Model – Manages access to data – can be stored in file, database etc. • View – The screen representation (User interaction). • Controller – Processes user input, instructs Model. Revision Assignment 1 Chapter 13 – Models and Views Qt implementation of Model-View • Qt combines the View and Controller – M-V architecture; • Separates the way data is stored from the way it is presented; • Same data can be displayed in different Views, and new types of Views implemented, without changing data structure; • Adds Delegate – allows flexible handling of user input, and • customization of rendering and editing of data; • M-V Classes separated into 3 groups – Models, Views, Delegates; • Each defined by abstract Classes that provide common interfaces / implementations; • Abstract Classes must be sub-classed to provide full / additional functionality. • Models, Views, and Delegates communicate using signals and slots - ◦ Signals from Model inform View about changes to the data; ◦ Signals from View provide information about user interaction with View; ◦ Signals from Delegate inform Model and View about any editing. Revision Assignment 1 Chapter 13 – Models and Views Models • All item Models are based on QAbstractItemModel; • Defines interface used by Views and Delegates to access data; • Can handle tables, lists, and trees; • QAbstractTableModel and QAbstractListModel are better for Tables / Lists - provide default implementations of common methods. • Ready-made models - ◦ QStringListModel – Lists of QString items; ◦ QStandardItemModel – Multipurpose – list, table, and tree views; ◦ QFileSystemModel – Files and directories in local file system. • NB: Abstract (must be sub-classed) vs concrete classes. Revision Assignment 1 Chapter 13 – Models and Views Views • All Views are based on QAbstractItemView; • Defines interface used by Views; • Can handle tables, lists, trees and columns; • Ready-made Views (Can be sub-classed) - ◦ QListView – Displays list of items; ◦ QTableView – Displays data from a model in a table; ◦ QTreeView – Displays tree representation of items from a model; ◦ QColumnView – Displays multiple QListViews, based on trees (Cascading list). • Headers – access the same Model as the View that contains them. • Use QHeaderView Class – displays headers in views QTableView, QtreeView. • Retrieve data from model: QAbstractItemModel::headerData() method. • Set header data: QAbstractItemModel::setHeaderData(); Revision Assignment 1 Chapter 13 – Models and Views Delegates • M-V does not include separate component (Controller) for managing user interaction. Generally, View is responsible for processing user input, and presenting model data. • Delegates – control rendering and editing of individual items in Views. • Provide editing capabilities (flexibility) for Views. • All Delegates are based on QAbstractItemDelegate; • QStyledItemDelegate - default Delegate provided by Views; • Provides default implementation of Delegate interface; • Can be sub-classed, to change appearance of View. Revision Assignment 1 Assignment 1 • Advised to complete exercises, particularly 4 and 5, including quizz – before attempting the assignment. • Closing date – Remains Monday 16 May 12h00 midday. • Read requirements carefully - ◦ Please note that Qt Designer should not be used, and you are expected to manually set up GUIs to ensure that you properly handle memory using Qt’s parent-child functionality. ◦ Marks will also be awarded for following good programming practice, for example, naming conventions, code layout, using initialiser lists in constructors, and GUI handling like setting focus, tabbing and clearing input widgets (like text input fields being cleared and spin boxes being returned to some default value), and providing appropriate user feedback. Your code should build and run without any warnings. • Added functionality – Can add functionality, but do not detract from requirements. Revision Assignment 1 Question 1 Badly designed class - Anti-Pattern / Single Purpose principle / Separation of Concerns. Separation of Concerns (SoC) – is the process of breaking a computer program into distinct features that overlap in functionality as little as possible. A 'concern' is any piece of interest or focus in a program. Typically, concerns are synonymous with features or behaviours. • Applications should be split into modules whose functionalities overlap as little as possible. (Modules / functions / methods / classes / structs). Single Purpose Principle (SPP) – (Single Responsibility Principle) • Every object should have a single responsibility, and all its services should be narrowly aligned with that responsibility. • A Class should do one thing, and do it well. • A Class should have only one reason to change. SoC is a more general / broad statement. SPP is a specific case of SoC. Revision Assignment 1 Question 1 Redesign the Film class so that the functionality currently included in it can be achieved using three different classes. 1. The Film class to represent a film with the necessary functions (as given in the above UML class diagram). 2. A FilmWriter class which saves the state of a Film instance (values of the data members of that instance) to a file (you may save it in any sensible format that is human-readable). 3. A Graphical User Interface (GUI) class FilmInput, which allows users to enter film information to create Film instances as well as to save Film instances to file (using the FilmWriter). Note: You can decide when Film instance(s) should be saved. Note: Question does not state that you are limited to only three classes. Revision Assignment 1 Question 2 Make necessary changes in the Film class so that you can access the data members of Film instances using QMetaObject. Rewrite the FilmWriter class so that the state of a Film instance is accessed using the generated QMetaObject. Three requirements for using fixed properties - • Inherit QObject; • Include Q_OBJECT macro; • Define properties using Q_PROPERTY(). Revision Assignment 1 Question 3-1 Use Qt’s model/view framework to store and display music CD information. The following information should be stored in the model (a QStandardItemModel): • composer, • album name, • cost, and • a rating (out of 100). The information should be displayed in a table. The following functionality should be included. • There should be a header row. • The user should be able to add rows of data to the model. • The user should be able to edit data in the view. • The replacement value should always display the cents (even as .00), even after editing. • The user should be able to sort the data by clicking on the column header on which the sorting should be implemented. Revision Assignment 1 Question 3-2 • Where the replacement value is greater than or equal to R250, the row should be made a different colour. Note that this colour should also change if the user edits a replacement value (and it should return to the normal colour if the value drops below R250). • The user should be able to delete a row of data. Here is an example of the interface. Revision Assignment 1 Question 3-3 • Read documentation for QStandardItem and QStandardItemModel. • Some useful methods - ◦ setDecimals() ◦ setBackground() ◦ role – BackgroundRole ◦ QString::number() • Three possible approaches for setting decimals, background colour - ◦ Sub-class the model; ◦ Use a method to access the required functionality through QStandardItem. ◦ Implement a delegate (for decimals). • Two ways of implementing sorting – either through the model, or the view. Revision Assignment 1 Question 4 & 5 Question 4 Make necessary changes in the Film, FilmWriter, and FilmInput classes (used in Question 2) to meet the following criteria: • When a Film instance is created, the dynamic property genre is added with the value Unknown. • When the object state is saved to file, both the QMetaObject and dynamic properties are saved. Question 5 Modify Question 3 by displaying the rating using a delegate (where the rating is shown as a coloured bar and not a number). Use the following diagram as an example. Use QStyledItemDelegate – override the paint() method. Edit option.rect()","libVersion":"0.2.3","langs":""}