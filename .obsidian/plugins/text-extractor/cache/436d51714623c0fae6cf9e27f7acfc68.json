{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/201_2016_1_b.pdf","text":"BAR CODE Learn without limits. university of south africa Tutorial Letter 201/1/2016 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 School of Computing IMPORTANT INFORMATION This tutorial letter contains model solutions for assignment 01 COS3751/201/1/2016 ASSIGNMENT 01 Solution Total Marks: 150 UNIQUE ASSIGNMENT NUMBER: 783828 Study material: Chapters 1 through 4. You may skip sections 4.2 and 4.5. Question 1: 9 Marks (1.1) (6)Compare Simple Reﬂex Agents to Model Based Agents. Pay attention to: • the environments in which one may outperform the other, • the difference in their architecture, • their underlying implementation and functioning. Simple reﬂex agents react purely based on the rules governing their current percepts. They work well in fully observable environments and consist of simple percept and rules (condition-actions), They have no memory, or model of the world. As all agents do, they have sensors-rules-actuators.✓3 Model based agents maintain an internal state/model of the world (thus, there is mem- ory, as well as rules that modify their internal model in order to keep track of those parts of the world they cannot observe), they work particularly well in partially observable environments (and will typically outperform simple reﬂex agents here).✓3 (1.2) (3)Consider a Global Positioning System (GPS) navigation unit one might ﬁnd in a car. Does this unit constitute an agent as deﬁned in the text book? Justify your answer. Based on the deﬁnition in the textbook it does not✓. It does bear a striking resem- blance to a simple problem solving (goal based) agent with one difference: it has no ability to execute the plan that was created, that is, there is no way for the GPS unit in your vehicle to effect a left or right turn in the car, unless we account for the fact that YOU may form part of the ’agency’ (i.e you are the actuators the GPS agent uses to effect change in its world.)✓✓. Question 2: 23 Marks (2.1) (5)List the 5 components that can be used to deﬁne a problem. 1. Initial state✓ 2. Actions✓ 3. Transition model✓ 4. Goal test✓ 5. Path cost✓ 2 COS3751/201 (2.2) (2)Differentiate between search space and goal space. The search space is the set of states that have to be searched for a solution✓, whereas a goal space is a set of goal states✓. (2.3) (2)Differentiate between expanding and generating with respect to searching. Expansion is the action of applying all legal actions to the ’current’ state (i.e. a par- ticular state that was chosen in some way)✓, when applying a legal action to a state, other states may be generated which can be placed on the frontier.✓. (2.4) (6)List and discuss three types of queues that may be employed in a search. 1. FIFO✓: used in DFS searches, nodes are added in reverse order to ensure that the last node added will be the ﬁrst node to be explored.✓ 2. LIFO✓: Typically used in BFS searches: nodes are added in the order they are generated.✓ 3. Priority queue✓: Nodes are added and sorted based on some key, this ensures that certain states take priority over others during the expansion phase.✓ (2.5) (8)List and explain the measures used to determine problem solving performance. 1. Completeness✓: Will the algorithm ﬁnd a solution if it exists? ✓ 2. Optimality✓: Will the algorithm ﬁnd the best solution (optimal path cost among all solutions)? ✓ 3. Time complexity✓: How long does the algorithm take to ﬁnd a solution? ✓ 4. Space complexity✓: How much memory is needed to perform the search for a solution? ✓ Question 3: 12 Marks Consider the simple game of tic-tac-toe, or as we call it naughts-and-crosses1. The game is played by two players on a three by three square board, and each player takes a turn to place a token in a square. Each player has their own token: either an ’X’ (crosses) or an ’O’ (naughts). (3.1) (2)If we can formulate the problem in a way that allows it to be translated into a computer based solution, we can easily implement an agent that can play the game. Deﬁne a mathematical state representation for the game. Remember: a state rep- resentation is supposed provide a snapshot of the world at a particular point in time. In terms of an agent, this means it will be what it can perceive at a particular point in time. Hint: Read the section on arrays in the mathematical background chapter of your textbook. 1https://en.wikipedia.org/wiki/Tic-tac-toe 3 X O Figure 1: Naughts and Crosses sample A simple state representation is a matrix representing the board in its entirety. Thus we have the tic-tac-toe board: B, with bij ∈ {0, 1, 2}, 1 ≤ i, j ≤ 3✓, where a 0 represents an empty square, a 1 presents a ’O’, and a 2 represents a ’X’.✓ (3.2) (2)Now that you have deﬁned a state representation, deﬁne the initial state for the prob- lem. Using the proposed state representation above, we can easily use the following for our start/initial state. B0 =   0 0 0 0 0 0 0 0 0   ✓✓B0 is used to represent the start state for the game. (3.3) (2)Deﬁne an applicable action for the agent using the start state. Assume that naughts moves ﬁrst 2. So an action should simply deﬁne a legal action that can be taken given a state. Ideally it should be the same for every state. A good general action would thus be something like Put(P, i, j). With P ∈ {1, 2}, and 1 ≤ i, j ≤ 3. This allows us to place a 1 or a 2 in the appropriate place given the row and column indicators i and j.✓ For the start state we may have Put(1, 2, 2) which would result in an naught right in the middle of the board.✓ (3.4) (2)Now deﬁne an applicable action for the state resulting from the action you deﬁned ﬁrst. Now suppose the ﬁrst move was in fact an ’O’ being placed in the centre of the board. That is: B ′ =   0 0 0 0 1 0 0 0 0   We now simply deﬁne an action to place an ’X’ somewhere on the board. For example: Put(2✓, 1, 1)✓ which would result in B ′′ =   2 0 0 0 1 0 0 0 0   2That is, the user using token ‘O’ moves ﬁrst 4 COS3751/201 (3.5) (4)Deﬁne a goal state for the problem based on your state representation. Explain how an agent might detect a goal state using your state representation. (Remember, as humans we can easily see a state and interpret a state as a goal – it is not so simple for computers). A goal state, based on the rules of the game, results from a row, column, or any one of the diagonals containing the same symbol: an ’X’ or an ’O’. Suppose for example ’O’ won the game. A sample goal state here would be: BG =   1 2 2 0 1 0 0 0 1   ✓✓ (it is not enough to simply show a board with just 1s (’O’s) on it, remember, the other player will move as well.) There are many more variations on this. How would we determine if the goal state was reached? Any algorithm which tests if all the columns or rows is 1 (or 2), as well as testing for the diagonals will do the job✓✓. Question 4: 15 Marks (4.1) (3)Highlight the differences between a tree and graph search. Remember that a tree is a simple-connected acyclic graph. (That means that there are no loops, and that by deﬁnition there must be nodes that have no children.) A graph, on the other hand may have cycles or loops. The main difference between a tree search is thus that we don’t need to keep track of already explored nodes, since a simple tree cannot have revisited states. Thus, the tree search simple selects a leaf node from the frontier, goal tests, and if it is a goal it returns the path (solution) to that node.✓ Applying a tree search to a graph creates problems since there may be redundant paths and loops. The graph search solves this problem by augmenting the tree search with a ’closed list’ (or explored list). When nodes are generated during the search that are already on the closed list they are not added to the frontier.✓✓ (4.2) (3)Explain what a redundant path is, and why redundant paths may cause intractability problems during goal searches. A redundant path is a (worse/another) solution to the same problem. For example generating a slower (or longer) route to a destination.✓ Redundant paths may not always be a problem as far as tractability is concerned, but a redundant path could be a loop, in which case the problem may have several redundant paths (which can quickly bloom into a vast number of paths to consider). This could cause a relatively straight-forward problem to become intractable. ✓✓ 5 A B E I F H C N G J L M O K D Figure 2: Sliding-block puzzle (4.3) (4)Consider the sliding-block puzzle game state provided below (ﬁgure 2). How many distinct states are there for this puzzle? How many search nodes? Explain how you reached your answer. It is interesting to note that half of random start states for the 15 puzzle are not solvable. For the 15-puzzle, we will always have 16! distinct states. However, since only half of the random start states are solvable, we have a possible search space of 16!/2.✓4 Why use 16!? If we start with an empty board we can choose to place any of the 16 tokens (numbers 1 to 15 and space) in the top-left position, from here on we can choose any one of the remaining 15 tokens for the position just to the right of the top-left, and so we carry on: 16 × 15 × 14 × ... × 2 × 1 = 16!. If you’re concerned about the number of distinct states for the example provided above, you will have to consider the number of moves that can be used to solve the puzzle – but that would only yield a possible lower-bound (assuming our search is super- efﬁcient) on the search space. From a space-complexity viewpoint, it will sufﬁce to state that the upper bound of the distinct number of states is 16!. (4.4) (5)Explain the separation property of the graph search. Provide an example to support your discussion. The graph search separates the state space of the search into explored and unex- plored states.✓✓ An example is straight-forward: ﬁnding a route from one town to the next – we have a set of paths representing towns already visited during our search, and a set of paths for towns we still have to visit.✓✓✓ Question 5: 9 Marks Consider the search tree in ﬁgure 3. (5.1) (6)Show the order in which the nodes will be expanded (from limit 0 to limit 4) given that IDS is used. Assume the goal node is O, and that nodes are expanded from left to right. So expansion means we apply legal actions to a chosen node – this, by deﬁnition, means that our order look somewhat different from what one may expect. 1. Limit 0: (No expansion – A is generated but not expanded) ✓ 6 COS3751/201 A B D H I E J K C F L M G N O Figure 3: Search Tree (Iterative Deepening Search (IDS)) 2. Limit 1: A ✓ 3. Limit 2: A B C ✓ 4. Limit 3: A B D E C F G ✓2 5. Limit 4: A B D H I E J K C F L M G N ✓ Note that O is not expanded since the goal test is performed on generation! (5.2) (3)Has this search performed better than a regular Depth First Search (DFS) in terms of space complexity? Explain your answer. (Assume a DFS in which nodes are also expanded from left to right.) Remember that the IDS is a dynamic version of the depth limited search which is in essence a DFS. In terms of space requirements it should thus not use more space than a DFS (remember: it generates nodes in the same fashion as DFS, but discards them when the depth limit is reached). No✓. To ﬁnd the solution we had to generate the entire search tree✓that the DFS would have generated in any case.✓ Question 6: 18 Marks Consider the graph in ﬁgure 4. (6.1) (2)Explain the concept of Uniform Cost Search (UCS). Uniform cost search is a greedy search algorithm (it is also an uninformed search – thus no heuristics!). It calculates the cost of moving from this state to the next (keeping the cost of reaching the current state in mind), and chooses the cheapest (as deﬁned in the problem) next state from the frontier✓✓. It helps to think of it as explained in the textbook: it uses an evaluation function (similar to an informed search such as A ∗): ˆf (n) = ˆg(n) or just ˆg(n). 7 A B C D E F G H 11 20 15 4 24 22 14 12 9 Figure 4: Search Graph (Uniform Cost Search (UCS)) (6.2) (2)Differentiate between path and step cost. Path cost is the sum of all steps along a particular path✓, and step cost is the cost between two nodes that are next to each other in the state space✓. (6.3) (2)How does UCS select the next node for expansion? It simply chooses the node from the frontier that will minimise total path cost✓✓. (6.4) (12)Suppose we start at B and the goal is F . Write down the nodes in the order they are expanded. Show your steps and calculations. The step cost between nodes is provided next to the edges in the graph. Since we’ve been talking about uniform cost, we’ll use the UCS algorithm. 1. B is placed on the frontier. (Technically we would put (B,B,0) on the frontier – see the next step for more detail) 2. Choose B (and remove) for expansion: generate the path (B,A, 11) and (B,D, 15) 8 COS3751/201 (where (B,A,11) means that there is a path from B to A which costs 11) ✓ 3. Choose (and remove) (B,A,11) (lowest cost, but not goal) – generate (B,A,C,31) and place on the frontier. ✓ 4. Choose (and remove) (B,D,15) (lowest cost, but not goal) – generate (B,D,E,37) and (B,D,G,29) and place on the frontier. ✓ 5. Choose (and remove) (B,D,G,29) (lowest cost, but not goal) – generate (B,D,G,H,41) and place on the frontier.✓ 6. Choose (and remove) (B,A,C,31) (lowest cost, but not goal) – generate (B,A,C,E,55), (B,A,C,F,35) and place on the frontier. ✓ 7. Choose (and remove) (B,A,C,F,35) (lower cost, and goal) – search terminates.✓ Taking the nodes from the map as they are expanded, you thus have B,A,D,G,C.✓✓✓✓✓✓. Question 7: 12 Marks (7.1) (3)Explain what a heuristic function is. A heuristic function estimates✓the cost from the current✓to the goal✓. (Alternatively, a heuristic imparts additional information on the search/state space that can be used in order to make the search more efﬁcient and potentially produce an optimal result.) (7.2) (4)Differentiate between an admissible and a consistent heuristic. An admissible heuristic does not overestimate the actual cost of getting from a node in the search space to the goal✓2. A consistent heuristic is more strict than an admissi- ble one: it obeys the triangle inequality: it is not possible for one side of a triangle to be longer than the sum of the lengths of the other two sides – thus, the heuristic should not estimate a higher cost from a node to a goal than a shorter actual path to the goal from that node.✓2 (7.3) Greedy best-ﬁrst search is not optimal but is often efﬁcient. (a) (2)Explain what is meant by this statement. The search may not ﬁnd the best solution to the problem, but if one exists it may ﬁnd it in an acceptable time/with acceptable space cost✓2. (b) (3)Provide an example to support your answer to the previous question. Any example in which it is shown that the GBF search quickly zooms in on a solution (such as ﬁnding a path from a node to another in a state space), which is not optimal.✓3 9 A B C D F G H I L K M E N 7 8 3 10 10 5 8 5 7 6 4 4 3 3 2 5 10 1 Figure 5: A ∗ Search Question 8: 31 Marks Consider ﬁgure 5 and table 1 and answer the questions that follow. Table 1 provides the estimated distances from each node to H (thus ˆh for each node). The label next to each edge provides the cost between nodes (thus ˆg). Node Estimated distance to H A 10 B 12 C 4 D 5 E 4 F 7 G 4 H 0 I 4 K 2 L 1 M 1 N 6 Table 1: Distance Table 10 COS3751/201 (8.1) (10)List the nodes in the order in which they are expanded (not generated). Show your steps (don’t just list the nodes, explain the reason for each choice). Lets start by adding A to the frontier so that the search can kick-off. In actual fact we add A with some additional information so that the search can discriminate between good choices during the search. We’ll add < P n s , cn s >, where P n s is a path than can be explored (from the start node S to node n), and cn s is the cost of getting to n added to the estimate of getting to G (the goal). But we know that for A∗, cn s is ˆf (n) = ˆh(G) + ˆg(n) So, we choose the node in the frontier with the lowest ˆf : < A, (10) >, and we expand it. Expanded thus far: A. Current frontier (ﬁrst item is always chosen next): 1. << A, D >, (8) > 2. << A, C >, (12) > 3. << A, B >, (15) > Now we choose, again, the node from the frontier with the lowest ˆf value: << A, D > , (8) >. This means we have to expand D next. Expanded thus far:A,D So we expand D, and the frontier then looks thus: 1. << A, D, K >, (9) > 2. << A, D, L >, (10) > 3. << A, C >, (12) > 4. << A, D, I >, (14) > 5. << A, B >, (15) > The search node with the lowest ˆf is the one with the path through K , so we choose that, and thus we expand K . Expanded thus far:A,D,K Frontier: 1. << A, D, L >, (10) > 2. << A, D, K , M >, (10) 3. << A, C >, (12) > 4. << A, D, I >, (14) > 5. << A, B >, (15) > 6. << A, D, K , E >, (16) 11 Notice that I’ve placed the path to M below the path to L even though they have the same ˆf values. I did this as an internal conﬂict protocol (internal to the algorithm). As long as I am consistent in applying this conﬂict resolution (and it is not grossly wrong) everything should turn out ﬁne. In this case the rule is simple: paths with fewer nodes have priority. So we choose the path through L, and thus expand L. Expanded thus far: A,D,K,L. Frontier: 1. << A, D, K , M >, (10) 2. << A, C >, (12) > 3. << A, D, I >, (14) > 4. << A, B >, (15) > 5. << A, D, K , E >, (16) 6. << A, D, L, N >, (18) > Now we get to choose the path through M. Expanded thus far: A,D,K,L,M Frontier: 1. << A, C >, (12) > 2. << A, D, I >, (14) > 3. << A, B >, (15) > 4. << A, D, K , E >, (16) 5. << A, D, K , M, N >, (16) Notice that we found a shorter route to N: we thus remove the old route << A, D, L, N > , (18) > from the frontier. Next we choose the path from A to C. Expanded thus far: A,D,K,L,M,C Frontier: 1. << A, C, H >, (13) > 2. << A, D, I >, (14) > 3. << A, B >, (15) > 4. << A, D, K , E >, (16) 5. << A, D, K , M, N >, (16) 6. << A, D, L, N >, (18) > 7. << A, C, G >, (20) > 12 COS3751/201 (Why don’t we just quit when we generate A,C,H?) Choose the node on the frontier with the lowest ˆf value. In this case it is actually our goal path. However, we have started the process of expansion, although we won’t apply actions to the selected node. So our ﬁnal answer is: A✓2, D✓, K✓, L✓2, M✓2, C✓2 Implicit in the actions presented above is a goal check when the next node is chosen from the frontier. (One could argue that when ACH is generated it can be determined that it will have the smallest ˆf value and the search can terminate. In this case the argument is true, provided ACG is generated ﬁrst. However, it may be the case that we have no way of determining if we’ve reached the optimal path to the goal without generating all the nodes from AC. The simplest solution is to generate the nodes, and then do the goal check when the next element is chosen as part of the expansion task.) (8.2) (4)When adding nodes to the frontier, many people assume that we simply add the nodes in the search space (in this case the graph). This is not always the correct approach. Explain why this is so, and state the difference that will exist between the nodes in the search space and the nodes in the frontier. Simply adding the nodes in the state/search space may not convey the needed infor- mation to solve the problem. It is not always the case, if the search space naturally encodes the solution (or an intermediate solution) then the nodes from the state space should should sufﬁce. For example: if the nodes in the search space for the previous question are simply nodes in the state-space, then the path to follow from start to ﬁnish is not properly encoded in the solution to the problem. We need to have the path to follow (or the route to travel) in order to be able to solve the problem. Thus it is often better to encode partial solutions in the nodes in the search space: in this way they become part of the solution to the problem, and will be used as they are in the frontier.✓✓✓✓ (8.3) (10)Provide the content of the frontier at the time the search terminates. Frontier: 1. << A, D, I >, (14) >✓2 2. << A, B >, (15) >✓2 3. << A, D, K , E >, (16)✓2 4. << A, D, K , M, N >, (16)✓2 5. << A, C, G >, (20) >✓2 13 (8.4) (7)Is the heuristic being applied consistent? Justify your answer by providing proof from the graph. No✓2. We can easily show that the heuristic is not consistent by providing a single case in which it does not satisfy the triangle inequality✓2. ˆh(A) > ˆg(D) + ˆh(D)✓3 (it is somehow cheaper to reach the goal by moving to D from A and then moving onto the goal than it is estimated in reaching it from A), in other words, the one side of the triangle formed AH (cost = 10), is longer than the sum of the sides AD + DH (cost = 8), which violates the inequality. Question 9: 21 Marks Beyond classical search: A magic square is a square of n × n cells, and which has some very interesting properties: all the rows, columns, and diagonals, when summed, adds up to the magic constant. The magic constant is calculated as follows: M = n(n2 + 1) 2 Thus, for n = 3, M = 3(32+1) 2 = 15. The entries in the square are limited to the integers between 1 and n2. For example, a solution for n = 3 is: 4 3 8 9 5 1 2 7 6 Figure 6: Magic Square for n = 3 It is easy to verify that every row, column, and diagonal in the above example adds up to 15. (9.1) (4)Differentiate between a global and local maxima/minima. Local minima/maxima are local solutions in the search space that are optimal solutions to the problem✓2. A global maxima/minima is a solution to the problem that is the best solution in the solution space (no other solution beats it).✓2 (9.2) (2)One way of solving a magic square is to randomly populate the entries, and then swap out values until a solution is found. Deﬁne an appropriate objective function for this approach. A simple objective function is simply the number of rows, columns, and diagonals that sum to 15. The idea is then to favour moves that have higher values for the objective function – for example if we have a square with an objective function value of 4, chances are that we will only need to make minor adjustments to get to 5,6,7, and then 8. We can deﬁne some auxiliary functions to help deﬁne our objective function: r (x) which returns 1 if row x is 15, c(y) which returns 1 if row y sums to 15, and d and d ′ 14 COS3751/201 for each diagonal. r (x) = { 1 if ∑3 j=1 Mxj = 15 0 otherwise c(y) = { 1 if ∑3 k=1 Mky = 15 0 otherwise d = { 1 if ∑3 j=1 Mjj = 15 0 otherwise d ′ = { 1 if ∑3 k=1 Mk(4−k) = 15 0 otherwise Finally we deﬁne our objective function: o(M) = 3∑ j=1 r (j) + 3∑ k=1 c(k) + d + d ′✓2 (1) Another possible solution is to get the absolute value of 15 minus the sum of a row/column/diagonal, and add these together. The objective would then be to min- imise the objective function. r (x) =| 15 − 3∑ j=1 Mxj | c(y) =| 15 − 3∑ k=1 Mky | d =| 15 − 3∑ j=1 Mjj | d ′ =| 15 − 3∑ k=1 Mk(4−k) | Finally we deﬁne our objective function: o(M) = 3∑ j=1 r (j) + 3∑ k=1 c(k) + d + d ′ (2) 15 (9.3) (5)Differentiate between a standard hill-climb search and a simulated annealing search. Would simulated annealing ﬁt the approach in the previous question? Explain your answer. (Hint: think about what simulated annealing is supposed to do with respect to local/global maxima, also think about shoulders and plateaux.) A standard hill-climb attempts to ﬁnd a maximum/minimum by ’climbing/descending the hill’ (moving in the direction of a bigger/smaller objective function result)✓2. It may get stuck at a local max/min. Simulated annealing has some features that try to ’shake things up’ (amongst others it also employs the concept of hardening, or annealing) – in order to avoid getting stuck on plateaux✓2. Simulated annealing works quite well in this case: a random board is chosen at the start, and a random successor is generated, if it is better (using the objective function) it is always accepted, if it is not better, it is accepted with probability e∆E/T : this means the longer we search, the less happy we are to accept ’poor’ moves (this allows us to quickly get out of local minima/maxima at the start).✓. On a side note: remember that SA is supposed to give you a good chance of getting out of local minima/maxima: it does not always succeed. The magic square problem can quite easily be solved using a brute force search. (9.4) (10)Using the approach suggested above, show the ﬁrst 5 states in the search as well as the value of your objective function for each state. (Start off with a randomly populated magic square, and show 4 subsequent “moves”. In each case, show the value the objective function would take for each “move”.) . 9 2 6 3 5 7 1 8 4 Our objective function (the ﬁrst one in the sample solution) is 2. This is our random start, so we perform a random swap of the values on the board. Let’s assume a temperature T = 100.0, and we’ll use a simple linear discounting factor of 0.9 at each interval.✓2 (This doesn’t mean T is linear.) 9 2 4 3 5 7 1 8 6 Here our objective function for the board is 4. This is better than the previous situation (∆E = 2), so we will deﬁnitely use this going forward. T was discounted to 90.0 at the start of the loop.✓2 9 4 2 3 5 7 1 8 6 16 COS3751/201 T is discounted to 81.0 Our objective function evaluates to 3, so we have ∆E = −1. At this point we use thus choose this board with probability e∆E/T = e(−1/81.0) = 0.988 (this is an extremely high probability, so for our purposes let’s say we accept the board 3).✓2 3 4 2 9 5 7 1 8 6 T is discounted to 72.9. Our objective function evaluates to 2. This is even worse than before (but we let the annealing process worry about that). ∆E = −1, and we accept the new board with probability e∆E/T = e(−1/72.9) = 0.986, also very high, and (again for illustrative purposes) we accept.✓2 The penultimate state provided here does not follow from the one above, but it is done with a view on the very last state given (particularly to show how the temperature affects the acceptance of boards). Assume we arrived at the following during the search 3 4 8 9 5 1 2 6 7 (The objective function for this board evaluates to 6.)✓2 Suppose now the following random board is: 3 4 8 9 5 1 2 6 7 And that T = 1.4 (after about 40 iterations). The objective function for this board evaluates to 5. That means ∆E = −1, and now we accept this board with probability e−1/1.4 = 0.508. This is basically a coin ﬂip, and from here on things don’t get better for these ’worse’ cases (look at the footnote again to understand why this is a coin-ﬂip). Copyright c⃝UNISA 2016 3Think about it like this: suppose we create 100 cards, each one with a unique number from 1 to 100. We then colour 99 of them red, and one of them white. The cards are placed in a hat, and we randomly draw one: if the card is red, we accept the move, if it is white, we don’t. 17","libVersion":"0.2.3","langs":""}