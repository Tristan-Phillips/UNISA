{"path":"Subjects/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/lec09_predicatelogic.pdf","text":"Fundamentals of Artificial Intelligence First Order Logic (Predicate Logic) Pros and Cons of Propositional Logic • Propositional logic is declarative: pieces of syntax correspond to facts • Propositional logic allows partial/disjunctive/negated information (unlike most data structures and databases) • Propositional logic is compositional: meaning of P  Qis derived from meaning of P and of Q • Meaning in propositional logic is context-independent (unlike natural language, where meaning depends on context) • Propositional logic has very limited expressive power (unlike natural language) • E.g., cannot say ‘pits cause breezes in adjacent squares’ except by writing one sentence for each square Limitations of Propositional Logic • In propositional logic, we are not able represent the following sentences accurately. • “All men are mortal.” • “Socrates is a man.” • And, we are not able deduct that “Socrates is mortal” from their representations. • We need more expressive power, and the answer is the first order predicate logic. • In predicate logic, we represent those sentences as: • ∀x(Man(x)→Mortal(x) • Man(Socrates) • Mortal(Socrates) • And, we are able to deduct the third one from first two. Extending Propositional Logic into Predicate Logic • Instead of propositions, Predicate Logic has predicates that take a predefined number (≥0) of arguments (parameters). • The arguments are terms intended to denote objects in some universe (not true/false statements). • Terms may contains symbols denoting variables, constants, and functions. • Formulas may include quantification over variables: “for all” x, “there exists” x. • Logical connectives of propositional logic are still available in predicate logic. Predicate Logic (First Order Logic) • Whereas propositional logic assumes world contains facts, first-order logic (like natural language) assumes the world contains • Objects: people, houses, numbers, theories, Ronald McDonald, colors, baseball games, wars, centuries, … • Relations: red, round, bogus, prime, multistoried, brother of, bigger than, inside, part of, has color, occurred after, owns, comes between, … • Functions: father of, best friend, third inning of, one more than, end of, … Predicate Logic Syntax: Terms • Terms are intended to denote objects, and terms are defined in BNF as follows: t ::= x | c | f(t, . . . , t) where x is a variable symbol, c is a constant (a function symbol with arity=0) and f is a function symbol with arity n > 0. Definition: Term • A variable symbol is a term. • A constant symbol (a nullary function symbol) is a term. • If t1,t2,…,tn are terms and f is a function symbol with arity n > 0, then f(t1,t2,…,tn ) is a term. • Nothing else is a term. Predicate Logic Syntax Terms - Examples • If x,y,z are variable symbols, a, b, c are constant symbols and f(with arity 1), g(with arity 2) are function symbols, then followings are tems. • x y z • a b c • f(a) f(x) f(f(x)) f(f(a)) f(f(f(a))) • g(a,b) g(x,y) g(a,z) g(f(a),g(b,y)) • But if P (with arity 1) is predicate symbol, the followings are NOT terms. • P(x) P(a) f(P(a)) Predicate Logic Syntax Sentences (Formulas) • A wff of predicate logic can be defined using following BNF rules. φ ::= P(t1, … , tn) | t1= t2 | Atomic Sentences (¬φ) | (φ ∧ φ) | (φ ∨ φ) | (φ ⇒ φ) | (φ ⇔ φ) | (∀xφ) | (∃xφ) where P is a predicate symbol of arity n ≥ 0, ti are terms and x is a variable symbol. Predicate Logic Syntax Sentences (Formulas): Examples • If P is a predicate symbol with arity 1, and Q is a predicate symbol with arity 2. – P(x) P(a) P(f(a)) P(f(x)) – Q(x,a) Q(x,y) Q(f(x),f(a)) – ∀xP(x) ∃xP(x) – ∀xQ(x,a) ∃xQ(b,x) ∀xQ(x,y) ∃xQ(y,x) – ∀x∀yQ(x,y) ∃x∃yQ(x,y) ∀x∃yQ(x,y) – ∀x(P(x) ⇒ ∃yQ(x,y)) Free and Bound Variables • Quantifiers bind variable occurrences within a sub-formula. • Occurrences of a variable are bound by the most recent quantifier of that variable within that sub- formula. • If the occurrence of a variable is not bound, it is said to be free. • The same variable symbol may be bound by different quantifiers, when it occurs in different sub- formulas • renaming them improves clarity. • A sentence (a closed formula) is a formula with no free variables. Examples • ∃xP(x,y) • ∃x(P(x,y) ˄ ∀yQ(x,y)) • ∃x(P(x,y) ˄ ∀xQ(x,y)) Semantics of Predicate Logic - Models • The meanings of constant, function and predicate symbols come from models. A model M consists of: • Each model identifies a universe U, a non-empty set of objects to which terms are intended to be mapped. • Each constant symbol c is mapped to an object cM in U. • Each function symbol f is mapped to a function fM from Un to U, where n is the arity of f. fM: Un → U • Each predicate symbol P is mapped to a n-ary relation PM ( a subset of n-tuples Un ) where n is the arity of P. Model - Examples • Let c be a constant symbol, f be a function symbol (with arity 1), P be a predicate symbol (with arity 2). • And, let M be a model as follows • The universe of M = {1,2,3} • cM = 1 • fM is the function {(1,2),(2,3),(3,1)} • PM is the relation{(1,1),(1,2)} • Term Meanings: • f(c) maps to fM(cM) = fM(1) = 2 • f(f(c)) maps to fM(fM(cM)) = fM(fM(1)) = fM(2) = 3 • Atomic Formula Meanings: • P(a,f(c)) maps to True since (1,2) ∈ PM • P(f(c),f(c)) maps to False since (2,2) ∉ PM Semantics of Predicate Logic Environments • Meanings of free variables come from environments (state or look-up table). • An environment is a function maps variables to objects of the universe of a model. • Examples: • {(x,1),(y,2),(z,1)} is an environment l. • a function from variables {x,y,z} to the universe of our model M (={1,2,3}) • l(x) is 1 since l maps x to 1 Semantics of Predicate Logic Satisfaction Relation • Truth values of formulas of predicate logic are evaluated wrt a model M and an environment l. • Truth values of closed formulas of predicate logic are evaluated wrt a model M. • Given a model M with the universe U and given an environment l, we define the satisfaction relation M⊨l φ for each logical formula φ by structural induction on φ. Satisfaction Relation: • If φ is of the form P(t1,… tn), then we map the terms t1,…,tn to the objects a1,…,an in set U by using the model M and the environment l. Now M ⊨l P(t1,… tn) holds iff (a1,…, an) is in the relation PM. • M ⊨l ∀xψ holds iff M ⊨l [x→a] ψ holds for all a ∈ U. • M ⊨l ∃xψ holds iff M ⊨l [x→a] ψ holds for some a ∈ U. • M ⊨l ¬ψ holds iff it is not the case that M ⊨l ψ holds. • M ⊨l ψ1 ∨ ψ2 holds iff M ⊨l ψ1 or M ⊨l ψ2 holds. • M ⊨l ψ1 ∧ ψ2 holds iff M ⊨l ψ1 and M ⊨l ψ2 hold. • M ⊨l ψ1 → ψ2 holds iff M ⊨l ψ2 holds whenever M ⊨l ψ1 holds. Satisfaction Relation - Example • Let M be a model as follows • The universe of M = {1,2} cM = 1 PM is the relation{(1,1),(1,2)} • Let e be an environment {x→1, y→2} • The following satisfaction relations hold or not? • M ⊨e P(x,y) • M ⊨e P(y,x) • M ⊨e P(x,c) • M ⊨e P(y,c) Satisfaction Relation - Example • Let M be a model as follows • The universe of M = {1,2} cM = 1 PM is the relation{(1,1),(1,2)} • Let e be an environment {x→1, y→2} • The following satisfaction relations hold or not? • M ⊨e P(x,y) YES (1,2)∈PM • M ⊨e P(y,x) NO (2,1)∉PM • M ⊨e P(x,c) YES (1,1)∈PM • M ⊨e P(y,c) NO (2,1)∉PM Satisfaction Relation - Example • Let M be a model as follows • The universe of M = {1,2} cM = 1 PM is the relation{(1,1),(1,2)} • Let e be an environment {x→1, y→2} • The following satisfaction relations hold or not? • M ⊨e ∀yP(x,y) • M ⊨e ∀xP(x,y) • M ⊨ ∀x∀yP(x,y) • M ⊨ ∀xyP(x,y) • M ⊨ x∀yP(x,y) Satisfaction Relation - Example • Let M be a model as follows • The universe of M = {1,2} cM = 1 PM is the relation{(1,1),(1,2)} • Let e be an environment {x→1, y→2} • The following satisfaction relations hold or not? • M ⊨e ∀yP(x,y) YES (1,1) and (1,2) ∈ PM • M ⊨e ∀xP(x,y) NO (2,2)∉PM • M ⊨ ∀x∀yP(x,y) NO (2,1) and (2,2) ∉ PM • M ⊨ ∀xyP(x,y) NO (2,1) or (2,2) ∉ PM • M ⊨ x∀yP(x,y) YES (1,1) and (1,2) ∈ PM Reasoning Over All Models • Validity: φ is valid if M ⊨l φ for all M, l. • Unsatisfiable: φ is unsatisfiable if M ⊭l φ for all M, l. • Satisfiability: φ is satisfiable if there exists M, l such that M ⊨l φ. • Entailment: ψ ⊨ φ if M ⊨l φ whenever M ⊨l ψ holds for every M, l. Reasoning Over All Models - Examples • Decide the following formulas are valid, satisfiable (but not valid) or unsatisfiable. • ∀x(P(x)→P(x)) • ∀x(P(x)∨Q(x)) • ∀x(P(x)) ∧ y(!P(y)) • Decide whether following logical consequence relations hold or not. • ∀x(P(x))∧∀y(Q(y)) ⊨ ∀x(P(x)∧Q(x)) • ∀x(P(x)∨Q(x)) ⊨ ∀x(P(x))∨∀y(Q(y)) Reasoning Over All Models - Examples • Decide the following formulas are valid, satisfiable (but not valid) or unsatisfiable. • ∀x(P(x)→P(x)) Valid • ∀x(P(x)∨Q(x)) Satisfiable • ∀x(P(x)) ∧ y(!P(y)) Unsatisfiable • Decide whether following logical consequence relations hold or not. • ∀x(P(x))∧∀y(Q(y)) ⊨ ∀x(P(x)∧Q(x)) Holds • ∀x(P(x)∨Q(x)) ⊨ ∀x(P(x))∨∀y(Q(y)) Does NOT hold Fun with Sentences: Quantifiers • Everybody loves somebody ∀x ∃y Loves(x, y) • There is someone who is loved by everyone ∃y ∀x Loves(x, y) • Quantifier duality: each can be expressed using the other ∀x Likes(x, IceCream) is equivalent to ¬∃x ¬Likes(x, IceCream) ∃x Likes(x, Broccoli) is equivalent to ¬∀x ¬Likes(x, Broccoli) ¬∀x Likes(x, IceCream) is equivalent to ∃x ¬Likes(x, IceCream) ¬∃x Likes(x, Broccoli) is equivalent to ∀x ¬Likes(x, Broccoli) • One's mother is one's female parent ∀m∀c Mother(m,c) ⇔ Female(m) ∧ Parent(m, c) Interacting with FOL KBs Inference in Predicate Logic Proofs Proofs • How can we produce a proof for query Evil(x) from the following KB? ∀x King(x) ∧ Greedy(x) ⇒ Evil(x) King(John) Greedy(John) • Substitution {x/John} solves the query Evil(x) • To use the rule that greedy kings are evil, find some x such that x is a king and x is greedy, and then infer that this x is evil. • More generally, if there is some substitution θ that makes each of the conjuncts of the premise of the implication identical to sentences already in the knowledge base, then we can assert the conclusion of the implication, after applying θ. Proofs • We will assume that our KB • contains only definite clauses (exactly one positive literal) and • all variables are universally quantified. • We will use a single inference rule called as Generalized Modus Ponens (A Variation of Resolution Rule for Horn Clauses) in our proofs. Generalized Modus Ponens • Generalized Modus Ponens (GMP) Inference Rule: • There are n+1 premises to this GMP rule: the n atomic sentences pi’ and the one implication. • The conclusion is the result of applying the substitution θ to the consequent q. Generalized Modus Ponens • A proof for query Evil(x) from the following KB using GMP? ∀x King(x) ∧ Greedy(x) ⇒ Evil(x) King(John) Greedy(John) Unification • Finding substitutions that make different logical expressions look identical is called unification. • The UNIFY algorithm takes two sentences and returns a unifier for them if one exists: UNIFY(p, q)=θ where SUBST(θ, p)=SUBST(θ, q) Unification Unification AlgorithmForward Chaining Algorithm • On each iteration, it adds all the atomic sentences that can be inferred in one step from the implication sentences and the atomic sentences already in KB. • STANDARDIZE-VARIABLES replaces all variables with new ones that have not been used before. Generalized Modus Ponens: Example Knowledge Base: The law says that it is a crime for an American to sell weapons to hostile nations. The country Nono, an enemy of America, has some missiles, and all of its missiles were sold to it by Colonel West, who is American. Prove that Col. West is a criminal. Generalized Modus Ponens: ExampleForward Chaining ProofForward Chaining ProofForward Chaining ProofBackward Chaining AlgorithmBackward Chaining Algorithm: ExampleBackward Chaining Algorithm: ExampleBackward Chaining Algorithm: ExampleBackward Chaining Algorithm: ExampleBackward Chaining Algorithm: ExampleBackward Chaining Algorithm: ExampleBackward Chaining Algorithm: ExampleFOL Resolution: Brief SummaryConversion to CNFConversion to CNFResolution Proof: Definite Clauses","libVersion":"0.2.3","langs":""}