{"path":"UNISA/98906 - BSc Science in Computing/COS3721 - Operating Systems and Architecture/Unsorted/COS 3721/Exams/2018-October/Ap/downstudocu.com_2018-oct-nov-memo.pdf","text":"This paper consists of 5 pages. Instructions: 1. Answer all the five (5) questions in your answer book. 2. All rough work must be done in your answer book. 3. Please answer the questions in order. If you want to do a question later, leave a blank space. 4. The string (Silberschatz, Galvin & Gagne) refers to the prescribed book, namely,SGG Operating Systems Concepts, 9 edition for this module. th Good luck! [TURN OVER] Page of 2 10 COS3721 October/November 2018 Question 1 : 14 Marks 1.1 Describe some of the challenges of designing operating systems for mobile devices compared with designing operating systems for traditional PCs. [4] Answer: The greatest challenges in designing mobile operating systems include: Less storage capacity means the operating system must manage memory carefully.  The operating system must also manage power consumption carefully.  Less processing power plus fewer processors mean the operating system must carefully apportion processors to applications. 1.2 Explain why Java programs running Android systems do not use the standard Java API and virtual machine. [2] Answer: It is because the standard API and virtual machine are designed for desktop and server systems, not mobile devices. Google developed a separate API and virtual machine for mobile devices. 1.3 A multithreaded web server wishes to keep track of the number of requests it services (known as hits.) Consider the following two strategies to prevent a race condition on the variable hits. The first strategy is to use a basic mutex lock when updating hits: int hits; mutex_lock hit_lock; hit_lock.acquire(); hits++; hit_lock.release(); A second strategy is to use an atomic integer: Atomic_t hits; Atomic_inc(&hits); Explain which of these two strategies is more efficient. [4] Answer: The use of locks is overkill in this situation. Locking generally requires a system call and possibly putting a process to sleep (and thus requiring a context switch) if the lock is unavailable. (Awakening the process will similarly require another subsequent context switch.) On the other hand, the atomic integer provides an atomic update of the hits variable and ensures no race condition on hits. This can be accomplished with no kernel intervention and therefore the second approach is more efficient. [TURN OVER] Page of 3 10 COS3721 October/November 2018 1.4 Which of the following scheduling algorithms could result in starvation? Explain. [4] (a) Shortest Job First (b) Round-Robin Answer: (A) The SJF result in starvation when shortest jobs keep on joining the ready queue which could already contains a process with highest burst time. (B) RR result in starvation since each process ready for execution has equal chances to becould not executed based on the time quantum. Question 2: 24 Marks 2.1 Consider the following code segment: Pid_t pid; pid = fork( ); if ( pid = = 0 ) { / * child process * / fork ( ); thread_create ( . . . ); } Fork ( ); (A) How many unique processes are created? [2] Answer: There are six processes. (B) How many unique threads are created? [2] Answer: There are two threads. 2.2 Consider a system consisting of four resources of the same type that are shared by three processes, each of which needs at most two resources. Is this system deadlock free? Show the full workings. [4] Answer: Suppose the system is deadlocked. This implies that each process is holding one resource and is waiting for one more. Since there are three processes and four resources, one process must be able to obtain two resources. This process requires no more resources and, therefore it will return its resources when done. 2.3 Discuss how the following pairs of scheduling criteria conflict in certain settings. [6] [TURN OVER] Page of 4 10 COS3721 October/November 2018 (a) CPU utilization and response time (2) (b) Average turnaround time and maximum waiting time (2) (c) I/O device utilization and CPU utilization (2) Answer: a. : CPU utilization is increased if the overheads associated withCPU utilization and response time context switching is minimized. The context switching overheads could be lowered by performing context switches infrequently. This could, however, result in increasing the response time for processes. b. Average turnaround time and maximum waiting time: Average turnaround time is minimized by executing the shortest tasks first. Such a scheduling policy could, however, starve long-running tasks and thereby increase their waiting time. c. : CPU utilization is maximized by running long-runningI/O device utilization and CPU utilization CPU-bound tasks without performing context switches. I/O device utilization is maximized by scheduling I/O-bound jobs as soon as they become ready to run, thereby incurring the overheads of context switches. 2.4 The following processes are being scheduled using a preemptive, round-robin scheduling algorithm. Each process is assigned a numerical priority, with a higher number indicating a lower relative priority. In addition to the processes listed below, the system also has an idle task (which consumes no CPU resources and is identified as Pidle). This task has priority 0 and is scheduled whenever the system has no other available processes to run. The length of a time quantum is 10 units. If a process is pre-empted by a higher-priority process, the pre-empted process is placed at the end of the queue. Process Priority Burst time Arrival P1 40 20 0 P2 30 25 25 P3 30 25 30 P4 35 15 60 P5 5 10 100 P6 10 10 105 (A) Show the scheduling order of the processes using a Gantt chart. [4] Answer: pre-emption is performed at the time a higher prioritized process becomes ready for execution. P1 P1 idle P2 P3 P2 P3 P2 P3 P4 P4 idle P5 P6 0 10 20 25 35 45 55 60 65 70 75 85 90 100 110 120 [TURN OVER] Page of 5 10 COS3721 October/November 2018 Note: The concepts of Turnaround time and waiting time are explained in SGG, 8 edition, on page th 187. Practical formulae, generated from the explanation given in the textbook were included in the tutorial letter 102 available for download on the myUnisa website. Those formulas are: TTTTTurnaround timeurnaround timeurnaround timeurnaround timeurnaround time = = = = = Time of completion - Time of submissionTime of completion - Time of submissionTime of completion - Time of submissionTime of completion - Time of submissionTime of completion - Time of submission ∑ Waiting time = Turnaround time − ∑ CPU burst time Applying these formulae yields the following results, presented in a tabular form: (B) Calculate the turnaround time and the waiting time for each process. [4] Answer: Process Turnaround time P1 (20 – 0) = 20 P2 (70 – 25) = 45 P3 (75 – 30) = 45 P4 (90 – 60) = 30 P5 (110 – 100) = 10 P6 (120 – 105) =15 (c) What is the CPU utilization rate? [2] Answer: We first calculate the total time units during which the CPU was active which is the total time minus the time spent on idle process.Time spent on idle process: 5 +10 = 15 and  Time of activity: 120-15 = 105 CPU utilization rate = 105/120 which results in 87.5% Question 3: 10 Marks [TURN OVER] Page of 6 10 COS3721 October/November 2018 3.1 When a page fault occurs, the process requesting the page must block while waiting for the page to be brought from disk into physical memory. Assume that there exists a process with five user- level threads and that the mapping of user threads to kernel threads is one to one. If one user thread incurs a page fault while accessing its stack, would the other user threads belonging to the same process also be affected by the page fault that is, would they also have to wait for the faulting page to be brought into memory? Explain. [4] Answer: No because each user thread is mapped to a separate kernel thread and such, a blocking call by a user thread may not necessary affect other threads. 3.2 Explain what has to happen for a set of processes to achieve a deadlock state. [2] Answer: The necessary conditions for a set of processes to get into a deadlocked state are well explained in the prescribed textbook see SGG 9 edition, Section 7.21 (Necessary conditions) on pages 314 and 315. th The conditions must hold simultaneously: Mutual exclusion, Hold and wait, No preemption, Circular wait. 3.3 Consider a file system in which a file can be deleted and its disk space reclaimed while links to that file still exist. (A) What problems may occur if a new file is created in the same storage area or with the same absolute path name? [2] Answer: Let F1 be the old file and F2 be the new file. A user wishing to access F1 through an existing link will actually access F2. Note that the access protection for file F1 is used rather than the one associated with F2 (B) How can these problems be avoided? [2] Answer: This problem can be avoided by insuring that all links to a deleted file are deleted also. This can be accomplished in several ways: a. maintain a list of all links to a file, removing each of them when the file is deleted b. retain the links, removing them when an attempt is made to access a deleted file c. maintain a file reference list (or counter), deleting the file only after all links or references to that file have been deleted [TURN OVER] Page of 7 10 COS3721 October/November 2018 Question 4: 12 Marks Consider the following snapshot of a system in a safe mode: Allocation Max Need Availab le A B C D A B C D A B C D A B C D P0 3 0 1 4 5 1 1 7 2 1 0 3 5 2 2 3 P1 2 2 1 0 3 2 1 1 1 0 0 1 P2 3 1 2 1 3 3 2 1 0 2 0 0 P3 2 2 1 0 4 6 1 2 2 4 0 2 Table 1 4.1 Calculate the contents of the array Need vector. [2] Answer: Allocation Max Need Availab le A B C D A B C D A B C D A B C D P0 3 0 1 4 5 1 1 7 2 1 0 3 5 2 2 3 P1 2 2 1 0 3 2 1 1 1 0 0 1 P2 3 1 2 1 3 3 2 1 0 2 0 0 P3 2 2 1 0 4 6 1 2 2 4 0 2 4.2 Clearly explain the three-steps of the Resource-Request Algorithm. [2] Answer: (a) Ensure that the requested resources are not greater than those needed (b) Ensure that the requested resources are not greater than those available (c) Allocate the requested resources and verify if the system is a safe state 4.3 Can a request for (0, 2, 0, 1) by P3 be safely granted? Show all you’re working. [8] Answer: (a) Is (0, 2, 0, 1) <= (2, 4, 0, 2) Yes (b) Is (0, 2, 0, 1) <= (5, 2, 2, 3) Yes (c) We now allocate the requested resources to P3 and check if the system is a safe state. Assume (0, 2, 0, 1) are allocated to P3 then,  The new system state: Allocation Max Need Availab [END] Page of 8 10 COS3721 October/November 2018 le A B C D A B C D A B C D A B C D P0 3 0 1 4 5 1 1 7 2 1 0 3 5 0 2 2 P1 2 2 1 0 3 2 1 1 1 0 0 1 P2 3 1 2 1 3 3 2 1 0 2 0 0 P3 2 4 1 1 4 6 1 2 2 2 0 1  Apply resource allocation algorithm to the new system Step 1: Work = (5, 0, 2, 2): resource available. Finish = (f, f, f, f): none of the processes is completed. Step 2: We search the array need for the process that needs less resources than those available. Only process P1 needs less resources than those available and can therefore be completed. Work = Work + (2, 2, 1, 0) = (5, 0, 2, 2) + (2, 2, 1, 0) = (7, 2, 3, 2) Finish = (f, t, f, f, f) Step 3: P2 needs less resources than those available and can therefore be completed. Work = Work + (3, 1, 2, 1) = (7, 2, 3, 2) + (3, 1, 2, 1) = (10, 3, 5, 3) Finish = (f, t, t, f, ) Step 4: P0 as well as P3 needs less resources than those available and can therefore be completed. Conclusion: the requested resources can be safely allocated to P3. Question 5: 10 Marks [TURN OVER] Page of 9 10 COS3721 October/November 2018 Consider the following sequence of memory references in a 460-word program: 100, 35, 195, 140, 75, 10, 40, 220, 5, 88, 145, 149, 24, 65 5.1 Draw up the table which addresses to the page numbers, given a page size maps the memory of . Number both the 50 words page numbers memory addresses as well as the starting from zero 0 (i.e. ). [3] Answer: Memory address Page reference 0 – 49 0 50 – 99 1 100 – 149 2 150 – 199 3 200 – 249 4 5.2 Use your table in 5.1 and calculate the reduced page reference string, given a page size of 50 words. Show full workings. [2] Answer: 100 35 195 140 75 10 40 220 5 88 145 149 24 65 2 0 3 2 1 0 0 4 0 1 2 2 0 1 2 0 3 2 1 0 4 0 1 2 0 1 The reduce string: 2 0 3 2 1 0 4 0 1 2 0 1 5.3 Calculate the page fault rate for the reduced reference string in 5.2 for the optimal replacement algorithm. Assume that there are three (3) frames of primary memory allocated to the program. [5] [TURN OVER] Page of 10 10 COS3721 October/November 2018 Answer: 2 0 3 2 1 0 4 0 1 2 0 1 Fault Yes Yes Yes No Yes No Yes No No Yes No No Frame 1 2 2 2 2 4 2 Frame 2 - 0 0 0 0 0 Frame 3 - - 3 1 1 1 Page fault rate = 6/12 Total of marks = 70 First examiner Dr C Dongmo Second examiner Mr A Lazarus External moderator Ms A De Villiers © UNISA 2018 [END]","libVersion":"0.2.3","langs":""}