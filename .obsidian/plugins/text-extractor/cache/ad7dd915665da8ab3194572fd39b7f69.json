{"path":"UNISA/98906 - BSc Science in Computing/COS3721 - Operating Systems and Architecture/Unsorted/COS3721/Exam pack (2)/materials/Stuvia-862626-detailed-cos3721-summary.pdf","text":"DETAILED COS3721 Summary written by francoissmit www.stuvia.com Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Detailed COS3721 Summary Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: This document contains detailed explanations on each section followed by worked out exam questions. Banker’s algorithm Know how to explain the steps of these two algorithms: Explanation: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 1. Create Work and Finish vectors. Initialize all Finish entries to false and Work to Available. The Finish table represents processes that have finished executed. 2. Search for processes that needs fewer resources than those available. (i.e. Need <=Work). If there is no such process, go to step 4, else go to step 3. 3. For each process found in step 2 update the Work by adding current Work to the process’ Allocation. Set Finish entry of the process to true. Go to step 2. 4. If the whole Finish vector has true entries then system is in a safe state. Explanation 1. Check if request is smaller or equal than the Need vector of the specified process (say process i). If it is go to step 2, otherwise the request cannot be granted immediately. 2. Check if request is smaller or equal than the Available vector of the process i. If it is go to step 3, otherwise the request cannot be granted immediately. Think: I need you to be available 3. Then have the system pretend to have allocated the requested resources to process i by modifying the following of this process: -Update Available by subtracting it with request -Update Allocation by adding the request to it -Update the Need by subtracting request from it THINK AAN -+- Then use this resulting resource-allocation state with the banker’s algorithm to check if it is in a safe state. If it is, then the resources can be granted immediately. If it isn’t then resources can’t be granted immediately. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Exams 2019-06 Question 3.1) Need = Max – Allocation Need A B C D P0 2 2 1 1 P1 2 1 3 1 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace P2 0 2 1 3 P3 0 1 1 2 P4 2 2 3 3 3.2) Work = Available = (3,3,2,1) Finish = (0,0,0,0,0) Search for processes that needs fewer resources than those available. (i.e. Need <=Work) P0: Can execute since Need <= Available. Assume it completed its execution: Finish = (1,0,0,0,0). Work = Allocation(P0) + work (previous work) = 2 0 0 1 + 3 3 2 1 Work = 5 3 2 2 P1: Cannot execute since Need(P1) <= Work is false P2: Cannot execute since Need(P2) <= Work is false P3: Can execute since Need(P3) <= Work. Assume it completed its execution: Finish = (1, 0, 0, 1, 0) Work 6 6 3 4 <- Previous Work + Allocation(P3) P4: Can execute since Need(P4) <= Work. Assume it completed its execution: Finish = (1, 0, 0, 1, 1) Need A B C D P0 2 2 1 1 P1 2 1 3 1 P2 0 2 1 3 P3 0 1 1 2 P4 2 2 3 3 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Work 7 10 6 6 <- Previous Work + Allocation(P4) Now we start from the top again seeing if the other processes can execute: P1: Can execute since Need <= Work. Assume it completed its execution: Finish= (1, 1, 0, 1, 1) Work 10 11 8 7 P2: Can execute occur since Need <= Work. Assume it completed its execution: Finish = (1, 1, 1, 1, 1) Work 12 12 8 10 System is in a safe state since everything in Finish is T. The safe sequence: <P0, P3, P4, P1, P2> 3.3) Check request <= P4’s Need. (0,0,2,0) <= (2,2,3,3) is true. Next we check that request <= Available (0,0,2,0) <= (3,3,2,1) is true. If these are not true then request cannot be granter immediately. When these 2 tests past we pretend request has been fulfilled which will result in the following state.( Thus REQUEST + ALLOCATION & NEED – REQUEST of P4 (next 1 that hasn’t have AVAILABLE). AND you go AVAILABLE – REQUEST.) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Now determine if this system state is in safe state: P0: Available = Work = (3, 3, 0, 1) Cannot execute since Need <= Work is false (i.e. 2 2 1 1 <= 3 3 0 1 is false) P1: Cannot execute since Need <= Work is false (i.e. 2 2 1 1 <= 3 3 0 1 is false) P2: Cannot execute since Need <= Work is false (i.e. 0 2 1 3 <= 3 3 0 1 is false) Both P3 and P4 Cannot execute since Need <= Work because C’s work value is 0 and it is less than both P3’s and P4’s Need C values. Resources can’t be granted immediately, since system is not in a safe state. P4 will have to wait. 2018-10 Question: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 4.1) Need = Max – Allocation 4.2) 1. Check if request is smaller or equal than the Need vector of the specified process (say process i). If it is go to step 2, otherwise the request cannot be granted immediately. 2. Check if request is smaller or equal than the Available vector of the process i. If it is go to step 3, otherwise the request cannot be granted immediately. 3. Then have the system pretend to have allocated the requested resources to process i by modifying the following of this process: i. -Update Available by subtracting it with request ii. -Update Allocation by adding the request to it iii. -Update the Need by subtracting request from it THINK AAN -+- Then use this resulting resource-allocation state with the banker’s algorithm to check if it is in a safe state. If it is, then the resources can be granted immediately. If it isn’t then resources can’t be granted immediately. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 4.3) Request <= Need(P3) is true. i.e. (0, 2, 0, 1) <= (2, 4, 0, 2) is true Request <= Available is true, i.e. (0, 2, 0, 1) <= (5, 2, 2, 3) is true. Pretend to have the allocated the request resource to process P3. Thus the resulting resource allocation state would be as follows: Now apply Banker’s algorithm to see if this system is in a safe state. Work = Available = (5, 0, 2, 1) Finish= (0, 0, 0, 0, 0) Search for processes that needs fewer resources than those available. (i.e. Need <=Work) P0: Cannot execute since Need <= work is false, i.e. (2, 1, 0 ,3) <= (5, 0 ,2, 1) is false P1: Can execute since Need <= work Work = Work + Allocation = (5,0,2,1) + (2,2,1,0) = (7,2,3,1) P2: Can execute since Need <= work Work = (10, 3, 5, 2) P3: Cannot execute since Need <= work is false. Now we start from the top again seeing if the other processes can execute: P0: Cannot execute since Need <= work is false. P3: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Cannot execute since we have not added to the work, thus Need <= work will still be false. Thus, we will never reach a safe state which means that the resource won’t be able to be allocated immediately. P3 needs to wait for the request. 2018-06 Question: 5.1) Need = Max - Allocation 5.2) Work = Available = (5,2,2,3) Finish= (0,0,0,0) Search for processes that needs fewer resources than those available: P0: Can execute since Need<=Work, i.e. (2,1,0,3) <= (5,2,2,3) Work = Work + Allocation = (5,2,2,3) + (3,0,1,4) = (8,2,3,7) Finish= (1,0,0,0) P1: Can execute since Need<=Work Need A B C D P0 2 1 0 3 P1 1 0 0 1 P2 0 2 0 0 P3 4 1 0 2 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Work = (8,2,3,7) + (2,2,1,0) = (10, 4, 4, 7) Finish = (1,1,0,0) Both P2 and P3 will execute since their Need <= to the work. Thus Finish = (1,1,1,1). System will be in a safe state. Safe sequence: <P0, P1, P2, P3> 5.3) Request <= Need(P0) is true, i.e. (1,0,0,1) <=(2,1,0,3) Request <= Available is true, i.e. (1,0,0,1) <= (5,2,2,3) Then have the system pretend to have allocated the requested resources to process P0 which should result in the following state: Subtract request from Available & Need. Add request to Allocation Now apply Banker’s algorithm on this state to see if the system is in a safe state: Search for processes that needs fewer resources than those available: Work = Available = (4,2,2,2) Finish = (0,0,0,0) P0: Can execute since Need <= Work Need A B C D P0 0 1 0 2 P1 1 0 0 1 P2 0 2 0 0 P3 4 1 0 2 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Work = Allocation + Work = (8, 2, 3, 7) Finish = (1,0,0,0) P1: Can execute since Need <= Work Work = Allocation + Work = (10, 4, 4, 7) Finish = (1,1,0,0) It is clear to see that both P2 and P3 will execute since their Need will be smaller or equal to the work. Thus Finish =(1,1,1,1) Thus the system is in a safe state, thus the request can be granted immediately. 2017-10 4.1) Need = Max – Allocation Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Work = Available = (3, 3, 2, 1) Finish = (0,0,0,0,0) Search for processes that needs fewer resources than those available: P0: Can execute, since Need <= Work Work = Work + Allocation = (5, 3, 2, 2) Finish = (1, 0, 0, 0, 0) P1: Cannot execute since Need <= Work is false, i.e. (2,1,3,1) <= (5,3,2,2) is false P2: Cannot execute since Need <= Work is false P3: Can execute, since Need <= Work Work = (6, 6, 3, 4) Finish = (1,0,0,1,0) P4: Can execute, since Need <= Work Need A B C D P0 2 2 1 1 P1 2 1 3 1 P2 0 2 1 3 P3 0 1 1 2 P4 2 2 3 3 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Work = (7, 10, 6, 6) Finish = (1,0,0,1,1) Now looping through the processes again to see which processes needs fewer resources than those available: Both P1 and P2 will both execute since both their Needs will be less than work (less than (7, 10, 6, 6) Finish (1,1,1,1,1) The system will be in a safe state. Safe sequence: <P0, P3, P5, P1, P2> 4.2) Request <= Need(P4) is true, i.e (0,0,2,0) <= (2,2,3,3) Request <= Available is true. Then have the system pretend to have allocated the requested resources to process P4 which should result in the following state: Now use the banker’s algorithm to see if this state is safe. Search for processes that needs fewer resources than those available: Work = Available = (3,3,0,1) Finish = (0,0,0,0,0) It is clear to see that none of the processes will need fewer resources than those avaialable, because all Processes Needs of resource C is bigger than Available’s resource C. Thus the system won’t be in a safe state. Thus the resources can’t be granted immediately. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 2017-06: * 4.1) Need = Max – Allocation 4.2) Search for processes that needs fewer resources than those available: Work = Available = (5,2,2,3) Finish = (0,0,0,0) P0: Need A B C D P0 2 1 0 3 P1 1 0 0 1 P2 0 2 0 0 P3 2 4 0 2 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Can execute since Need <= Work Work = Work + Allocation = (8,2,3,7) Finish = (1,0,0,0) P1: Can execute since Need <= Work Work = Work + Allocation = (10,4,4,7) Finish = (1,1,0,0) It is clear to see that both P2 and P3 will executes since both their Need is smaller or equal to the work (10,4,4,7). Finish = (1,1,1,1) The system will be in a safe state. Safe sequence: <P0, P1, P2,P3> 4.3) 1. Check if request is smaller or equal than the Need vector of the specified process (say process i). If it is go to step 2, otherwise the request cannot be granted immediately. 2. Check if request is smaller or equal than the Available vector of the process i. If it is go to step 3, otherwise the request cannot be granted immediately. Think: I need you to be available 3. Then have the system pretend to have allocated the requested resources to process i by modifying the following of this process: -Update Available by subtracting it with request -Update Allocation by adding the request to it -Update the Need by subtracting request from it THINK AAN -+- Then use this resulting resource-allocation state with the banker’s algorithm to check if it is in a safe state. If it is, then the resources can be granted immediately. If it isn’t then resources can’t be granted immediately. 4.4) Request <= Need(P3), i.e. (0,2,0,1) <=(2,4,0,2) Request <= Available is true Then have the system pretend to have allocated the requested resources to process P3 which should result in the following state: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Now use the banker’s algorithm to see if this state is safe. Search for processes that needs fewer resources than those available: Work = Available = (5,0,2,2) Finish = (0,0,0,0) P0: Cannot execute, since Need <= Work is false P1: Can execute since Need <= Work Work = Work + Allocation = (7,2,3,2) Finish = (0,1,0,0) P2: Can execute since Need <= Work Work = Work + Allocation = (10,3,5,3) Finish = (0,1,1,0) P3: Cannot execute, since Need <= Work is false Now we go through the processes again to search for processes that needs fewer resources than those available: P1: Can execute since Need <= Work Work = Work + Allocation = (13,3,6,7) Finish = (0,1,1,0) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace P3: Cannot execute, since Need <= Work is false Thus we cannot reach a safe state, thus the resources can’t be granted immediately. 2016-10: This question is not in this exam. 2016-06: Question is the same as 2017-06 CPU scheduling Algorithm: FCFS (First come first serve): Have no preemtion and never consider priority SJF (shortest job first): Can be preemtive or non-preemtive and if process have the same shortest burst time then we consider their priority. Is not preempted by lower priority, only with processes that have shortest burst. Round robin can be preemptive and non preemtive and proccesses is preemted by higher priority. With priority algorithm you lok for lower priority. IF they have the same you look for process that haas lower process number. Algorithms: Note: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace In questions they would say If a process is pre-empted by a higher priority, the pre-emted process is placed at the end of the queue. This means we have to replace a process (pre-empt it) if the process have a lower priority. It sort of becomes like SJF where you select the shortest job 1st, but here you just go according to priority. SJF with preemption:  Start running 1st process that arrived.  When new process arrives stop and update the process that just ran’s burst time (i.e. subtract for how long it executed).  Then check which process of all the processes that have arrived have the least burst time and run that process. Round Robin Algorithm with Pre-emption:  Make Ready Queue (RQ). First process (most to the left) in RQ will be sent to the CPU.  Start executing Process that arrives 1st for Time Quantum(TQ) amount of time.  Whilst a process is executing check if other processes have arrived. Whenever process arrives, put it in RQ. When arrival and process finish execution at same time we put arrival 1st. When all processes have arrived we can just work with RQ and not worry about arrivals.  When process is done with execution, put it back in RQ.  Now execute process 1st in RQ( i.e. the most left process) for TQ amount of time.  Remember to update burst times each time you run the a process. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Burst time is process execution duration. How long it takes to execute. Preemptive vs Non preemtive: Non-preemptive: A process that started executing (given to the CPU) must finish before we can assign another process to CPU. Preemptive: CPU can be assigned to another process even though current executing process is not finished yet. What happens is process arrives and then it must wait (not always) to be execute, then it executes. Thus Turnaround time is total time it takes until it is finished with execution, i.e. time completed – arrival time. Obviously waiting time (how long it waited) is Total time(turnaround time) – CPU execution time (burst) CPU utilization: CPU utilization rate = [ (Total Time – idle Time) / Total Time] * 100 = [ (T120– 15) / 120] * 100 = 87.5% These times you simply read of the Gant chart. Exam type example: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: Higher priority value means higher priority. There is Pidle process. a) Option 1: Preemption happens at the end of time quantum. Priority Queue: <Pi> This queue will put processes from this queue to CPU. Higher priorities goes to the left. Left process is taken to CPU. Intitially only Pi (Pidle) is in it. P1 arrives and goes into PQ: <P1, Pi> Now it is taken to CPU to get executed: <Pi> Update burst of P1: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Now it is done. Put it back in PQ. Now other Process has arrived. PQ: <P1, Pi>. Note all other processes have higher priority than Pi, thus it goes to the left of Pi. Pi always on theright. Now put P1 back in execution: P1 is now completely finished and no other process has arrived. PQ: <Pi> Thus we run Pidle for 5 seconds until process 2 arrives: PQ:<> Now after 25 seconds P2 arrives and we take Pi off. SO PQ: <P2, Pi>. So run P2: PQ:<Pi> Update P2’burst: So at 30 P3 arrives and P2 goes off CPU. They both have same priority, thus arrival go before taken off process in PQ. PQ: <P3, P2, Pi>. Now run P3: PQ: <P2, Pi> Update P3: Now take P3 off. Processes that has been taken off goes in PQ in the position according to it’s Priority. If processes have the same value then it goes to the right of that process. Thus PQ: <P2, P3, Pi> Note Pi always have lowest priority. Now run P2: PQ: <P3, Pi> Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Update P2: P2 goes back in PQ: PQ: <P3, P2, Pi> Run P3: PQ: <P2, Pi> Update P3: P4 arrived at 60, so put it in PQ, then also put P3. PQ: <P4, P2, P3, Pi> P4 have highest priority. Run next processin PQ, then PQ: <P2, P3, Pi> But after running for 10 seconds it is clear that P4 will be run again, because it will go left of PQ sincei it has highest priority. SO run P4 for 10 andthen for 5 seconds. Then P4 is done. P4 is now done. PQ: <P2, P3, Pi> Now doing the rest without explanation: Option 2: Premption occurs emmeditaly after higher priority process comes in. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Run P1 for 10 and then another 10. Then run Pi for 5 seconds. Then at 25 seconds P2 arrives. Then run P2 for 5 seconds then P3 arrives. P3 has same priority as P2, thus P2 is not preempted and P2 continues to run for another 5 seconds (i.e. for the complete 10 seconds). updated processes: PQ: <P3, P2, Pi>. Now we run P3 for 10, then run P2 for 10, then run P3 for 5. Now P4 arrives @ 60. updated: Note P2 is done. PQ: <P4, P2, P3, Pi> P4 has higher priority, thus it is to the left. Also P3 has run before this, thus P2 will have next turn, thus it is more to left than P3. Run P4 for 10 and then run it for 5, then run P2 for 5 and then run P3 for 5. Now P1-P4 are done. Now run idle until we get to process P5. Then run it for 5 until P6 arrives. Preempt P5 with P6 and run P6 for 10. Then run P5 again for 5. Note if a process is preempted then it will go to the end of the PQ. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Not going to do b, c and d. Theory question: SJF and Priority based algorithms could result in starvation. Example: Without pre-emptive, i.e. non-pre-emptive. FCFS (First Come First Serve) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace This is easy. Just show them in the order of 1st come 1st served. The bottom values are the accumulative burst times. SJF (Shortest Job First) Easy, just do the shortest burst time 1st, if equally short then do 1st process 1st. Priority Here we go according to Priority. Lower priority number go 1st, otherwise if they have the same priorities then go according to the 1st entered process. Round Robin (quantum = 1) The method is simple. Go from Process P1 to P5 with increments of quantum number. Repeat this, but if we have used up a process just leave it out. To do this it is good to keep a table where you keep track of the burst times. i.e. you subtract the amount of processing time you used a process (i.e. subtract the burst time) e.g. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace By used up we mean that it doesn’t have more burst times What happens is process arrives and then it must wait (not always) to be execute, then it executes. Thus Turnaround time is total time it takes until it is finished with execution, i.e. time completed – arrival time. Obviously waiting time (how long it waited) is Total time(turnaround time) – CPU execution time (burst) FCFS (First Come First Serve) See time completed is the accumulative time indicated at the bottom of the Gantt charts SJF (Shortest Job First) without pre-emption Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Priority without pre-emption Round Robin (quantum = 1) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note here that time completed for a process is the last occurrence, i.e. last occurrence of P3 ends at 7: Calculate average of waiting time for each table: Thus SJF results in the minimal average waiting time. SJF YT example: https://www.youtube.com/watch?v=6KBkAbHbark Note Arrival times are 0.0, 2.0, 4.0 and 5.0 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace SJF scheduling Non preemptive: Non preemptive, thus process must be done before we assign CPU to another process. So executing P1: Now since executing P1 all of the processes have arrives since all arrival time is < 7. Of the ones that have arrived, which is having the minimum burst time: P3 have min, thus compute next Both P2 and P4, thus execute 1st to arrive: Preemptive: remember we can swap processes now 1st we execute P1, but only until next process arrives. Then we stop and check. P2 arrives at time 2, thus we have executed P1 for 2 seconds. SO burst time remaining for P1 is 5. Burst time for P2 is 4. 4<5, thus we go with P2 since we doing SJF which is shortest job first. Keep track of the burst times by subtracting Algorithm: Run process, say Pm, then when new one arrives Pn stop and check which 1 have the shortest burst time, i.e. the remaining burst time of Pm or Pn. Then run that process. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Now after running P2 for 2 units P3 arrives. Remaining burst times: P1 = 5, P2 = 2 and burst time for P3 is 1. This run P3 since it is the least: Now after running P3 for 1 second it is done and P4 arrives. Thus all processes have arrived and are available to us. Remaining burst times: P1=5, P2=2 and burst time for P4 = 4. Thus P2 has the least burst time. Thus execute: P2 is done now. What we have left is P1=5, P4 = 4. Thus execute P4 first followed by then P5 for the times remaining: Note the preemptive will have a less average waiting time, thus it is better than non preemptive. Example: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note that SJF is a special case of the priority-scheduling. Thus WE can use priority with SJF. Without Pre-emption: Note that when priority are the same then it turns into SJF scheduling. So both P1 and P3 have the same priority, thus the Shortest Job First (SJF) says we do the one with the shortest burst. Thus P3 comes before P1. With Pre-emption: RR YT example: https://www.youtube.com/watch?v=-jFGYDfWkXI Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Given: Time Quantum = 3 Need to maintain a ready queue which will assist you. Ready Queue (RQ) = arrival time(AT) + Time Quantum(TQ) Process P1 will arrive so place it in RQ. Next thing in RQ will get executed. Execute next thing in RQ: Note it goes from RQ to CPU This is RQ This is CPU RB(remaining burst time) for P1 = 5 Now see which processes have arrived during this time. P3 have arrived during this time. Thus when P3 arrived put in in RQ: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace After P1 is done it will go from CPU to RQ: Now we take 1st thing in RQ and take it to CPU, so take P3 to CPU: RB for P3 = 4 Before taking P3 from CPU we check arrival. Always check arrival before taking process from CPU. Processes P2 arrived before P3 is done, so put it on RQ: Also, P4 arrived at the exact same time that P3 ended. SO which one we put 1st in RQ. WE put arrivals 1st before CPU exits. SO put P4 on RQ and then put P3: Now after arrivals we take next process on RQ and take it to CPU. So take P1 to CPU and execute for 3 time units: RB for P1 = 2 During this runtime P5 arrives so put in onto RQ: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Now put P1 in RQ from CPU, i.e. after execution of P1: See now every process has arrived, so we can now just work with RQ and not check for new arrivals. So next one in RQ is P2, so execute for 3 time units BUT burst time for P2 is only 2, thus we can only execute it for 2 time units: Since P2 is done we do not put it in RQ again. Now next process in RQ is P4, so execute it for 3 time units: Now P4 is done since it only have BT of 3. Thus we do not put it back in RQ again. Now execute P3 for 3 time units: RB for P3 =1 Now put P3 back on the RQ: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Load next process of RQ onto CPU: Continuing this algorithm yields: NON pre-emption, thus can’t swap process during process execution. Process must finish executing. Execute process a: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace During this time process b and c have arrived. Of them b have shortest burst time, thus execute: Processes that have arrived in the 9 seconds that haven’t been executed yet: c, d, e. OF them d have shortest burst time. Thus execute: Processes arrived that have not executed: c, e. Shortest is e: Following this process brings us to: Turnaround times and waiting times are: Remember TurnaroundTime = Completion – Arrival WaitingT = TurnaroundT - burst Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Compute a for 2 seconds then b will arrive. Burst remaining (BR) for a is 1 and burst for b is 6. 1 < 6, thus continue to process a and don’t swap: Processes that have arrived are b and c. b is shortest, thus compute b for 4 seconds then d will arrive. Now BR for b is 2. C burst is 10 and d’s burst is 1. Thus compute d: Now e have also arrived. So burst times of processes: b=2, c=10, e=5. Thus compute b until done because in the next 2 seconds no new process will arrive: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Burst times of arrived states: c=10, e=5. Thus compute e. WE can fully compute e, since next process will only arrive after it has completed: Now f arrives. Burst times: c=10, f=2. Thus compute f: Continuing this process leads to this: Turnaround times and waiting times for pre-emptive: Process a will arrive and get loaded into CPU for 5 time units (TU). IT has has burst of 3. Thus it will only run 3 TU: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace a is done now. Next b will get loaded and run for 5 TU: RBT(remaining burst time) b = 1 During this time c and d arrived. Next execute process that arrived 1st ,i.e. c for 5 TU: RBT c = 5 During this time e has arrived. Execute next process (by next we mean from top to bottom the top most one That have arrived and that has not yet in this round (by round we mean we 1st go through them all, i.e. a – g) ) Next process will be d for 5 TU, but since it only have 1 TU available due to burst execute it for 1 TU: d is done now. Don’t have to worry about it. Next available process will be e, thus process it for 5 TU: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace e is now done. During this time f has arrived, thus it will go at the back of the READY QUEUE (RQ). Look on YT example. SO then we start ROUND 2 and go from the TOP to the bottom again. Processes a, d and e are done so far. Next available process is b so process for 5 TU, but RBT of b = 1, so it can only be executed for 1 TU: : b is now done. Next available process is c, thus process it. RBT for c = 5 : c is now done. g arrived now, but f is before it on RQ, thus we execute f 1st: Execute f, for 5 TU, but it only have 2 burst time, thus execute for 2: Now g have arrived and it is the only 1 that is left. Thus we can process the whole thing, we don’t have to do it in increments of 5 TU: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Another thing you need to know is if they ask you to calculate the CPU utilization rate. Let’s us the above table: CPU utilization rate = Busy time/ Total Time * 100 Now Turnaround time is the total time the CPU spends either calculating or waiting. Burst time is the time it spends to calculate. So to calculate: CPU utilization rate = Total(burst) / Total(Turnaround Time) * 100 = 34 / 82 * 100 = 41.5 % Important example: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: P3 has higher priority than P2, thus it pre-empts. P4 has lower priority thus it does not pre-empt. Note at 65 seconds. Both P2 and P4 is in the queue and have same priority. But P2 was their 1st, so it gets executed 1st. If processes have the priority they alternate. i.e. P2 and P4 have same priority, thus they alternate. Exams: 2019-06 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: We only have theory here. 2018-10 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: We have theory here as well. SO would be good to study theory a bit. 2.4) a) Pre-emptive, RR, TQ = 10. Note they say if a process is pre-empted by a higher priority, the pre-emted process is placed at the end of the queue. Lower priority is higher priority. Option 1: pre-emption during time quantum: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Does a Process with the same priority pre-empt other priority. i.e. does P3 preempt P2 at 30 seconds. I don’t think so. b) Turnaround Time = Completion time – Arrival Time P1 P2 P3 P4 P5 P6 Waiting Time = Turnaround time – burst Time P1 P2 P3 P4 P5 P6 c) CPU utilization rate = [ (Total Time – idle Time) / Total Time] * 100 = [ (T120– 15) / 120] * 100 = 87.5% Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 2018-06 4.1) 1 st go according to priority and then shortest burst SJF without pre-empt. Smaller prio implies higher prio) Not correct Priority non-preemptive 4.2) SJF Turnaround Time P1 18-0=18 P2 P3 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace P4 P5 Waiting Time P1 -10 = 9 P2 -1=0 P3 -2=2 P4 -1=1 P5 -5=4 Priority: Turnaround Time P1 16 P2 1 P3 18 P4 19 P5 6 Waiting Time: P1 16-10=6 P2 1-1=0 P3 18-2=16 P4 19-1=18 P5 6-5=1 4.3) Sum Waiting time for SJF= 16 Sum of waiting time for Priority= 41 Thus SJF will result in the minimum waiting time since it has a lower sum of waiting time. 2017-10 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: Assuming smaller priority number is higher priority *1 st according to priority and then burst time 3.2.1) SJF with preemtion: Priority scheduling without preemtion: 3.2.2) SJF: Turnaround Time: Completion Time – Arrival Time P1 12-0=12 P2 5-1=4 P3 P4 Waiting Time: Turnaround Time – burst Time P1 12 – 8 = 9 P2 P3 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace P4 Priority: Turnaround Time P1 8 – 0 = 8 P2 12 – 1 = 11 P3 21 – 2 =19 P4 26 – 3 = 23 Waiting Time P1 8 – 8 =0 P2 11 – 4 = 7 P3 19 – 9 = 10 P4 23 – 5 = 18 Also theory 2.3) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace a) FCFS (pre-emption), assuming lower priority number pre-empts other process. So processes are pre-empted by higher priority (lower value). Start executing P2, while it is executing P1 and P4 arrives, but both have lower priority, thus P2 is not pre-empted. Now choice is between P1 and P4. Although P4 have arrived 1st, P1 has higher priority, thus run P1 for 1 seconds. Then P3 arrives having higher priority than P1, thus pre-empt P1 with P3. Then after P3 run P1 and then P4. RR (pre-emption) Assuming pre-emption is done after time quantum: b) FCFS: Turnaround Time: Completion Time – Arrival Time P1 10 – 4 = 6 P2 6 – 0 = 6 P3 9 – 7 = 2 P4 17 – 2 = 15 Waiting Time: Turnaround Time – burst Time P1 6 – 2 = 4 P2 6 – 6 = 0 P3 2 – 2 = 0 P4 15 – 7 = 8 RR: Turnaround Time P1 8 – 4 = 4 P2 6 – 0 = 6 P3 10 – 7 = 3 P4 17 – 2 = 15 Waiting Time Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace P1 4 – 2 = 2 P2 6 – 6 = 0 P3 3 – 2 = 1 P4 15 – 7 = 8 2016-10 2.1) a) FCFS with pre-emption Note, P3 arrives while P2 is executing, but since it doesn’t have higher priority it does not pre-empt P2. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Also, P4 arrives whilst P3 is executing, onec again P4 has lower priority, thus it does not pre-empt P3. Priority (non-pre-emption): Note: The same as FCFS RR(pre-emption), Assuming pre-emption happens after time quantum. Also take quantum to be 10: b) FCFS: Turnaround Time P1 20 – 0 = 20 P2 50 – 25 = 25 P3 75 – 30 = 45 P4 90 – 60 = 30 Waiting Time P1 20 – 20 = 0 P2 25 – 25 = 0 P3 45 – 25 = 20 P4 30 – 15 = 15 Priority: Same as FCFS Turnaround Time P1 20 – 0 = 20 P2 50 – 25 = 25 P3 75 – 30 = 45 P4 90 – 60 = 30 Waiting Time P1 20 – 20 = 0 P2 25 – 25 = 0 P3 45 – 25 = 20 P4 30 – 15 = 15 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace RR: Turnaround Time P1 20 – 0 = 20 P2 70 – 25 = 45 P3 75 – 30 = 45 P4 90 – 60 = 30 Waiting Time P1 20 – 20 = 0 P2 45 – 25 = 20 P3 45 – 25 = 20 P4 30 – 15 = 15 c) Average waiting time FCFS and Priority = (0+0+20+15)/4 = 8.75 Average waiting time RR = (0+20+20+15) / 4= 13.75 Thus, FCFS and Priority results in minimum average waiting time. 2016-06 No questions Page Replacement: Theory: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: When we are just given a page reference string then we do not have to reduce it 1st. We just work with the string. Implementation of this is at exam section. How to do the 3 types of replacement algorithms: LRU (Least recently used): Insertion at top each time, moving rest to bottom When hit occurs then hitted number go to top FIFO: Use star, replace value with star, move star to longest present value. Beginning insertion 1st row, then 2nd, then 3 rd. Optimal: Replace value which is furthest in future (To the right). Beginning insertion 1 st row, then 2nd, then 3rd. Both FIFO and Optimal have normal insertions at the 1 st 3 pages. Example: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Solution a) Page size of 50 words means each memory address will be increments of 50, we start at 0 which means that the upper limits will be 1 less than 50’s: For 380 word program it means we will have 8 pages since 380/50 = 7.6 round up is 8. Or via the table: Last page would result in internal fragmentation of 20 words( i.e. 40%) Maybe since program goes up to 380 words and in last page being 350-399(think of it as 400) 20 words will not get used. *Ask tutor Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Now we convert memory references to page references using the table: Memory reference: The page reference string will be: 0, 0, 2, 3, 1, 6, 3, 4, 4, 2, 6 e.g. the memory reference 10 would be in page 0. Reducing the string leads to( we collapsed consecutive, similar values into 1 value): 0, 2, 3, 1, 6, 3, 4, 2, 6 b) i) FIFO: First in first out 0 2 3 1 6 3 4 2 6 F1 0* 0* 0* 1 1 1* 2 F2 2 2 2* 6 6 6* F3 3 3 3* 4 4 Hits ^ ^ Faults= 9 – 2 = 7 Thus page fault rate = 7/9 *100 = 77.8% ii) LRU (Least recently used): 0 2 3 1 6 3 4 2 6 F1 0 2 3 1 6 3 4 2 6 F2 0 2 3 1 6 3 4 2 F3 0 2 3 1 6 3 4 Hits ^ Faults= 9 – 1= 8 Thus page fault rate = 8/9 *100 = 88.9% iii) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Optimal: We replace the page that will not be used for longest period of time. (look at future pages, i.e. to the right and see which one is furthest from where you are now and replace it) Look at this column’s entries and see which one of them is furthest in future (to the right). 1st we find a 3 in 3 columns after it and then there is a 2 in 5 columns after it. But no 0, thus 0 will get replaced. IF 0 was also last it would be replaced. Note: When you get to the 3(6th column) hit and you must then determine which one will get replaced then you must look after the hit column (i.e. the 7th column) to see which value is furthest in the future. 0 2 3 1 6 3 4 2 6 F1 0 0 0 1 6 6 F2 2 2 2 2 2 F3 3 3 3 4 Hits ^ ^ ^ Faults= 9 – 3= 6 Thus page fault rate = 6/9 *100 = 66.7% Exam Questions: 2019-06: Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 5.1) Memory addresses Page Number 0-49 0 50-99 1 100-149 2 150-199 3 200-249 4 250-299 5 300-349 6 350-399 7 400-449 8 450-499 9 Pages 5-9 will be empty. 5.2) Page reference string: 2, 0, 3, 2, 1, 0, 0, 4, 0, 1, 2, 2, 0, 1 Reduced page reference string: 2,0,3,2,1,0,4,0,1,2,0,1 5.3) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace LRU: Each insert goes at top and push other to bottom. Hit will cause the hitted value to go at top and shift the rest down. 2 0 3 2 1 0 4 0 1 2 0 1 Fault Y Y Y N Y Y Y N N Y N N F1 2 0 3 2 1 0 4 0 1 2 0 1 F2 2 0 3 2 1 0 4 0 1 2 0 F3 2 0 3 2 1 1 4 0 1 2 Hits: ^ ^ ^ ^ ^ Page Faults =7 Page Fault Rate = Faults/PageReferences = 7/12 *100 = 58% 2018-10 5.1) Memory addresses Page Number 0-49 0 50-99 1 100-149 2 150-199 3 200-249 4 250-299 5 300-349 6 350-399 7 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 400-449 8 450-499 9 5.2) Reference page: 2, 0, 3, 2, 1, 0, 0, 4, 0, 1, 2, 2, 0, 1 Reduced reference page: 2, 0, 3, 2, 1, 0, 4, 0, 1, 2, 0, 1 5.3) With optimal you look at future pages and replace the one that is furthest in the future. Insertion is made at next (bottom) frame 2 0 3 2 1 0 4 0 1 2 0 1 Fault Y Y Y N Y N Y N N Y N N F1 2 2 2 2 4 2 F2 0 0 0 0 0 F3 3 1 1 1 Page Faults 6 Page Fault rate = 6/12*100 = 50% 2018-06 Note: Do not reduce the string. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 3.1) LRU: Each insert goes at top and push other to bottom. Hit(non fault) will cause the value to go at top and shift the rest down. 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 Fault Y Y Y Y N Y Y Y Y Y N Y Y Y Y Y Y Y Y Y F1 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 F2 7 2 3 1 2 5 3 4 6 6 7 1 0 5 4 6 2 3 0 F3 7 2 3 1 2 5 3 4 4 6 7 1 0 5 4 6 2 3 Page Faults = 18 3.2) FIFO: When we need to replace we replace the one that has a star on it and then move star to value that has been present the longest. 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 f Y Y Y Y N Y N Y Y Y N Y Y Y Y Y Y Y Y Y F1 7* 7* 7* 1 1 1* 6 6 6* 0 0 0* 6 6 6* 0 0 F2 2 2 2* 5 5 5* 7 7 7* 5 5 5* 2 2 2* 1 F3 3 3 3* 4 4 4* 1 1 1* 4 4 4* 3 3 3* Page Faults = 17 3.3) Optimal: Replace latest future value (value most to the right) 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 Fault N N N N N N N F1 7 7 7 1 1 1 1 1 1 1 1 1 1 F2 2 2 2 5 5 5 5 5 4 6 2 3 F3 3 3 3 4 6 7 0 0 0 0 0 Page Faults = 13 2017-10 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Note: Here are theory as well, so we should learn a bit of theory. But for now just focus on algorithms. 2.4) 2.4.1) LRU: Insertion at top each time, moving rest to bottom. When hit occurs then hitted number go to top 2 1 7 5 1 7 0 2 6 Faults Y Y Y Y N N Y Y Y F1 2 1 7 5 1 7 0 2 6 F2 2 1 7 5 1 7 0 2 F3 2 1 7 5 1 7 0 Page Faults = 7 2.4.2) FIFO: Use star, replace value with star, move star to longest present value. Beginning insertion 1st row, then 2nd, then 3rd. 2 1 7 5 1 7 0 2 6 Faults N N F1 2* 2* 2* 5 5 5* 6 F2 1 1 1* 0 0 0* F3 7 7 7* 2 2 Page Faults = 7 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 2.4.3) Optimal: Replace value with furthest in future (To the right). Beginning insertion 1st row, then 2nd, then 3rd. 2 1 7 5 1 7 0 2 6 Faults N N F1 2 2 2 5 0 2 6 F2 1 1 1 1 1 1 F3 7 7 7 7 7 Page Faults = 7 2017-06 Note: Here we have theory as well. 3.1) a) LRU: Replace at top moving all to bottom. Hitted values go to top pushing rest to bottom. 7 2 3 1 3 4 6 7 1 0 5 6 2 3 0 1 Fault N F1 7 2 3 1 3 4 6 7 1 0 5 6 2 3 0 1 F2 7 2 3 1 3 4 6 7 1 0 5 6 2 3 0 F3 7 2 2 1 3 4 6 7 1 0 5 6 2 3 Page Faults = 15 b) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace FIFO: Use start. Insert at star then place star at value that has been present longest. Normal insertion at start 3 pages. 7 2 3 1 3 4 6 7 1 0 5 6 2 3 0 1 Fault N F1 7* 7* 7* 1 1 1* 7 7 7* 5 5 5* 3 3 3* F2 2 2 2* 4 4 4* 1 1 1* 6 6 6* 0 0 F3 3 3 3* 6 6 6* 0 0 0* 2 2 2* 1 Page Faults = 15 2016-10 4.1) Memory addresses Page Number 0-49 0 50-99 1 100-149 2 150-199 3 200-249 4 250-299 5 300-349 6 350-399 7 400-449 8 450-499 9 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 4.2) Page reference string: 1,3,0,3, 5, 0, 2, 0, 1, 4, 2, 0, 1, 4 Reduced page reference string: 1, 3, 0, 3, 5, 0, 2, 0, 1, 4, 2, 0, 1, 4 4.3) a) LRU: Insertion at top. Hitted value goes to top. 1 3 0 3 5 0 2 0 1 4 2 0 1 4 Fault N N N F1 1 3 0 3 5 0 2 0 1 4 2 0 1 4 F2 1 3 0 3 5 0 2 0 1 4 2 0 1 F3 1 1 0 3 5 5 2 0 1 4 2 0 Page Faults = 11 b) Optimal: Normal insertion for 1st three. Replace value furthest down the line (to the right) 1 3 0 3 5 0 2 0 1 4 2 0 1 4 Fault N N N N N N N F1 1 1 1 1 1 4 4 F2 3 3 5 2 2 1 F3 0 0 0 0 0 Page Faults = 7 2016-06 Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace 4.1) Memory addresses Page Number 0-49 0 50-99 1 100-149 2 150-199 3 200-249 4 250-299 5 300-349 6 350-399 7 400-449 8 450-499 9 4.2) Page reference string: 3, 2, 0, 3, 1, 0, 0, 0, 1, 2, 2, 0, 1, 4 Reduced page reference string: 3, 2, 0, 3, 1, 0, 1, 2, 0, 1, 4 4.3) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace a) LRU: Insertion at top moving other to bottom. Hitted value you move to top 3 2 0 3 1 0 1 2 0 1 4 Faults N N N N N F1 3 2 0 3 1 0 1 2 0 1 4 F2 3 2 0 3 1 0 1 2 0 1 F3 3 2 0 3 3 0 1 2 0 Page Faults = 6 b) Optimal: Replace value which is most to the right in the future. 3 2 0 3 1 0 1 2 0 1 4 Faults N N N N N N F1 3 3 3 1 4 F2 2 2 2 2 F3 0 0 0 Page Faults = 5 Exam and assignment theory question to study Note: These questions are from the exams and assignments. The exams repeat many questions so the following questions are the most important questions to study, but the exams might ask new questions. Not all theory are covered in this section, just the most important. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace a) Stealing or copying one’s programs or data; using system resources without proper accounting. b) Probably not, since any protection scheme devised by humans can inevitably be broken by a human, and the more complex the scheme, the more difficult it is to feel confident of its correct implementation. Clustered systems consists of multiple computers which forms a single system to perform a computational task distributed across the cluster. Multiprocessor systems could be a single physical entity comprising of multiple CPUs. Clustered systems communicate using messages, while a multiprocessor system could communicate using shared memory. To provide highly available service, the state on the 2 machines should be replicated and should be consistently updated. When one of the machine fail, the other could then take- over the functionality of the failed machine. Advantages:  Open-source code is more secure than closed-source code, because many more eyes are viewing it. This is beneficial for the people using the OS.  Bugs are discovered faster in open-source Oss, since more eyes are viewing it. Also beneficial for the people using the OS since it is bug free. Disadvantages:  Commercial (non- open source) OS companies are challenged by open source OSs and it might put them out of business. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace  Some open source OSs do not offer support, thus companies avoid using them for projects because they need paid support.  Backward-compatibility is lacking in open-source OSs making upgrades difficult. Frequent releases worsens these issues by forcing users to upgrade frequently. Important question Advantages of using a microkernel approach are:  Adding a new service does not require modifying the kernel  It is more secure as more operations are done in user mode than in kernel mode  A simpler kernel design and functionality results in a more reliable OS. They use interprocess communication mechanisms such as messaging. These messages are conveyed by the OS. The primary disadvantages of the microkernel architecture are the overheads associated with interprocess communication and the frequent use of the OS’s messaging functions for communication between process and service. Important question It is because the standard API and virtual machine are designed for desktop and server systems, not mobile devices. Google developed a separate API and virtual machine for mobile devices. If either the “at most once” or “at least once” semantics is not supported, then the RPC server cannot guarantee that a remote procedure will not be invoked multiple Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace occurrences. Consider if a single remote procedure were withdrawing money from a banking system that did not support these semantics then it might lead to multiple withdraws. If a system were unable to support either of these semantics, then such a system could only safely provide remote procedures that do not alter data or provide time-sensitive results. Using our bank account as an example, we certainly require both semantics for performing a withdrawal, but checking balance does not require these semantics. When a kernel thread suffers a page fault, another kernel thread can be switched in to use the interleaving time in a useful manner. A single-threaded process, on the other hand, will not be capable of performing useful work when a page fault takes place. Therefore, in scenarios where a program might suffer from frequent page faults or has to wait for other system events, a multithreaded solution would perform better.  It only makes sense to create as many threads as there are blocking system calls, as the threads will be spent blocking. Creating additional threads provides no benefit. Thus, it makes sense to create a single thread for input and a single thread for output.  Four. There should be as many threads as there are processing cores. Fewer would be a waste of processing resources, and any number > 4 would be unable to run. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace This scheduler would favour CPU-bound processes as they are rewarded with a longer time quantum as well as priority boost whenever they consume an entire time quantum. This scheduler does not penalize I/O-bound processes as they are likely to block for I/O before consuming their entire time quantum, but their priority remains the same. If a user-level program is given the ability to disable interrupts, then it can disable the timer interrupt and prevent context switching from taking place, thereby allowing it to use the processor without letting other processes execute a) FCFS b) LIFO Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace One is spin lock other 2 is mutex Lock  Spin lock Only for short duration it is spin lock, other is mutex lock  Mutex lock  Mutex Lock As2 This is actually question 2.1 and 2.2 a) #pages = # entries Size of logical address space = #pages * page size 2 32 = #pages x 4096 #pages = 2 32/ 4096 = 2 20 pages b) Same as previous, but here we working with frames and physical address Size of physical address space = No. of frames × frame size Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace No. of frames = Size of physical address space/ frame size = 512MB / 4KB = 128K entries Just do direct division and you will get the answer = 128 * 1024 = 131072 entries (frame size = page size ) In paging in general (# frames = # pages)In Inverted paging ONLY a. Page = 3085/1024 = 3; Offset = 3085 mod 1024 = 13 b. Page = 42095/1024 = 41; Offset = 42095 mod 1024 = 111 c. Page = 215201/1024 = 210; offset = 215201 mod 1024 = 161 d. Page = 650000/1024 = 634 round down; Offset = 650000 mod 1024 = 784 e. Page = 2000001/1024 = 1953; Offset = 2000001 mod 1024 = 129 To do MOD with calculator say Address references – Size * PageNumber) e.g. 3085 – 1024 *3 Yes, because there is only one kernel thread for all user threads, that kernel thread blocks while waiting for the page fault to be resolved. Since there are no other kernel threads for available user threads, all other user threads are thus affected by the page fault. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace By keeping a central open-file table, the OS can perform the following operation that would otherwise not be possible. Consider a file that is currently being accessed by one or more processes. If the file is deleted, then it should not be removed fromthe disk until all processes accessing the file have closed it. This checkcould be performed only if there is centralized accounting of number of processes accessing the file. On the other hand, if two processes are accessing the file, then 2 separate states needs to be maintained to keep track of the current location of which parts of the file are being accessed. This requires the OS to maintainseparate entries for the two processes Advantage is that application can deal with failure condition in a more intelligent manner if it realizes that it incurred an error while accessing a file stored in a remote file system. For instance, a file open operation could simply fail instead of hanging when accessing a file and the application could deal with the failure in the best possible manner; if the operation were simply to hang, then the entire application hangs, which is not desirable. The disadvantage however is the lack of uniformity in failure semantics and the resulting complexity in application code. Block size/ pointer size (8*1024)/4 = 2048 12 * 8KB + 2048*8KB + 2048^2*8KB + 2048^3*8KB= 64 terabytes Direct single double triple Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace Relocation of files on secondary storage involves considerable overhead. Data blocks have to be read into main memory and written back out to their new locations. Furthermore, relocation registers apply only to sequential files, and many disk files are not sequential. For this same reason, many new files will not require contiguous disk space; even sequential files can be allocated non-contiguous blocks if links between logically sequential blocks are maintained by the disk system. Yes, this approach is equivalent to including the access privileges of domain B in those of domain A as long as the switch privileges associated with domain B are also copied over to domain A. Repeated exam questions that you need to study: The green number indicates in how many exams they are in. a) CPU utilization is increased if the context switching overheads is minimized. The context switching overheads could be lowered by performing context switches infrequently. This result in increasing response time for processes. Context Switching overheads b) Average turnaround time is minimized by executing the shortest tasks first. Such a scheduling strategy would starve long-running tasks thus increase their waiting time. Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace c) CPU utilization is maximized by running long-running CPU bound tasks without performing context switches. I/O device utilization is maximized by scheduling I/O bound jobs as soon as they become ready to run, thereby incurring the overheads of context switches. (2) (3) The greatest challenges in designing mobile operating systems include:  Less storage capacity means the OS must manage memory carefully. OS must also manage power consumption carefully.  Less processing power mean the OS must carefully allocate processor resources to applications. OR Yes, this system is deadlock-free. Proof by contradiction. Suppose the system is deadlocked. This implies that each process is holding one resource and is waiting for one more. Since there are three processes and four resources, one process must be able to obtain two resources. This process requires no more resources and, therefore it will return its resources when done. (4) Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace (2) a) To initiate a transfer, the CPU first sets up the DMA registers, which contain a pointer to the source of a transfer, a pointer to the destination of the transfer, and a counter of the number of bytes to be transferred. Then the DMA controller proceeds to place addresses on the bus to perform transfers, while the CPU is available to accomplish other work. b) Once the entire transfer is finished, the DMA controller interrupts the CPU. (2) Main advantage of using the layered approach: - Advantages of layered operating systems are: 1. It provides modularity and clear interfaces 2. It allows good maintenance, because changes affect only limited sections of OS. 3. Easier to debug, also because - Disadvantages of layered operating systems are: 1. It is difficult to exactly assign functionalities to the correct layer 2. Having too many layers can degrade the system’s performance As in all cases of modular design, designing an operating system in a modular way has several advantages. The system is easier to debug and modify because changes affect only limited sections of the system rather than touching all sections of the operating system. Theory: Banker’s algoriThm Stuvia.com - The study-notes marketplace Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal Stuvia.com - The study-notes marketplace a) 6 processes b) 2 threads Theory: Page replacement A set of processes is deadlocked when every process in the set is waiting for a resource that is currently allocated to another process. Powered by TCPDF (www.tcpdf.org) Downloaded by: YeNahGetThat | likewise52@protonmail.com Distribution of this document is illegal","libVersion":"0.2.3","langs":""}