{"path":"Subjects/COS3761 - Formal Logic III/Unsorted/COS3761/exam pack/Materials/Additional+notes+on+Chapter+2.pdf","text":"ADDITIONAL NOTES FOR COS3761 – PART C ADDITIONAL NOTES ON CHAPTER 2 INTRODUCTION In this chapter, the proof system of natural deduction is extended to predicate logic. The syntax and semantics are explained and the concept of bound and free variables is discussed. Soundness and completeness of the natural deduction proof system are briefly discussed. Furthermore, the undecidability of predicate logic is shown by reduction to Post’s correspondence problem. Certain important quantifier equivalences are also shown. 2.1 The need for a richer language Propositional logic is inadequate to express statements such as \"All birds can fly\". If there were n birds in the universe and we had a list of all of them, and we could identify each of them using a specific sequence number, starting at 1, this could be expressed in propositional logic as follows: \"Bird 1 can fly\" and \"Bird 2 can fly\" and \"Bird 3 can fly\" and … and \"Bird n can fly\". This could be feasible if there were only a few birds in the universe. However, even though the number of birds in the universe at any one time is strictly finite for enumeration purposes, that number is infinite for all practical purposes. Hence propositional logic would fail to adequately express the statement that \"All birds can fly\". So, what is the nature of the statement \"All birds can fly\"? It is about the property of \"being able to fly\", a property that all things called \"birds\" should have. So, the proposition \"All birds can fly\" could be written as a material implication that says \"If an object is a bird, then that object can fly\". In order to assert that this implication is true, we have to be inclusive in our consideration of every possible object in the entire universe. If any object that we encounter is a bird and that object does not fly, then we would have to assert that the proposition is false. Predicate logic is designed to give us a way to express knowledge and construct sound logical arguments about elements of (possibly infinitely large) sets. It is based, as you might suspect, on the concept of a predicate. A predicate states something about an object or a tuple of objects. Predicates can take single or multiple arguments. If a predicate takes a single argument, we can think of it as expressing a property of an object. For example, Bird(x), which translates to \"x is a bird\", expresses the fact that some arbitrary object x is a bird. If, on the other hand, the predicate takes more than one argument, we can think of it as a relationship between the arguments of the predicate. For example, Younger(x, y), which translates to \"x is younger than y\", expresses a relationship between the arguments x and y of the predicate Younger. When predicates are defined, the arity of the predicate must always be specified. The arity defines how many arguments the predicate takes. By convention, predicate names always start with capital letters. The notion of a variable is implicit in the above examples of a predicate. The variable is the generic name for any object from our universe of discourse. Predicate logic also deals with functions. A function expression differs from a predicate statement in that instead of denoting a truth value, it denotes a single object. For example, productOf(x, y) denotes the single object that represents the product of x and y. Another example, the function parentOf(y) denotes the single object that represents the parent of y. Some functions do not require any arguments. Such functions are called constants because they always take on the same value. The arity of a function is the number of arguments it requires. The convention we follow is to represent function names by beginning them with lower case letters. Function symbols are used to build complex terms, whereas predicates are used to build predicate formulas. Predicate logic also introduces the notion of quantification. The two main quantifiers used in predicate logic are the universal and existential quantifiers. Symbolically represented as '∀', the universal quantifier loosely translates to “every” or “for all”. The existential quantifier, '∃', loosely translates to “there is at least one” or “there exists at least one”. Thus, for example, ∀xP(x) expresses the fact that “every object x is such that x is P”, whatever predicate P stands for. Similarly, the quantified expression ∃xP(x) expresses the fact that “there is at least one object x such that x is P”, whatever predicate P means. 2.2 Predicate logic as a formal language A vocabulary of predicate logic consists of three sets: a set P of predicate symbols, a set F of function symbols and a set C of constant symbols. We can actually get by with two sets only because C is a subset of F if we consider every constant to be a nullary function. 2.2.1 Terms These are logical expressions that refer to objects. The inductive definition of term is given on page 99 of the prescribed book. Example: A symbol that refers to one specific whistler’s female parent always denotes the same value, and is therefore a constant. Thus the constant ‘whistlersMother’ would be a valid term. Unary functions can sometimes more easily express the same idea as a constant. Thus the term motherOf(whistler) could also refer to the same object as referenced by the constant ‘whistlersMother’. 2.2.2 Formulas The inductive definition of well-formed formulas (wffs) is given on page 100 of the prescribed book. You will note that parentheses occur in all the formulas. However, the use of parentheses can very often be avoided by applying the same binding priorities as in propositional logic. The quantifiers have the same binding priority as negation (¬). Therefore, if we want a quantifier to apply to more than just the formula following immediately after it, we need to use parentheses to demarcate the scope of the quantifier. For example, in \"∃xP(x) ∨ Q(x)\" the quantifier applies only to P(x). If the intention is to extend the scope of the quantifier to the whole formula, we must write \"∃x(P(x) ∨ Q(x))\". We deal with the semantics (meaning) of predicate logic in section 2.4. There we will see that predicate logic defines the idea of a model of a formula φ as a specific assignment of meaning to the predicates and functions that appear in φ. There are some formulas that are true in all models (for example, \"P(x) ∨ ¬P(x)”), some formulas are true in some models and false in others, while other formulas are false in all models. One of the main goals of predicate logic is to determine the models in which a formula is true or false. However, we before we come to that, we need to understand what free and bound variables are, and how constants, variables and terms can be substituted for each other. 2.2.3 Free and bound variables A variable is said to be bound if, as we traverse up the parse tree from the leaf containing the variable, we encounter a quantifier for that variable. A variable is free if it is not bound. A wff without any free variables is called a sentence. 2.2.4 Substitution Natural deduction proofs in predicate logic sometimes require the substitution of free variables by constants or terms. We write φ [t/y] to mean \"substitute the term t for all free instances of variable y in φ \", or equivalently \"replace all free instances of variable y in φ by t\". Definition: If φ is a predicate logic formula, t is a term, and y is a variable, then we denote by φ [t/y] the formula obtained by replacing all free instances of y in φ by t. The expression t/y is called a substitution. Note that if φ does not contain y as a free variable, the substitution would have no effect. Bound variables cannot be replaced by other variables, constants or terms. (This is because the substitution would result in an unintentional alteration of the semantics of the formula. For example, an attempt to substitute x for the bound occurrences of y in ∀y(P(x) ∨ Q(y)) would result in the formula ∀x(P(x) ∨ Q(x)), which would have an entirely different meaning from the original.) Special care must be taken, though, as even substituting for free variables is not always safe. For example, suppose that a free instance of y occurs within the scope of a quantified variable x in a formula φ. If we replace y with a term t that includes the variable x, then this variable is now unintentionally bound by the quantifier. This has the unintended consequence of changing the meaning of the original formula, and hence the conditions under which the formula is true or false. A term t is said to be free for x in φ if none of the free instances of x in φ are within the scope of any quantifier that extends to any variable that appears in t. In other words, it is safe to substitute t for x in φ. Thus, the substitution does not pose the risk of unintentionally changing the meaning of the formula. We stress that if the variable x is not free in φ, that is, if φ contains only bound occurrences of x or no occurrences of x at all, then the substitution φ [t/x] has no effect, and φ [t/x] is said to be equivalent to φ. For example, let φ be a formula ∀xP(x, y) and let t be a term. Then φ [t/x] = φ since x is a bound variable in φ and φ [t/y] = ∀xP(x, t) since y is a free variable in φ. (But note that x must not occur free in t.) Take note that replacements of different free occurrences of the same variable take place at the same time; in other words, simultaneously. For example, if φ is the formula P(x, x) → ∃yQ(x, y), then φ [h(x)/x] is P(h(x), h(x)) → ∃yQ(h(x), y). We stress that, as explained above, it is possible that substitutions may result in unintended, semantic side effects when their application leads to a change in the meaning of the formula. Because of that, substitutions should always be done subject to certain restrictions, which can be summarized in the following definition: Definition: A term t is said to be free to replace a variable x in a formula φ if no free occurrence of x is in the scope of a quantifier that binds a variable y occurring in t. The following are examples of situations in which t is free to replace all free occurrences of x in φ : • t is equal to x. • t is a constant. • The variables appearing in t do not occur in φ. • The variables appearing in t do not occur within the scope of a quantifier in φ. • There are no quantifiers in the formula φ. • The variable x does not occur freely within the scope of a quantifier in φ. Function f(x, y) is free for x in the following wff: (∃xP(x) ∨ Q(y)) → (P(x) ∧ ¬Q(y)) However, f(x, y) is not free for y in ∃x(P(x) ∨ Q(y)) → (P(x) ∧ ¬Q(y)) because the first free occurrence of y occurs within the scope of ∃x and x appears in f(x, y). What should we do in such a case if we want to do the substitution? We should rename all the bound occurrences of x in the given formula before doing the substitution. Thus we need two steps for the substitution: First ∃u(P(u) ∨ Q(y)) → (P(x) ∧ ¬Q(y)) is equivalent to ∃x(P(x) ∨ Q(y)) → (P(x) ∧ ¬Q(y)) and then ∃u(P(u) ∨ Q(f(x, y))) → (P(x) ∧ ¬Q(f(x, y))) 2.3 Proof theory of predicate logic 2.3.1 Natural deduction rules The natural deduction rules of predicate logic can be obtained as an extension of the deduction rules of propositional logic. This can be done by • keeping the propositional rules, e.g. φ ¬φ ¬e ⊥ for any predicate logic sentence φ, and • introducing new rules for quantification and equality. New Rules We discuss the new rules for natural deduction in predicate logic below. Rules for Equality = i \"equality introduction\" This rule says that we can always add \"t = t\" to our proofs, where t is any term. = e \"equality elimination\" Equality elimination is an interesting case, because it allows us to apply substitution in our proofs. The basic idea is that if we have \"t1 = t2\" in our proof, and we also have a formula of the form φ [t1/x] (i.e. a formula in which t1 has been substituted for all the free instances of x), then we can add the formula given by φ [t2/x]. This is possible because if t1 = t2, both t1 and t2 should have the same effect on the truth value of φ. Note, however, that for these substitutions to work, we require that both t1 and t2 be free for x in φ. The challenge with using this rule is being able to recognize when we have a useful formula of the form φ [t1/x] in our proof. Rules for Universal Quantification ∀x e \"for all x elimination\" Given the quantified formula ∀xφ, the rule \"for all x elimination\" allows us to substitute anything we want for the free instances of x in the formula φ (as long as what we substitute is a term which is free for x in formula φ). It is important to realize that φ does not include the ∀x that precedes it. For example, if we have \"∀x(P(x) ∧ Q(x))\" then φ is \"P(x) ∧ Q(x)\" and both occurrences of x are free in φ. ∀x i \"for all x introduction\" In order to introduce a universal quantifier we create a new, completely unconstrained variable (traditionally called x0) and attempt to prove some formula that includes x0 (i.e. a formula of the form φ [x0/x]). In writing our proofs, we open a box, which looks just like an assumption box, but which represents the scope of the variable x0. When we have proved φ [x0/x] within the box, we are entitled to close the box and assert that \"∀x φ \". We can do this because we didn't put any constraints on x0, so whatever properties it has are ones that it shares with all objects in the universe of discourse. Hence the lines of the proof within the box would work no matter what actual value we assigned to x0. That is, the conclusion φ is true for any arbitrary variable x. Rules for Existential Quantification ∃x i \"there exists x introduction\" If we have φ [t/x] in a proof (i.e. a formula which would result from replacing all the free occurrences of x in φ with t) then we know that there is some value that makes φ true. Thus we can introduce the formula \"∃xφ \". This may seem useless because it is giving up some information - we are going from an assertion that φ is true for a specific value to an assertion that φ is true for some unknown value. On the contrary, it is actually very useful to us because very often the specific value for which φ is true will be a \"local\" variable defined within an assumption box. The scope of that variable is restricted to the box, and we cannot carry it outside the box, but after we generalize the statement \"φ [x0/x]\" to \"∃xφ \", we can extend the scope of that statement outside the box. It is important to note that, whenever we write “φ [t/x]\", it is understood that this particular sequence of characters is not a formula, and would not appear as a line in our proof. Rather, \"φ [t/x]\" is a short-hand notation of a formula that would result from replacing all free occurrences of x in φ by t. This is the formula that would actually appear in the proof. ∃x e \"there exists x elimination\" The reasoning that lets us eliminate an existential quantifier is very similar to the \"∨ elimination\" rule in propositional logic. If we are given \"∃xφ \" then we know that there is some value x0 such that φ [x0/x] is true. This is equivalent to an infinitely long disjunction: \"φ [a/x] ∨ φ [b/x] ∨ φ [c/x] ∨ ...\" where a, b, c, etc are all the values in the universe. To make use of this knowledge, we introduce a box containing a value x0. Within the box, we prove some formula χ such that χ contains no reference to x0. We then pull χ out of the box as a true statement. This makes sense because we put no constraints on x0 other than that φ [x0/x] is true. Thus, the steps we use to derive χ within the box would be valid no matter what value we choose for x0, so long as φ [x0/x] is true. We leave x0 within the box because we don't really know its value, but we pull χ out of the box because it is true no matter which φ- satisfying value of x0 we choose. As a natural language demonstration of this rule, consider the following argument: If any automobile can fly, then that automobile is a bird. There is an automobile that can fly. Therefore There is an automobile that is a bird. In order to prove the above we use the following predicates: A(x) : x is an automobile B(x) : x is a bird F(x) : x can fly We can then derive the following proof: 1 2 ∀x(A(x) ∧ F(x) → B(x)) ∃x(A(x) ∧ F(x)) premise premise 3 4 5 6 7 8 9 x0 A(x0) ∧ F(x0) A(x0) A(x0) ∧ F(x0) → B(x0) B(x0) A(x0) ∧ B(x0) ∃x(A(x) ∧ B(x)) assumption ∧e1 4 ∀x e 1 → e 6, 4 ∧i 5,7 ∃x i 8 10 ∃x(A(x) ∧ B(x)) ∃x e 2, 3-9 Notice that the prescribed book uses “assumption” in line 4 above as the justification for the introduction of this line in the proof. It would have been preferable to justify the introduction of this line by writing: φ: A(x) ∧ F(x), φ [x0/x]. 2.3.2 Quantifier equivalences In addition to the propositional equivalences discussed before, we have equivalences for predicate logic. φ and 𝜓 denote arbitrary predicate formulas. 1. ∀x∀yφ ⊣⊢ ∀y∀xφ 2. ∃x∃yφ ⊣⊢ ∃y∃xφ 3. ¬∀xφ ⊣⊢ ∃x¬φ 4. ¬∃xφ ⊣⊢ ∀x¬φ 5. ∀x(φ ∧ 𝜓) ⊣⊢ ∀xφ ∧ ∀x𝜓 6. ∃x(φ ∨ 𝜓) ⊣⊢ ∃xφ ∨ ∃x𝜓 7. If x does not occur free in φ then ∃x(φ ∧ 𝜓) ⊣⊢ φ ∧ ∃x𝜓, and ∃x(φ ∨ 𝜓) ⊣⊢ φ ∨ ∃x𝜓, and ∀x(φ ∨ 𝜓) ⊣⊢ φ ∨ ∀x𝜓, and ∀x(φ ∧ 𝜓) ⊣⊢ φ ∧ ∀x𝜓. 8. If x does not occur free in φ then ∀x(φ → 𝜓) ⊣⊢ φ → ∀x𝜓, and ∃x(φ → 𝜓) ⊣⊢ φ → ∃x𝜓. 9. If x does not occur free in 𝜓 then ∀x(φ → 𝜓) ⊣⊢ ∃xφ → 𝜓, and ∃x(φ → 𝜓) ⊣⊢ ∀xφ → 𝜓. Example: Let us show that if x is not free in φ then ∃x¬𝜓 → ¬φ is equivalent to ∀x(φ → 𝜓). ∃x¬𝜓 → ¬φ ⊣⊢ ¬∀x𝜓 → ¬φ (equivalence 3) ⊣⊢ φ → ∀x𝜓 (see note below) ⊣⊢ ∀x(φ → 𝜓) (equivalence 8) Note: We used the propositional equivalence: ¬φ → ¬𝜓 ⊣⊢ 𝜓 → φ The above example is not a formal proof. You will find examples of natural deduction proofs in your prescribed book on pages 118 to 122. 2.4 Semantics of predicate logic How can we evaluate formulas in predicate logic? In propositional logic we could simply assign truth values to all the atoms, but now it is more complicated. We need the notion of models. 2.4.1 Models Note: Models are defined differently by different logicians. In other logic textbooks you may come across the term ‘interpretation’ which corresponds to ‘model’ here. We will stick to the way the term is used in our prescribed book. Given a set F of function symbols and a set P of predicate symbols, a model of the pair (F, P) is defined on page 124 of the prescribed book. We give two examples of models below. The model in the first example has a universe consisting of four girls. In the second example we give a mathematical model. First example of a model Given F: the set { j, a, b } P: the set { T } where the first two elements of F (namely j and a) are constants, i.e. nullary functions, the third element of F (namely b) is a unary function, and the only element of P (namely T) is a binary predicate. There are many possible models. Note that in all models M we are obliged to define a value for the function bM for every element of the universe A that we will choose, but that we are free to define the predicate TM in any way we like. We construct the following model M of (F, P): • The universe A of concrete values: {joan, margaret, alma, danita}, • j M = joan, • aM = alma, • bM(joan) = margaret • bM(margaret) = alma • bM(alma) = danita • bM(danita) = alma • T M = { (joan, alma), (alma, joan) } We think of b(x) as “best friend of x” and of T(x, y) as “x and y are twins”. Second example of a model Given F: the set { 0, 1, +, ∗, -, / } P: the set { =, ≤, <, >, >, != } where the first two elements of F are nullary functions (i.e. constants) and the other elements binary functions, and all the elements of P are binary predicates. We construct the following model M of (F, P): • The universe A of concrete values: the set of real numbers • 0M : the real number 0, • 1M : the real number 1, • + M: the addition operation, • ∗ M: the multiplication operation, • - M: the subtraction operation, • / M : the division operation, • = M: the equality predicate, • ≤ M: the less-than-or-equal-to predicate, • < M: the less-than predicate, • > M: the greater-than predicate • > M: the greater-than-or-equal-to predicate • != M: the not-equal-to predicate Suppose we are given one or more formulas and are required to construct a model where the formulas are true or to construct a model where the formulas are false. We will need a universe of concrete values as well as definitions for all functions and all predicates appearing in the formulas. (If the formulas do not involve any constants or other functions, no function definitions are required - the set F is empty.) Look at the two examples below where models have to be constructed. Required: a model where a given sentence is true Given the sentence ∀x ∀y (R(x, y) ∨ R(y, x) → ¬ R(x, x)) we have to construct a model where the sentence is true. Note that F is empty because the given sentence does not include any constants or other functions. The sentence involves one predicate, namely R, with two arguments. So F: the set { } P: the set { R } There are many possible models. We construct the following model M of (F, P): • The universe A of concrete values: the set of integers greater than 3, i.e. {4, 5, 6, …} • R M : We define R(x, y) as “x is equal to 2 times y”. You should be able to see that the given sentence is true in this model, because the right hand side of the implication is always true: no integer greater than 3 is equal to 2 times itself. Required: a model where a given sentence is false Given the sentence ∃x G(x, m(x)) we have to construct a model where the sentence is false. We see the sentence involves one function (with one argument) and one predicate (with two arguments). So F: the set { m } P: the set { G } There are many possible models M. Note again that we are obliged to define a value for the function m M for every element of the universe A that we choose, but that we are free to define the predicate GM in any way we like. We construct the following model M of (F, P) where the sentence is false. (We think of m(x) as “husband or wife of x” and of G(x, y) as “x and y are colleagues”, thus the sentence states that some married couple are colleagues. This has to be false.) • The universe A of concrete values: {zeb, yaco, suzie, patience}, • m M (zeb): suzie • m M (suzie): zeb • m M (yaco): patience • m M (patience): yaco • GM : {(zeb, patience), (patience, zeb)} Below we give three additional examples of models - one of a mathematical nature and the other two non-mathematical. In each case we investigate whether given well-formed formulas are true or not in that model. First additional example of a model Given F: the set { c, f } P: the set { E } where c is a nullary function, i.e. a constant, f is a binary function, E is a binary predicate. Suppose we construct the following model M of (F, P): • The universe A of concrete values: the set of natural numbers {0, 1, 2, …}, • c M = 0, • the function fM is defined by fM(i, j) = (i + j) mod 3, • E M: the equality predicate Is the wff ∀x[E(f(x, x), x) → E(x, c)] true in this model? Yes. (In this model the meaning of the formula is, for all natural numbers k, if 2k mod 3 = k, then k = 0.) However, the following wff is false in this model: ∀x∀y[E(f(x, y), y) → E(x, c)] (In this model the meaning of the formula is, for all natural numbers k and m, if (k + m) mod 3 = m, then k = 0.) Second additional example of a model Given F: the set { c } P: the set { L } where c is a nullary function, i.e. a constant, and L is a binary predicate. Suppose we construct the following model M of (F, P): • The universe A of concrete values: {lola, john, harry}, • c M = lola, • LM = {(lola, lola), (lola, john), (john, lola), (harry, john)} (where we think of L(x,y) as “x likes y”) Is the wff ∀x(L(c, x) → L(x, c)) true in this model? Yes. (“Everyone Lola likes, likes her” - yes) However, the wff ∀x(L(c, x)) is false in this model. (“Lola likes everyone” - no.) Third additional example of a model Given F: the set { a, b, c, m, n } P: the set { F, K } where a, b, c, m and n are nullary functions, i.e. constants, and F and K are binary predicates. We construct the following model M of (F, P): • The universe A of concrete values: {aggie, bob, cecilia, marco, vincent}, • aM = aggie, • bM = bob, • c M = cecilia, • m M = marco, • nM = vincent, • F M = {(aggie, cecilia), (bob, aggie), (bob, cecilia), (bob, marco)} (where we interpret F(x,y) as “x and y are friends”) • KM = {(aggie, aggie), (aggie, cecilia), (aggie, bob), (bob, bob), (bob, cecilia), (bob, marco), (bob, vincent), (cecilia, cecilia), (cecilia, vincent), (marco, marco), (marco, aggie), (marco, vincent), (vincent, vincent)} (where we think of K(x,y) as “x knows y”) The wff ∀x∀y((F(x, y) ∨ F(y, x)) → (K(x, y) ∨ K(y, x))) is true in this model. The intended meaning of the formula is “If two persons are friends, then they know each other”. However, the wff ∃x((F(m, x) ∨ F(x, m) ) ∧ (F(x, n) ∨ F(n, x))) is false in this model. The intended meaning of the formula is “There is someone that is a friend of Marco and a friend of Vincent”. Environment An environment (or look-up function) l for a universe A of concrete values is defined on page 127 of the prescribed book. Such a function maps every variable onto an element of A. Interpretation of terms Terms are defined on page 99 of the prescribed book. Let T(F, var) denote the set of terms built from function symbols in F and variables in var. Each model M and look-up function l induce a mapping tA from the set of terms onto the universe A. The mapping can be defined recursively by: tA (x) = l(x) for x an element of var tA f(t1, . . . , tk) = fM (tA(t1), tA(t2), ..., tA(tk)) This means that, given a model M and look-up function (or environment) l, we find that terms denote elements of the universe A of concrete values. Here follows an example: Example of the interpretation of terms in a given model and look-up function Given F: the set { +, ∗ } P: the set { = } where the elements of F are binary functions, and the element of P is a binary predicate. We construct the following model M of (F, P): • The universe A of concrete values: the set of real numbers • + M: the addition operation, • ∗ M: the multiplication operation, • = M: the equality predicate, (where we will use infix notation for these symbols) and the following environment (look-up function) l: l(x) = 3 l(y) = 2 l(z) = 1 Now the following will be the case in the model: If the variable x is free in a given wff, it will be interpreted as 3. If a wff contains the term (x∗(y+x∗z)) where all the variables are free, it will be interpreted as 15. Satisfaction in an environment Satisfaction in an environment is defined on page 128 of the prescribed book. For a formula ψ without any free variables (i.e. a sentence) the environment is irrelevant and may be omitted from the notation. Thus in that case we may simply write M ⊨ ψ. 2.4.2 Semantic entailment Here the issue is whether the meaning of a given sentence entails that of another. This is a fundamental problem in natural language understanding. It provides a broad framework for studying language variability and has a large number of applications. It is defined on page 129 of the prescribed book. Note: Γ ⊨ Q differs from M ⊨l B; these conflicting uses of the symbol ⊨ are traditional. 2.4.3 The semantics of equality The semantics of “equality” = is intuitively as follows: given two terms t1 and t2, the formula t1 = t2 is true in a model M based on a set A if and only if t1 and t2 are interpreted by the same element of A. Formally: M ⊨l t1 = t2 holds if and only if tA(t1) = tA(t2) 2.5 Undecidability of predicate logic A formula φ is valid iff M ⊨ φ holds for every model M. Because φ has to be true in all models, validity is a very strong condition to place on the formula. Soundness Proof system ⊢ is sound iff for any closed predicate formula φ (i.e. a formula without any free variables, also called a sentence) we have: if ⊢ φ then M ⊨ φ for every model M In brief: the proof system is sound if any provable formula is valid. Completeness Proof system ⊢ is complete iff for any closed predicate formula φ (i.e. a formula without any free variables, also called a sentence) we have if M ⊨ φ for every model M, then ⊢ φ In brief: the proof system is complete if any valid formula is provable. The proof system ⊢ described in the prescribed book is both sound and complete: If φ is a closed predicate formula, then ⊢ φ iff M ⊨ φ for every model M The decidability problem for predicate logic How can we find out whether or not ⊨ φ in predicate logic? The truth-table method works for propositional logic: enumerate all possible values of propositional variables. However, this does not work for predicate logic since there are infinitely many models, and so infinitely many valuations for individual variables. It is shown in the prescribed book that, even though provability and validity are equivalent, neither one is decidable. In other words, you cannot be guaranteed to find out in a predetermined finite number of steps whether or not ⊨ φ in predicate logic! Implications for the deductive paradigm We know that if φ is a closed predicate formula (i.e. a sentence, i.e. does not have any free variables), then ⊢ φ iff M ⊨ φ for every model M. We also know that the question of whether ⊨ φ is undecidable. Consequence: There exists no perfect theorem-proving system for predicate logic. The set of true (valid) formulas can be enumerated: just enumerate all possible proofs using, for example, Huth and Ryan’s proof system. But there exists no way to enumerate the set of false formulas (else truth would be decidable). Therefore we have the following situation: Checking whether φ is valid (i.e. checking whether ⊨ φ) is undecidable. Corollaries: • Checking whether φ is satisfiable is undecidable. • Checking whether φ is provable (i.e. checking whether ⊢ φ) is undecidable. 2.6 Expressiveness of predicate logic In contrast to first-order logic (that we have discussed up to now), second-order logic allows quantification over functions and predicates. It can, for example, express mathematical induction by ∀P [P(0) ∧∀k (P(k) → P(k + 1)) → ∀n P(n)], using quantification over the unary predicate symbol P. In second-order logic, these functions and predicates must themselves be first-order, taking no functions or predicates as arguments.","libVersion":"0.2.3","langs":""}