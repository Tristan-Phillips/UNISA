{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/202_2016_1_b.pdf","text":"BAR CODE Learn without limits. university of south africa Tutorial Letter 202/1/2016 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 School of Computing IMPORTANT INFORMATION This tutorial letter contains model solutions for assignment 02 COS3751/202/1/2016 ASSIGNMENT 02 Solution Total Marks: 150 UNIQUE ASSIGNMENT NUMBER: 866067 Study material: Chapters 5 (Adversarial Search) and 7 (Constraint Satisfaction Problems). You may skip sections 5.5, 5.6, and 5.7. Question 1: 16 Marks (1.1) (2)Deﬁne the concept of a zero-sum game as we study it in AI. A zero sum game is a fully observable, deterministic, adversarial game (turn-based for two-players) in which a win for one player is a loss for the other. The end value for a game is always equal but opposite for the players.✓2 (1.2) (3)Clearly explain what a utility function is, and why it is used during adversarial searches. A utility function provides an indication of the apparent numerical value✓of a terminal state✓s for player p. It is used to ﬁnd the best available move for a player✓. In the case that the search tree is too deep, the leaf nodes of the searchable tree is considered the terminal node. (1.3) (5)Deﬁne the utility function for a game of tic-tac-toe. Provide the algorithm for this utility function and provide an example of the result of applying your function to a terminal state in the game tree. The simplest utility function will simply add together the number of tokens for a par- ticular player in a row. If there are 3 in a row, the utility is +1, if there are 3 of the opponents’ tokens in a row, the utility is -1. Remember: the principle here is that the search can consider all the search nodes to a terminal state. If we had some sort of a limit as to how far we would search, the nodes at the limit would be considered terminal states (even though those states may not be the end of the game). There are many ways of writing this, but what is provided here is elaborate by choice – it makes it easier to understand what is happening. We provide a helper algorithm: 2 COS3751/202 input : t the player’s token, S the state to evaluate output: +1 for a win for token t, 0 otherwise u ← 0; for i ← 1 to 3 do if S1i = t and S2i = t and S3i = t then u ← 1; end end for j ← 1 to 3 do if Sj1 = t and Sj2 = t and Sj3 = t then u ← 1; end end if S11 = t and S22 = t and S33 = t then u ← 1; end if S31 = t and S22 = t and S13 = t then u ← 1; end return u We can now deﬁne a utility function which simply calls the helper function once for each token. Depending on who we want the utility for we will return 1 or -1. ✓5 (1.4) (3)Explain how forward pruning works. Provide at least one approach to forward prun- ing in your explanation, as well as a problem that may be encountered with forward pruning. Forward pruning means that some nodes are pruned without even considering them✓. Beam search [others are also considered] only considers a sample of the best moves at each ply✓, but this may lead to the best move being pruned away✓. (1.5) (3)Does the order in which nodes are examined in minimax matter? Explain your answer. Only if we prune✓. Otherwise minimax is an exhuastive search✓(for the parameters such as depth – plys – it is conﬁgured for✓) and node orders do not matter. Question 2: 33 Marks (2.1) Consider ﬁgure 1 and answer the questions that follow. (The utility value of the leaf nodes are provided in brackets in the leaf node.) (a) (9)Provide the minimax values for all the nodes. A = -3✓, B = -3✓, C = -4✓, D = -3✓, E = 4✓, F = 9✓, G = -4✓, H = 1✓, I = 7✓ 3 A B C D J E K F L M G H I N O P Q R -3 4 0 9 -4 -9 1 7 0 Figure 1: Minimax, alpha/beta A B C D J E K F L M G H I N O P Q R -3 4 0 9 -4 -9 1 7 0 MAX(-3,-4) = -3 MIN(MIN(-3,4),9)) = -3 MAX = -3 MAX = 4 MAX(0,9) = 9 MAX(-4,-9) = -4 MAX = 1 MAX(7,0) = 7 MIN(MIN(-4,1),7) = -4 (b) (2)Which move should MAX make? Explain your answer. B✓. The utility value for MAX for move B is higher than that of move C✓. (c) (7)Write down the α/β values for all the nodes (except the leaf nodes) if alpha/beta pruning is applied to the tree. Provided below is < node >= (α, β): A = (-3, ∞)✓, B = (−∞,-3)✓, C = (-3,∞)✓, D = (-3, ∞)✓, E = (−∞,-3)✓, F = (-∞,-3)✓, G = (-3, ∞)✓. 4 COS3751/202 A B C D J E K F L M G H I N O P Q R -3 4 0 9 -4 -9 1 7 0 v = \b\b−∞ − 3 α = \b\b−∞ − 3 β = ∞ v =ˆ∞ − 3 α = −∞ β =ˆ∞ − 3 v = \b\b−∞ − 3 α = \b\b−∞ − 3 β = ∞ v = \b\b−∞4 α = −∞ β = −3 v = \b\b−∞0 α = −∞ β = −3 v = \b\b−∞ − 4 α = −3 β = ∞ v =ˆ∞ − 4 α = −3 β = ∞ When v = −4, v ≤ α ⇒ α-cut When v = 0, v ≥ β ⇒ β-cut -3 4 0 -3 -4 -4 The tree was traversed from left to right, and v = ˘˘˘−∞ 3 means that the original value of v was −∞ but was replaced with 3 during execution of the algorithm. We follow the red dashed arrows: down, then up with a return value. (d) (6)Write down which nodes were cut and what type of cut was made in each case (alpha, or beta). α-cut✓below C (H and I is not expanded)✓2. β-cut✓below F (M is not ex- panded)✓2 Also note: if there were an additional node below E, there would have been a β- cut. This would have happened because after v = MAX (v , 4) = 4 (v = −∞), we have that v ≥ β (β = −3), which is the requirement for a β-cut. (e) (4)Suppose the tree in ﬁgure 1 was traversed from right to left (instead of from left to right) would the same cuts have been made? Clearly explain your answer. You may use values from the tree to support your argument. Notice that I and M are right-children. It is impossible to determine if we should cut, if we cannot examine the nodes that would naturally occur during our ﬁrst consideration of a node’s children. Thus we cannot cut I or M. The only question that remains is H; but the same argument holds: once we exam- ine I and calculate the α and β values for C, we have to examine H (the situation is a mirror of nodes D and E, we cannot cut E since we have too little information after having examined D). ✓4 (2.2) (5)Explain what the horizon effect is. Provide an example that clearly explains this phe- nomenon. Use diagrams to assist your discussion. This happens when, for example, a depth limited search results in a sequence of moves resulting in an unavoidable bad state by pushing the bad state ’over the horizon’ 5 of the search. This is done by the search selecting a sequence of actions which end up looking like the unavoidable state has been ’avoided’, but which in fact as simply delayed it. Remember, the critical idea here is not that the avoidance tactic is chosen purposefully, but that the set of actions chosen is so chosen because the search is limited in how far it will look ahead. If the bad state is just on the horizon, the search will try to ﬁnd a better result, which (because it is depth-limited) may not see that the end result (just over the horizon) will be the bad unavoidable state. Any diagram which illustrates this situation is acceptable. ✓5 Question 3: 18 Marks (3.1) Consider a simpliﬁed version of Nim: Two players (A and B) take turns removing items from a heap (just one heap). Each player may remove either one, two, or three items from the heap. The heap starts off with seven items, and player A moves ﬁrst. The objective of the game is to be the last player to remove items from the heap. That is, if it is your turn to move, and the heap is empty, you’ve lost the game. A partial game tree for the game is shown in ﬁgure 2 on page 7. The state represented in each node is (P, n) where P ∈ {A, B} (the player whose turn it is to move next) and 0 ≤ n ≤ 7 (the number of items remaining in the heap). Thus (A, 6) would mean that player A will move next, and there are six items left in the heap. The label next to each edge indicates the number of items removed by the player whose turn it was to move. Loop states for nodes below (B, 6) are shown in elipses1, and terminal states are shown in rectangles. The utility value for a win uw for player A is +1, and a loss ul is −1 (draws are not possible in this game). Players are greedy, and if a win is possible, they will take it. Suppose you are trying to build a minimal tree for the game using expected utility values for different states (since you have access to the entire search tree you are able to use statistics based on the number of occurrences of events). You want to limit the depth of the tree to 2 (the root node and one level below). (a) (9)What is the expected utility value for state (B, 6) (E(B,6)) for player A? Show your calculations. Should A play to state (B, 6) by taking just 1 item from the heap? Why/why not? We simply calculate the number of possible wins and losses for A from (B, 6). There are 9 outcomes from this state, in which A will win exactly 4 times. Thus the probability (p) of a win from (B, 6) is p = 4 9 = 0.44✓2 The probability (q = 1 − p) of losing from this position is q = 5 9 = 0.56✓2. The expected utility value is E(B,6) = uw p + ulq = 1 × 0.44 + −1 × 0.56 = −0.11✓3. Since there are no draw in this game, A will lose if this state is reached✓✓. (b) (9)Which move should A play at the start of the game? Justify your answer by showing expected utility values. We calculate the expected utility for (B, 4). Since (B, 4) is a loop state, we simply 1Thus, there is a subtree somewhere in the tree which is equivalent to this loop state, and the subtree for the loop state is not shown again. 6 COS3751/202 (A,7) (B,6) (A,3) (B,0) 33 (A,4) (B,1) (A,0) 1 3 (B,2) 2 (B,3) 1 2 (A,5) (B,4) (A,3) 1 (A,2) (B,0) 22 (A,1) (B,0) 1 3 1 (B,3) (A,0) 32 (B,2) (A,0) 2 31 1 (B,5) . . .2 (B,4) . . .3 Figure 2: Partial game tree for simpliﬁed Nim. check the possible outcomes for the subtree. There are 3 possible outcomes in which A wins each time, thus: p = 3 3 = 1, q = 1 − p = 0 and the expected utility is E(B,4) = +1 × 1 + −1 × 0 = 1 a guaranteed win for A.✓4. 7 For (B, 5), we have the following sub-tree: (B,5) (A,4) (A,3) (A,2) We know that (A, 4) has 3 outcomes, and (A, 3) and (A, 2) each have 1 outcome. We thus have 5 outcomes, and losses for A from (A, 4), and wins from the other 2. So we have p = 2 5 = 0.4, q = 1 − p = 0.6, and then E(B,5) = uw p + ulq = +1 × 0.4 + −1 × 0.6 = −0.2✓4 A should thus always take 3 items from a 7 item heap to guarantee a win✓. Question 4: 10 Marks (4.1) (4)Differentiate between node and arc consistency. A node is node-consistent if the values in the variable’s domain satisfy the variables unary constrains, whereas arc-consistency requires that the values in the variable’s domain satisﬁes the variables binary constraints. ✓4 (4.2) (4)Explain why achieving arc consistency is beneﬁcial. Provide an example to justify your answer. Smaller search domains✓2, any example which shows how making a variable arc consistent reduces the domain for that variable will sufﬁce✓2 (4.3) (2)The Atmost constraint is used to indicate an upper bound on some set of variables. For example Atmost(10, P1, P2, P3, P4) is taken to mean that the sum of variables P1 to P4 should at most be 10. Rewrite this constraint as a regular arithmetic constraint. ∑4 i=1 Pi ≤ 10✓2 Question 5: 43 Marks Consider the following crypt-arithmetic puzzle: C R O S S + R O A D S D A N G E R 8 COS3751/202 (5.1) Re-write the puzzle in terms of a Constraint Satisfaction Problem (CSP) by deﬁning the following: (a) (10)The variables for the puzzle. X = {C✓, R✓, O✓, S✓, A✓, D✓, N✓, G✓, E✓} ✓for correct notation. (b) (5)The domains for the puzzle. ✓for correct notation DX /{C,R,D} = [0, 9]✓2 DC,R,D = [1, 9] ✓2 (c) (8)The constraints for this puzzle. 1. alldiff ✓ 2. S + S = R + X1 × 10✓ 3. X1 + S + D = E + X2 × 10✓ 4. X2 + O + A = G + X3 × 10✓ 5. X3 + R + O = N + X4 × 10✓ 6. X4 + C + R = A + X5 × 10✓ 7. X5 = D✓ 8. D = 1 ✓ (5.2) (15)Provide the solution to this crypt-arithmetic puzzle, show all the steps you took to arrive at the answer (also show which heuristic you employed, and your backtracking strategy (if used)). 1. We’ll use MRV. This has some important aspects: since we have D = 1, we remove 1 from the domain of all other variables. (This also means that X5 = 1) 2. Because of constraint 2, we know that R must be even, so we can remove all odd values from its domain, leaving us with DR = {2, 4, 6, 8}. This also means that using MRV, R is our next variable of choice. Suppose we choose R = 2. (a) S = 6. (b) X1 = 1 (c) This also means that DC = {9} from constraint 6, since X5 = 1 we know that X4 + C + R ≥ 10, and from constraint 4 we know that if A = 0, we will violate the alldiff constraint since it would mean that O = G. (d) From constraint 6 we know that if C = 9, then A = 1 which violates the alldiff constraint. (e) We backtrack. 3. We choose R = 4. 9 (a) From constraint 2: DS = {2, 7} (b) From constraint 3: DE = {3, 9} (c) From constraint 6: DC = {8, 9} 4. We now have 3 vars with only 2 values in their domains. So we use MRV and can thus choose randomly. Suppose we choose C = 8. (a) A = 2 (b) E = 3 (c) S = 7 (d) DO = {} from constraint 1,4, and 8. (e) We backtrack 5. Choose C = 9 (a) A = 3 (b) E = 3 (c) We backtrack 6. Using MRV we choose R = 6 (a) DS = {3, 8} from constraint 2 (b) DC = {7, 8, 9} from constraint 6 (c) DE = {0, 4} from constraint 2 (d) DA = {3, 4, 5} from constraint 6 7. Choose S = 3 using MRV (a) E = 4 (b) A = 5 (c) DC = {8, 9} (d) DG = {2, 7} from constraint 4, and c above (e) DN = {8} from constraint 5, and d above, so N = 8 (f) DC = {9} from constraint 5 and 6, so C = 9 (g) O = 2 from constraint 5 (h) DG = {7}, so G = 7 The solution is thus: C = 9, R = 6, O = 2, S = 3, D = 1, A = 5, N = 8, G = 7, E = 4. 9 6 2 3 3 + 6 2 5 1 3 1 5 8 7 4 6 ✓3 for correct domain consistency applied in all cases. ✓2 for appropriate back- tracking (or if none was required this is a bonus mark for correct navigation.) ✓2 for specifying the heuristic and ✓2 for applying it consistently. ✓2 for the correct answer. ✓4 for showing steps. 10 COS3751/202 (5.3) (5)Draw the constraint hypergraph for the puzzle. E ROS D A N G C X1 X2 X3 X4 X5 ✓for correct alldiff node ✓for correct variable nodes ✓for correct aux nodes ✓for correct constraint edges between nodes ✓for correct alldiff edges. Question 6: 30 Marks The problem of assigning registers on a CPU to variables being used in a program is a sim- ple graph-colouring problem (https://en.wikipedia.org/wiki/Register_allocation). Since the CPU has a limited number of registers, during execution, only certain variables can be assigned to these registers. These assignments actually take place during the compiling stage. A developer is free to create as many variables as they want, however, for speed of execution, these variables are in many cases assigned to registers. Figuring out how to assign a program variable to a register is thus an important task, but also (conveniently) expressible as a constraint satisfaction problem. In this case we have registers and program variables. It stands to reason that one cannot simply assign program variables to registers at whim, since in many cases a the executing program may only be using a particular set of program variables (for instance during the execution of different procedures or methods only a certain number of program variables may be competing for register allocation). When there is a possibility of program variables competing for registers, we say these program variables are alive together. And when they are alive together, they cannot be assigned the same register. For a certain program the following holds: 1. There are six variables in use in the program (in different procedures). 2. Program variables A,B, and C are alive together. Program variables C,D,E, and F are alive together, and program variables A,E, and F are alive together. 11 3. There are four registers available for assignment to program variables. (6.1) Rewrite this problem as a CSP by: (a) (7)Deﬁning the variables for this CSP. Remember: don’t get confused with the pro- gram variables and the CSP variables. The variables for the CSP are the variables in the program. The key point is to realise that we want to store each variable inside a register, thus we assign a register to a variable, hence, each program variable becomes a CSP variable. mark each.✓6, ✓for correct notation. X = {A, B, C, D, E, F } (b) (5)Deﬁning the domain for each variable in the CSP. Since this is a classic graph-colouring problem, we chose the domain as the reg- isters, and we represent each register as a colour. That way we can easily colour the graph using colours which will translate directly into register assignment. The colour choice is arbitrary. mark each✓4, ✓for correct notation. Dx∈X = {R, G, B, Y } (c) (11)Deﬁning the constraints for the variables in the CSP. Since we can only place one variable in one register at a time, we can easily rep- resent the constraints using a set of unary constraints. The depiction here is the same as in the textbook: A ̸= B is a shorthand for {< (A, B), [(Red, Blue), (Red, Green), (Red, Yellow), (Blue, Red), (Blue, Green), (Blue, Yellow), (Green, Red), (Green, Blue), (Green, Yellow), (Yellow, Green), (Yellow, Blue), (Yellow, Red)] >} A ̸= B✓, A ̸= C✓, A ̸= E✓, A ̸= F ✓, B ̸= C✓, C ̸= D✓, C ̸= E✓, C ̸= F ✓, D ̸= E✓, D ̸= F ✓, E ̸= F ✓ [alldiff(a,b,c), alldiff(c,d,e,f), alldiff(a,e,f) amounts to the same thing and will get the same marks] (6.2) (7)Provide the solution to this problem if it exists. If no solution exists, explain what parameters from the problem would have to change in order to get to a solution. A solution does exist.✓The provided solution is simply one of many conﬁgurations that are possible. The important thing to see here is that the relationships between the CSP variables are depicted using an edge between the nodes (the nodes, of course, represent the CSP variables). Also notice that nodes that share an edge (that are next to each other) will not be coloured the same colour. 12 COS3751/202 A B C D E F Red Red Yellow Green Blue Green ✓3 for all correct nodes. ✓for correct solution (where binary constrained nodes are of different colour). ✓2 if edges between nodes are correct. Copyright ©UNISA 2016 13","libVersion":"0.2.3","langs":""}