{"path":"Subjects/COS3721 - Operating Systems and Architecture/Unsorted/COS3721/Exam Shit (1)/Exam Shit/Excersizes/COS3721_TL_201_2_2019.pdf","text":"COS3721/201/2/2019 Tutorial Letter 201/2/2019 Solutions to assignment no.1 Operating Systems and Architecture COS3721 Semesters 2 Computer Science Department, School of Computing This tutorial letter contains important information about your module. BARCODE COS3721/101/3/2019 2 SEMESTER 2 Assignment 1 – Semester 2 Due Date: 27 August 2019 Submission Procedure: Written/Typed. Submission online via myUnisa in a PDF format; Chapters in SGG: Chapters 1 – 6 and 18 (section 18.1 and 18.2) Total for this assignment 50 marks Marking scheme Question 1 [09 marks] 1.1.a(1), 1.1.b(1), 1.2(3), and 1.3(3) Question 2 [06 marks] 2.1 (4) and 2.2 (2) Question 3 [10 marks] 3.1 (6) and 3.2 (4) Question 4 [07 marks] 4.1(3) and 4.2 (4) Question 5 [18 marks] 5.1(2), 5.2(2), 5.3(4), 5.4.a(4), 5.4.(b or c)(2) and 5.5(4) Question 1 – Based on Chapter 1 of SGG 1.1 In a multiprogramming and time-sharing environment, several users share the system simultaneously. This situation can result in various security problems. a. What are two such problems? Answer: [ 1 mark] Stealing or copying one’s programs or data; using system resources (CPU, memory, disk space, peripherals) without proper accounting. COS3721/101/3/2019 3 b. Can we ensure the same degree of security in a time-shared machine as in a dedicated machine? Explain your answer. Answer: [2 marks] Probably not, since any protection scheme devised by humans can inevitably be broken by a human, and the more complex the scheme, the more difficult it is to feel confident of its correct implementation. 1.2 How do clustered systems differ from multiprocessor systems? What is required for two machines belonging to a cluster to cooperate to provide a highly available service? Answer: [3 marks] Clustered systems are typically constructed by combining multiple computers into a single system to perform a computational task distributed across the cluster. Multiprocessor systems on the other hand could be a single physical entity comprising of multiple CPUs. A clustered system is less tightly coupled than a multiprocessor system. Clustered systems communicate using messages, while processors in a multiprocessor system could communicate using shared memory. In order for two machines to provide a highly available service, the state on the two machines should be replicated and should be consistently updated. When one of the machines fail, the other could then take-over the functionality of the failed machine. 1.3 Identify several advantages and several disadvantages of open-source operating systems. Include the types of people who would find each aspect to be an advantage or a disadvantage. Answer: [3 marks for 3 correct answers including advantages and/or disadvantages] Open source operating systems have the advantages of having many people working on them, many people debugging them, ease of access and distribution, and rapid update cycles. Further, for students and programmers, there is certainly an advantage to being able to view and modify the source code. Typically, open source operating systems are free for some forms of use, usually just requiring payment for support services. Commercial operating system companies usually do not like the competition that open source operating systems bring because these features are difficult to compete against. Some open source operating systems do not offer paid support programs. Some companies avoid open source projects because they need paid support, so that they have some entity to hold accountable if there is a problem or they need help fixing an issue. Finally, some complain that a lack of discipline in the coding of open source operating systems means that backward compatibility is lacking making upgrades difficult, and that the frequent release cycle exacerbates these issues by forcing users to upgrade frequently. COS3721/101/3/2019 4 Question 2 - Based on Chapter 2 of SGG 2.1 What is the main advantage of the microkernel approach to system design? How do user programs and system services interact in a microkernel architecture? What are the disadvantages of using the microkernel approach? Answer: [4 marks] Benefits typically include the following: (a) adding a new service does not require modifying the kernel, (b) it is more secure as more operations are done in user mode than in kernel mode, and (c) a simpler kernel design and functionality typically results in a more reliable operating system. User programs and system services interact in a microkernel architecture by using interprocess communication mechanisms such as messaging. These messages are conveyed by the operating system. The primary disadvantages of the microkernel architecture are the overheads associated with interprocess communication and the frequent use of the operating system’s messaging functions in order to enable the user process and the system service to interact with each other. 2.2 Explain why Java programs running on Android systems do not use the standard Java API and virtual machine. Answer: [2 marks] It is because the standard API and virtual machine are designed for desktop and server systems, not mobile devices. Google developed a separate API and virtual machine for mobile devices. Question 3 - Based on Chapter 3 of SGG 3.1 Design a file-copying program named filecopy using ordinary pipes. This program will be passed two parameters: the name of the file to be copied and the name of the copied file. The program will then create an ordinary pipe and write the contents of the file to be copied to the pipe. The child process will read this file from the pipe and write it to the destination file. For example, if we invoke the program as follows: filecopy input.txt copy.txt the file input.txt will be written to the pipe. The child process will read the contents of this file and write it to the destination file copy.txt. You may write this program using either UNIX or Windows pipes. Answer: [6 marks] Since a specific programming language was not prescribed for this question, implementation in various languages is expected from students. In addition, a student can use either UNIX or Windows pipes. That is why a model solution is provided here, however, sample programs are given in the prescribed textbook for these two pipes in Fig. 3.25, 3.26, 3.27, 3.28, and 3.29. Students are welcome to discuss their implementation with me or the e-tutor if they have some problems with their own version of the program. COS3721/101/3/2019 5 3.2 Consider the RPC mechanism. Describe the undesirable consequences that could arise from not enforcing either the “at most once” or “exactly once” semantic. Describe possible uses for a mechanism that has neither of these guarantees. Answer: [4 marks] If an RPC mechanism cannot support either the “at most once” or “at least once” semantics, then the RPC server cannot guarantee that a remote procedure will not be invoked multiple occurrences. Consider if a remote procedure were withdrawing money from a bank account on a system that did not support these semantics. It is possible that a single invocation of the remote procedure might lead to multiple withdrawals on the server. For a system to support either of these semantics generally requires the server maintain some form of client state such as the timestamp described in the text. If a system were unable to support either of these semantics, then such a system could only safely provide remote procedures that do not alter data or provide time-sensitive results. Using our bank account as an example, we certainly require “at most once” or “at least once” semantics for performing a withdrawal (or deposit!). However, an inquiry into an account balance or other account information such as name, address, etc. does not require these semantics. Question 4 - Based on Chapter 4 of SGG 4.1 Under what circumstances does a multithreaded solution using multiple kernel threads provide better performance than a single-threaded solution on a single-processor system? Answer: [3 marks] When a kernel thread suffers a page fault, another kernel thread can be switched in to use the interleaving time in a useful manner. A single-threaded process, on the other hand, will not be capable of performing useful work when a page fault takes place. Therefore, in scenarios where a program might suffer from frequent page faults or has to wait for other system events, a multithreaded solution would perform better even on a single-processor system. 4.2 A system with two dual-core processors has four processors available for scheduling. A CPU-intensive application is running on this system. All input is performed at program start-up, when a single file must be opened. Similarly, all output is performed just before the program terminates, when the program results must be written to a single file. Between startup and termination, the program is entirely CPU-bound. Your task is to improve the performance of this application by multithreading it. The application runs on a system that uses the one-to-one threading model (each user thread maps to a kernel thread). COS3721/101/3/2019 6 • How many threads will you create to perform the input and output? Explain. Answer: [2 marks] It only makes sense to create as many threads as there are blocking system calls, as the threads will be spent blocking. Creating additional threads provides no benefit. Thus, it makes sense to create a single thread for input and a single thread for output. • How many threads will you create for the CPU-intensive portion of the application? Explain Answer: [2 marks] Four. There should be as many threads as there are processing cores. Fewer would be a waste of processing resources, and any number > 4 would be unable to run. Question 5 - Based on Chapter 5 & 6 of SGG 5.1 A variation of the round-robin scheduler is the regressive round-robin scheduler. This scheduler assigns each process a time quantum and a priority. The initial value of a time quantum is 50 milliseconds. However, every time a process has been allocated the CPU and uses its entire time quantum (does not block for I/O), 10 milliseconds is added to its time quantum, and its priority level is boosted. (The time quantum for a process can be increased to a maximum of 100 milliseconds.) When a process blocks before using its entire time quantum, its time quantum is reduced by 5 milliseconds, but its priority remains the same. What type of process (CPU-bound or I/O-bound) does the regressive round-robin scheduler favour? Explain. Answer: [2 marks] This scheduler would favor CPU-bound processes as they are rewarded with a longer time quantum as well as priority boost whenever they consume an entire time quantum. This scheduler does not penalize I/O-bound processes as they are likely to block for I/O before consuming their entire time quantum, but their priority remains the same. 5.2 Explain why implementing synchronization primitives by disabling interrupts is not appropriate in a single-processor system if the synchronization primitives are to be used in user-level programs. Answer: [2 marks] If a user-level program is given the ability to disable interrupts, then it can disable the timer interrupt and prevent context switching from taking place, thereby allowing it to use the processor without letting other processes execute. COS3721/101/3/2019 7 5.3 Consider a pre-emptive priority scheduling algorithm based on dynamically changing priorities. Larger priority numbers imply higher priority. When a process is waiting for the CPU (in the ready queue, but not running), its priority changes at a rate α. When it is running, its priority changes at a rate β. All processes are given a priority of 0 when they enter the ready queue. The parameters α and β can be set to give many different scheduling algorithms. a. What is the algorithm that results from β > α > 0? Answer: [2 marks] FCFS b. What is the algorithm that results from α < β < 0? Answer: [2 marks] LIFO 5.4 The following processes are being scheduled using a preemptive, round robin scheduling algorithm. Each process is assigned a numerical priority, with a higher number indicating a higher relative priority. In addition to the processes listed below, the system also has an idle task (which consumes no CPU resources and is identified as Pidle ). This task has priority 0 and is scheduled whenever the system has no other available processes to run. The length of a time quantum is 10 units. If a process is preempted by a higher-priority process, the preempted process is placed at the end of the queue. Thread Priority Burst Arrival P1 20 20 0 P2 15 25 25 P3 30 35 30 P4 15 15 60 P5 5 10 100 P6 10 10 105 a. Show the scheduling order of the processes using a Gantt chart. Answer: [4 marks] Note: pre-emption is performed at the time a higher prioritized process becomes ready for execution. P1 pidle P2 P3 P3 P3 P2 P4 P2 P4 P5 P6 P5 0 20 25 30 40 50 65 75 85 95 100 105 115 120 COS3721/101/3/2019 8 Note: The concepts of Turnaround time and waiting time are explained in SGG, 8th edition, on page 187. Practical formulae, generated from the explanation given in the textbook were included in the tutorial letter 102 available for download on the myUnisa website. Those formulas are: Turnaround time = Time of completion - Time of submission ∑ Waiting time = Turnaround time − ∑ CPU burst time Applying these formulae yields the following results, presented in a tabular form: Marking: please mark b. or c. gives 2 marks for the correct answer. b. What is the turnaround time for each process? Answer: Process Turnaround time P1 (20 - 0) = 20 P2 (95 - 25) = 70 P3 (65 - 30) = 35 P4 (100 - 60) = 40 P5 (120 - 100) = 20 P6 (115 - 105) = 10 c. What is the waiting time for each process? Answer: Process Waiting time P1 (20 – 20) = 0 P2 (70 - 25) = 45 P3 (35 - 35) = 0 P4 (40 - 15) = 25 P5 (20 - 10) = 10 P6 (10 - 10) = 0 d. What is the CPU utilization rate? Answer: [not marked] According to the gantt chart in 5.4.a, the process piddle executes for 5 units of time. So, the CPU utilization rate is: [(120 – 5) / 120] x 100 = 95.83% COS3721/101/3/2019 9 5.5 Assume that a system has multiple processing cores. For each of the following scenarios, describe which is a better locking mechanism – a spinlock or a mutex lock where waiting processes sleep while waiting for the lock to become avail able: Marking: mark only two correct answers. • The lock is to be held for a short duration. Answer: [2 marks] Spinlock • The lock is to be held for a long duration. Answer: [2 marks] Mutex lock • A thread may be put to sleep while holding the lock. Answer: [2 marks] Mutex lock // initialization mutex->available = 0; // acquire using compare_and_swap() void acquire(lock *mutex) { while (compare_and_swap(&m utex->available, 0, 1) != 0) ; return; } // acquire using test_and_set() void acquire(lock *mutex) { while (test_and_set(&mutex- >available) != 0) ; return; } void release(lock *mutex) { mutex->available = 0; return; } COS3721/101/3/2019 10 Figure 5.2 Program for Exercise 6.9. @ Unisa 2019","libVersion":"0.2.3","langs":""}