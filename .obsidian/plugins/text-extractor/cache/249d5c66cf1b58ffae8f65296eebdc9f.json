{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Studocs/downstudocu.com_tut-3-lecture-notes-1.pdf","text":"COS3711/103/3/2019 1 Tutorial letter 103/3/2019 Advanced Programming COS3711 Semesters 1 & 2 School of Computing Networking and the Web 2 CONTENTS Page 1 INTRODUCTION ............................................................................................................................ 3 2 CREATING A SIMPLE WEB BROWSER ...................................................................................... 3 3 HARVESTING THE WEB ............................................................................................................... 5 4 APPLICATION AND WEB INTEGRATION .................................................................................... 8 4.1 Preparing the web page .................................................................................................................. 8 4.2 The application window .................................................................................................................. 9 4.3 Extracting data and showing reports ............................................................................................ 10 4.4 Exposing the calendar .................................................................................................................. 11 4.5 Browser plugin .............................................................................................................................. 12 4.6 Enabling plugins ........................................................................................................................... 12 4.7 The plugin widget .......................................................................................................................... 12 5 NETWORKING CONCEPTS ........................................................................................................ 14 5.1 Protocols ....................................................................................................................................... 14 5.2 QUrl ............................................................................................................................................. 14 5.3 Accessing sockets ........................................................................................................................ 15 5.4  Further reading ............................................................................................................................. 16 5.5 Further notes ................................................................................................................................ 16 6 UDP CHAT ................................................................................................................................... 16 7 USING TCP .................................................................................................................................. 17 8 CONCLUSION .............................................................................................................................. 18 COS3711/103/3/2019 3 1 INTRODUCTION Dear student Much of the work here will be done by example exercises, and you will need to use the files provided that can be downloaded from myUnisa (in UpdatedSourceFiles.zip, under Additional Resources). Text in boxes is of a more theoretical nature, and provides some background to the code in the example exercises. If you would like to read up more on these topics, have a look at the online books that are available through the Unisa library. Go to oasis.unisa.ac.za  Click on Library Links  Search for Information Resources  A-Z list of electronic resources  s  Safari Business and Tech Books Online  In the search box at the top right of the page, search the entire site for “Qt”.  You can then click on a book’s title, which should take you to the Table of Contents for that book. From here you can click on the chapter you want to read. There is some useful material in the following books (among others) that are available there:  Advanced Qt Programming: Creating Great Software with C++ and Qt 4, Mark Summerfield, 2010  C++ GUI Programming with Qt 4, Second Edition, Jasmin Blanchette and Mark Summerfield, 2008  Foundations of Qt Development, Johan Thelin, 2007  Programming with Qt, Second Edition, Matthias Kalle Dalheimer, 2002 Note that some of the information and exercises are based on the Qt in Education material, and as such are provided under the Creative Commons Attribution-Share Alike 2.5 License Agreement. The full license text is available from http://creativecommons.org/licenses/by- sa/2.5/legalcode. 2 CREATING A SIMPLE WEB BROWSER The starting point for this basic web browser application is the webbrowser project in the provided files. When you first build and run it, the project contains a basic implementation that shows a window with some widgets. The provided header files looks as follows. #include <QWidget> #include <QUrl> class QLineEdit; class QToolButton; class QWebView; class WebBrowser : public QWidget { Q_OBJECT public: WebBrowser(QWidget *parent = 0); signals: public slots: void loadPage(); void updateAddressBar(const QUrl &url); 4 private: QLineEdit *addressBar; QToolButton *backButton; QToolButton *forwardButton; QToolButton *reloadButton; QWebView *browser; }; The first task is to add a QWebView widget to the design to act as the browser window. There is already a member variable, , for holding it in the header file, so instantiate a browser QWebView widget and hold the pointer in the browser variable. Also, add the browser window to the mainLayout. Next, you will take care of the back, forward and reload buttons. See the following code for the back button that sets the button’s default action (using a QAction object). backButton->setDefaultAction(browser->pageAction(QWebPage::Back)); For this button, the QAction object is retrieved from the QWebView. Using the browser’s pageAction() Back Forward Reload function, you can set the appropriate actions ( , and ) which are defined in the QWebPage class. Do this for all buttons to implement the actions back forward, and reload. This should give the buttons an icon, some text and functionality. Now make your browser load the URL provided by the user in the address bar (when enter is pressed in the address bar) so that you can view the web page. There is already the statement in the code that connects the returnPressed addressBar signal from the to the loadPage slot. You need to add code to the loadPage() function to do this. Ask the QWebView object to load the URL. browser->load(QUrl::fromUserInput(addressBar->text())); As the addressBar’s text() function returns a QString, you need to convert that string to a proper URL: use QUrl::fromUserInput() to do that transformation. You should now be able to use the browser for basic browsing. Letting the user set the URL only solves half the problem. Web pages sometimes redirect the browser. To handle this, connect the urlChanged(QUrl) signal from the browser to the updateAddressBar(QUrl) updateAddressBar slot. In the slot, set the text of the address bar to the given URL. You can convert a QUrl object to a QString using the toString method. See Figure 1 for an example of the simple browser program running. Viewing a web page To view a web page, you need a QWebView object, and then load a QUrl into this object. For example: QWebView* view = new QWebView(); view->load(QUrl(\"www.unisa.ac.za\")); COS3711/103/3/2019 5 Figure 1 The simple browser window In this exercise, you have used the following new Qt classes to build you basic browser.  QWebView (provides a widget that is used to view and edit web documents)  QWebPage (provides an object to view and edit web documents)  QUrl (provides a convenient interface for working with URLs) You can read up on these in the Qt Assistant for more details. 3 HARVESTING THE WEB Providing users with web browsing abilities is good. However, it is also interesting to be able to traverse the web programmatically. The imagespider project is a starting point for an application that acts like a web browser, but also harvests images from the web pages visited (see Figure 2). Figure 2 The imagespider project The idea is that the scanPageForImages slot is called as soon as a page has been loaded. It 6 extracts all img tags and extracts the src attributes from them, populating the list of images to the right. The code for the constructor (which is essentially where the webbrowser project ended) is given below. #include <QWidget> #include <QUrl> class QLineEdit; class QToolButton; class QWebView; class QListView; class WebBrowser : public QWidget { Q_OBJECT public: WebBrowser(QWidget *parent = 0); signals: public slots: void loadPage(); void updateAddressBar(const QUrl &url); private slots: void scanPageForImages(); private: QLineEdit *addressBar; QToolButton *backButton; QToolButton *forwardButton; QToolButton *reloadButton; Accessing the DOM from Qt The DOM is accessible through the QWebElement class. Each QWebFrame contains a documentElement which is the root element of the frame. QWebView* view = new QWebView(); QWebFrame* frame = view->page()->currentFrame(); QWebElement documentRoot = frame->documentElement(); From each QWebElement it is possible to:  Traverse o firstChild – returns the first child element o nextSibling – returns the next sibling element o isNull – is true if there are no children/siblings  Search o findFirst and findAll – takes a CSS2 selector as an argument e.g. img or p QWebPage QWebFrame QWebElement QWebView COS3711/103/3/2019 7 QWebView *browser; QListView *imageList; }; WebBrowser::WebBrowser(QWidget *parent) : QWidget(parent) { addressBar = new QLineEdit(this); backButton = new QToolButton(this); forwardButton = new QToolButton(this); reloadButton = new QToolButton(this); backButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon); forwardButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon); reloadButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon); connect(addressBar, SIGNAL(returnPressed()), this, SLOT(loadPage())); QHBoxLayout *toolsLayout = new QHBoxLayout; toolsLayout->addWidget(backButton); toolsLayout->addWidget(forwardButton); toolsLayout->addWidget(reloadButton); toolsLayout->addWidget(addressBar); QVBoxLayout *mainLayout = new QVBoxLayout(this); mainLayout->addLayout(toolsLayout); browser = new QWebView(this); connect(browser, SIGNAL(urlChanged(QUrl)), this, SLOT(updateAddressBar(QUrl))); imageList = new QListView; QSplitter *splitter = new QSplitter; splitter->addWidget(browser); splitter->addWidget(imageList); mainLayout->addWidget(splitter); backButton->setDefaultAction(browser->pageAction(QWebPage::Back)); forwardButton->setDefaultAction(browser->pageAction(QWebPage::Forward)); reloadButton->setDefaultAction(browser->pageAction(QWebPage::Reload)); } First, you need to connect the scanPageForImages slot to the loadFinished(bool) signal of the QWebView. connect(browser, SIGNAL(loadFinished(bool)), this, SLOT(scanPageForImages())); In the scanPageForImages() slot, the plan is to retrieve all img tags and add their src attributes to the images string list. To be able to access the img elements, you first need access to the main frame of the web page. You get it through the web view as shown below. QWebFrame* frame = browser->page()->mainFrame(); From the frame a QWebElementCollection can be retrieved using the findAllElements(\"img\") function. You can iterate over every QWebElement using the foreach attribute src macro. For each element, use the function to retrieve the value of the attribute. Append this value to the string list. foreach(QWebElement we, elements) { QString src = we.attribute(\"src\"); if (!src.isEmpty()) images.append(src); } 8 When visiting a web page, once the page has fully loaded, the list to the right should fill with image paths – you have harvested the page of its images. Note that the solution uses a model- view approach to presenting the data in the window. You can read up on the following in the Qt Assistant:  QWebFrame, and its functions currentFrame and mainFrame  QWebElement, and its functions findFirst, findAll, and findAllElements  QWebCollection 4 APPLICATION AND WEB INTEGRATION This exercise focuses on combining regular desktop application features with the technology of the Web, building a hybrid application. This involves both mixing the web with application contents, as well as gathering da ogramatically. You will find the base files ta from the web pr needed for this application in the appweb folder in the files that you downloaded from myUnisa. You will implement an application that shows a report of activities for a given period of time. The report will be delivered to the user in form of a web page and shown inside the application (see Figure 3). The program will extend the page with the ability to control what is shown and how it is shown. Figure 3 The hybrid application window 4.1 Preparing the web page For this project, you will use a simple static HTML file as the report. In a real world setting, you would most likely get the report from a web server. A simple web page is provided (or you can create a similar one using a text editor of your choice): myweb.html. You can tweak backgrounds, styles and decorations and add other content if you like. You need to make sure to place a set of tags with a format described below so that your <div> application can detect them and work on their content. COS3711/103/3/2019 9 <html> <body> <div class=\"report\" id=\"report_10_07_12\"> <h2>Report for 10-July-2012</h2> <div class=\"reportcontent\"> <p>Doing exercises in reading and listening.</p> <table><tr> <td><object type=\"application/x-chart\" width=\"300\" height=\"150\"> <param name=\"title\" value=\"Reading\"/> <param name=\"value\" value=\"45\"/> </object> </td> <td><object type=\"application/x-chart\" width=\"300\" height=\"150\"> <param name=\"title\" value=\"Writing\"/> <param name=\"value\" value=\"90\"/> </object> </td> </tr></table> </div> </div> <div class=\"report\" id=\"report_ 2\"> <h2>Report for 12-July-2012</ > <div class=\"reportcontent\"> <p>Doing the dishes.</p> <object type=\"application/x-chart\" width=\"300\" height=\"150\"> <param name=\"title\" value=\"Dishes\"/> <param name=\"value\" value=\"20\"/> </object> </div> </div> </body> </html> 4.2 The application window A Qt application project is provided with a user interface derived from QMainWindow; it contains a QCalendarWidget and a QWebView in a horizontal layout. You will see that WebKitWidgets support is enabled in the .pro file. There is also an action for loading the report file added to a menu. Connect its triggered() signal to the loadFile() slot. In this slot, a proper URL is created from a file path (or you can embed the web page in a resource file and use a url pointing there; it should have a qrc:/ prefix). Note that you will have to change the file path to indicate where you have saved the myweb.html QWebView::load() file. Then the web page is loaded using . Try running the application to verify that the web page loads into the view. In case of problems make sure the path you use is correct and the file is readable for the user, and that there are no spaces in the path name. It is good practice to disable all the components the user should not interact with at a given state of the application. In this case it is a good idea to set the “enabled” property of the calendar widget to false when the application is started and only enable the widget when it becomes useful to the user. This will happen when the page is loaded into the browser window.  Each div tag contains an id attribute with a value in format report_day_month_year where the “day”, “month” and “year” parts are substituted with two digit numbers specifying the day of the month, the month of the year and the two last digits of the year.  Each div tag contains a class attribute with the value of report for easy detection of reports.  Each tag contains a div child container with a mandatory class reportcontent attribute set to ; the web page may contain styling information for the reportcontent class such as back ground, border, etc.  Each of the child div tags can (optionally) contain any textual description of activities performed on this particular day.  Each of the child div tag can contain object tags for describing the custom object that is to be embedded in the web page using a browser plugin; the tag has the format shown below where width and height attributes specify the size of the chart and title and value parameters specify the title of the chart and percentage of progress to be shown in the chart. 10 4.3 Extracting data and showing reports Having loaded and shown the page in question, the next step is to extract the relevant data from the web page. Connect the loadFinished() signal of the QWebView object to the changeFile() slot. This will let you perform tasks when the page is fully loaded. What the slot needs to do is to access the main frame of the page displayed in the view and find all elements representing reports. Firstly, get hold of the frame. QWebFrame* frame = webView->page()->mainFrame(); Use QWebFrame::findAllElements() to get a collection of all div tags with class attribute report div.report (using ). QWebElementCollection divReports = frame->findAllElements(\"div.report\"); Iterate over the collection and match values of the id attribute against a regular expression detecting the dates associated with reports. foreach (QWebElement report, divReports) { QString id = report.attribute(\"id\"); QRegExp dateRegEx(\"report_(\\\\d+)_(\\\\d{1,2})_([0-9]{1,2})\"); if(!dateRegEx.exactMatch(id)) continue; QDate date(2000+dateRegEx.cap(3).toInt(), dateRegEx.cap(2).toInt(), dateRegEx.cap(1).toInt()); ... } Store the dates and corresponding QWebElement objects in the map dateElement (it is a private class member) where the date is the key and the web element is the value of the entry. This will let you have quick access by date to all available reports. dateElement.insert(date, report); While you process the elements you should do two more things.  First, access the report element's child tag div with class reportcontent and use QWebElement::setStyleProperty() display to set the style attribute to none. This effectively hides the elements that have been processed from the web page. report.findFirst(\"div.reportcontent\").setStyleProperty(\"display\", \"none\"); The other thing to do is to provide a visual hint on the calendar widget that a report is available for a particular date. Use the QCalendarWidget::setDateTextFormat() method to do so. You can change the background, foreground color or even the font for any given date. QTextCharFormat highlight; ... highlight.setBackground(Qt::red); cal->setDateTextFormat(date, highlight); If you disabled the calendar wi ng of the page, this is a good moment to dget during the loadi enable it again. cal->setSelectionMode(QCalendarWidget::SingleSelection); It is good practice to to always start with a clean state of all objects you work with before you start filling them with data. Clear the map dateElement of date-report associations and revert all custom formatting of the calendar widget so that your code still works properly if it gets called again and again (e.g. when the user requests a page refresh). highlight.clearBackground(); dateElement.clear(); COS3711/103/3/2019 11 QMap<QDate, QTextCharFormat> changed = cal->dateTextFormat(); QMapIterator<QDate, QTextCharFormat> i(changed); while (i.hasNext()) { i.next(); cal->setDateTextFormat(i.key(), highlight); } If you run the application now, you should get a list of all report titles, but all the report contents should be hidden. The missing feature is to show the contents of a given report when the corresponding date is selected in the calendar widget. The calendar widget's selectionChanged() signal tells you when a new date has been picked. Connect it to the dateSelected() slot. In the slot, retrieve the report element from the map dateElement based on the date selected in the calendar widget and set the display style property of the report's container to block. QWebElement selReport = dateElement.value(cal->selectedDate()); ... selReport.findFirst(\"div.reportcontent\").setStyleProperty(\"display\", \"block\"); You should also collapse the previously opened report. To do that, you need to keep track of the currently shown report. You could scan the collection of available reports and determine which one is visible, but it is much easier to store the last opened report element (or its date) in a member variable: here the currentReport variable has been used. This way you can immediately perform the operation of hiding the old report when you open the new one. Remember to update the state of the variable you just created when reloading the page or opening a new report. At this point reports should be shown and hidden as dates in the calendar widget are clicked. currentReport.findFirst(\"div.reportcontent\").setStyleProperty(\"display\", \"none\"); ... currentReport = selReport; 4.4 Exposing the calendar To complete the user experience, it should also be possible to expand each report by interacting with the web page. It is possible to change the display style attribute from a script run in the web page, but this would put the calendar widget out of sync with the shown contents. A better solution is to make the calendar API available to the script. All that is needed to make that happen is to add it as a global object in the JavaScript scope. You do that using the addToJavaScriptWindowObject call. The frame is the object retrieved during the data extraction phase (which is where you can place the above code as well). frame->addToJavaScriptWindowObject(\"calendar\", cal, QWebFrame::QtOwnership); When adding an object to the JavaScript scope, all the properties and slots of the object in question become available from within the web page. This makes it possible to add code to the web page that interacts with QObjects. For instance, the following code in the html file changes the date of the calendar widget. <input type=\"button\" value=\"Open\" onClick=\"calendar.selectedDate = '2012-07-10';\"/> As the date is changed, the selectionChanged() signal is emitted. This in turn triggers the same code path that is used when the user interacts directly with the widget. Now add buttons to your web page that allow changing the current show report using the above as an example. 12 In real life the web page would probably contain a library of scripts that would be enabled or disabled depending on whether the web page was accessed from within a 'real' web browser (so that all the basic functionality of the web was present) or from a hybrid application like here. 4.5 Browser plugin The last integration between the web page and the application is to embed a Qt widget in the web page. This is achieved by implementing a plugin that handles the mime-type application/x-chart. To embed a widget in a web page, the following is required: Plugin loading needs to be enabled for the web page  The chart widget needs to be implemented  The chart widget needs to be exported as a browser plugin handling application/x-chart data type. These steps will now be implemented. 4.6 Enabling plugins Enabling plugins is the easiest part. Each web page in has a settings object QtWebKitWidgets of the class QWebSettings associated with it. You can manipulate this object to control the behavior of the page. One of the attributes that can be set is PluginsEnabled. Set it to true to allow WebKit to use plugins. This manipulates settings for a particular QWebPage object only. You can also change settings for all web pages by accessing the QWebSettings::globalSettings() static method that gives you access to the global settings. Do this when a page is loaded. webView->page()->settings()->setAttribute(QWebSettings::PluginsEnabled, true); 4.7 The plugin widget The widget that you will plug in should show a pie chart, which is used to show the percentage of the work done along with the title of the task. An example of the widget is shown in Figure 4. Figure 4 The PieChart widget A PieChart widget is included in the base files that you downloaded from myUnisa. You can obviously implement one of your own if you want to – it would be a good exercise. Make sure that you create the properties QString title int value and and provide proper setters and getters for them. You can use QFontMetrics to calculate the space taken by the title so that the pie does not intersect with the text and is neatly centred. 4.8 The browser plugin COS3711/103/3/2019 13 To export a plugin to webkit, you have to provide an implementation of the QWebPluginFactory interface. This couples the widget class with a mime-type. By referring to the mime-type in the web page, you will tell webkit to use your widget. Remember the object tag in the html file, as you will be needing it here. <object type=\"application/x-chart\" width=\"300\" height=\"150\"> <param name=\"title\" value=\"Reading\"/> <param name=\"value\" value=\"45\"/> </object> Start by subclassing QWebPluginFactory. Implement the plugins() method to return a list of Plugin objects, describing the plugins exported by the factory. In this case, the list will contain only one item that describes the chart plugin. class ChartPluginFactory : public QWebPluginFactory { public: ChartPluginFactory(); QList<QWebPluginFactory::Plugin> plugins() const; QObject* create(const QString &mimeType, const QUrl &, const QStringList &argumentNames, const QStringList &argumentValues) const; }; QList<QWebPluginFactory::Plugin> ChartPluginFactory::plugins() const { QWebPluginFactory::Plugin chart; chart.name = QString(\"application/x-chart\"); chart.description = QString(\"Draws a pie chart\"); QList<QWebPluginFactory::Plugin> list; list.append(chart); return list; } As each plugin can handle more than one mime-type, the description object contains a field of MimeType application/x-chart objects. You only handle so this list will also contain only one item. You only need to fill the name of the mime-type. It is good practice to provide a name and a short description for the plugin object. There are many standard mime-types out there like application/pdf, image/jpeg or text/plain. There is also a need for custom mime-types. To distinguish between standard mime-types and custom ones, there is a convention that all custom types contain a 'x-' prefix. Unless there is a strong reasoning behind doing otherwise they should belong to the group 'application'. This prevents potential name clashes with any standard types that might be introduced in the future. The second part of the plugin factory interface that needs to be implemented is the create() method. In it, you should instantiate the PieChart widget based on the mime-type given. Also initialize it using the provided url and a set of arguments described by the method parameters. Since the widget in this case does not work on any external data, the url can be ignored. Argument names and values correspond to param child tags of the html object tag requesting the plugin. It is important that you only create the widget if the mime-type passed as an argument to create matches the type you really support. In all other cases you should return 0. if (mimeType == \"application/x-chart\") { 14 ... } else return 0; If the type is supported, create an instance of the chart widget PieChart* pc = new PieChart(); and scan the list of argument names for the ones you support (i.e. title and value). For example int index = argumentNames.indexOf(\"value\"); Use the PieChart widget's API to set these values on the widget. Note that all the values are given as strings so you might have to convert some of them to proper types. int percent = argumentValues.at(index).toInt(); pc->setValue(percent); As has been shown here for value, do the same for title. When the widget has been setup, return it so that webkit can place it in the web page. return pc; The last step is to inform your application that your plugin factory exists. You do that by calling the setPluginFactory function once. You can do that in your main window constructor. webView->page()->setPluginFactory(new ChartPluginFactory()); Now, run the application to see the final result. You can read up on the following in the Qt Assistant:  QCalendarWidget  QWebElement  QWebElementCollection  QTextCharFormat  QWebSettings  QPainter  QFontMetrics  QWebPluginFactory 5 NETWORKING CONCEPTS 5.1 Protocols Browsing the web uses the HTTP protocol (hypertext transfer protocol), and it may be encrypted as https. HTTP is built on top of TCP (transmission control protocol), which in turn is built on top of IP (internet protocol). Other protocols, such as FTP, SMTP, POP, and IMAP are also built on top of TCP/IP. 5.2 QUrl The QUrl class can be used to split a URL into its parts. See Figure 5 (adapted from the Qt Assitant) to see the various parts of the URL. f t p : / / f t p . q t . n o k i a . c o m : 2 0 2 1 scheme host port COS3711/103/3/2019 15 h t t p : / / q t - p r o j e c t . o r g / d o w n l o a d s # q t - o t h e r h t t p : / / q t . n o k i a . c o m / p r o d u c t s / q t - f o r - m o b i l e - p l a t f o r m s f t p : / / p e r s o n : Q 3 d f r 4 _ $ 5 @ f t p . q t . n o k i a . c o m : 2 0 2 1 Figure 5 functions to access a URL QUrl 5.3 Accessing sockets Qt supports accessing TCP and UDP directly at socket level. See Table 1 for a comparison of TCP and UDP sockets. TCP Sockets UDP Sockets Guaranteed in-order delivery Fire and forget Point-to-point only Point-to-point or broadcasts Great when correct delivery is important Great when time is more important than delivery Table 1 Comparison of TCP and UDP sockets There are two TCP classes in Qt: QTcpSocket – representing a socket  QTcpServer – representing a server, listening for incoming connections, generating QTcpSocket instances for each connection However, TCP/IP traffic is easy to overhear. Qt thus provides QSslSocket to use encrypted TCP sockets (using connectToHostEncrypted). SSL (secure sockets layer) is a layer on top of TCP which relies on certificate authorities. The QUdpSocket provides a UDP (user datagram protocol) socket that is usable for both clients and servers. Datagrams are sent as one block, and the following should be borne in mind.  512 bytes is okay, 8192 bytes usually work, larger might be possible  Can arrive or not  Can arrive out of order  Can arrive in duplicates fragment path userName password userInfo 16 5.4 Further reading You should also read through the section on Networking and Connectivity in the Qt Reference Documentation in the Qt Assistant (see Figure 6). Figure 6 Finding Network Programming 5.5 Further notes All Qt classes used for networking are a part of the QtNetwork module. You need to include the module in your build process by telling qmake that you are using it (add the line QT += network to your project file). 6 UDP CHAT The simple web browser and harvesting the web exercises above relied on the HTTP protocol, which is based on TCP/IP. For this exercise you will use UDP datagrams over IP directly. Use the udpchat project as the starting point. The application provides a chat program user interface and the functions needed to implement a simple network chat system. The goal for this step is to add the UDP networking functions needed to transmit and receive messages. Figure 7 The utp chat program Start by implementing the startNetworking() function. In it create a UDP socket and store the pointer to the socket in the member variable. Then bind socket it to the given port and the COS3711/103/3/2019 17 broadcast host address. Make sure to pass the QUdpSocket::ShareAddress bind mode flag when binding the socket, so that you can run another copy of your program on the same machine for testing purposes. Use the following to bind the socket. socket->bind(QHostAddress::Broadcast, socketPort, QUdpSocket::DefaultForPlatform); You may find that this does not work, so you can try one of the other overloaded versions of the bind call to achieve the binding. socket->bind(socketPort, QUdpSocket::ShareAddress); Having created the socket, connect the readyRead signal of the socket to the processPendingDatagrams slot to receive notifications whenever a new datagram arrives. The function should now contain the following. void UDPChat::startNetworking(int port) { socketPort = port; socket = new QUdpSocket(); socket->bind(QHostAddress::Broadcast, socketPort, QUdpSocket::DefaultForPlatform); //socket->bind(socketPort, QUdpSocket::ShareAddress); //one of the bind calls connect(socket, SIGNAL(readyRead()), this, SLOT(processPendingDatagrams())); } In the processPendingDatagrams slot, use the following code to read the next datagram into a buffer. QByteArray buffer; buffer.resize(socket->pendingDatagramSize()); socket->readDatagram(buffer.data(), buffer.size()); Now use the provided decodeMessage function to convert the buffer contents into a pair of strings that carry the nickname of the sender and the message body. QPair<QString,QString> msg = decodeMessage(buffer); Pass these onto the provded showMessage function with appropriate parameters as shown below to have the message displayed in the window. showMessage(msg.first, msg.second); Finally implement the sendMessage() slot. Use the provided encodeMessage function to convert the (nick, message) pair into an opaque byte array and broadcast the message through the socket using the writeDatagram function. Broadcast to all on the network by providing the host address QHostAddress::Broadcast. QByteArray msg = encodeMessage(nick->text(), message->text()); socket->writeDatagram(msg, QHostAddress::Broadcast, socketPort); You should now be able to run two chat programs and communicate from one to the other. Note that you may find that only the one chat window will pick up messages from the port and display them although both chat windows can send messages. Tip: You might have to open your firewall to be able to broadcast to port 34567 (or whichever port number you are using if not using the default port number) in your local network. Notice that you need to open UDP port 34567, not the TCP port with the same number. 7 USING TCP Work through the Fortune server and client examples in the Qt Assistant. To access these, open the Assistant, go to the Index tab, and type “fortune” into the search box. Click on Fortune Server Example, and once you have worked through this, you will find a link near the top of the example to the Fortune Client Example. 18 To create the project for each of these (they must be two separate projects), create a new project, and choose Qt Widgets Application. The only line you really need in the .pro file is QT += network as the other entries (for headers and sources) will be added automatically. You can then copy the code for the class and main files from the Assistant example and paste it into files that you create in the project. However, you can also copy the files from examples provided with Qt (C:\\Qt\\Qt5.3.0\\Examples\\Qt-5.3\\network\\fortuneserver and C:\\Qt\\Qt5.3.0\\Examples\\Qt-5.3\\network\\fortuneclient). Note that you should run the server before starting the client, and that you may need to grant it access through the firewall. You can see a running version in Figure 8. When you run the server and client, they will have the same server name/IP address, and the server will indicate a port number. You can change the server name of the client if you want to (as has been done in the example in Figure 8 – it would only work using the localhost address – as the server listens on all addresses), but make sure that you type the same port number from the server into the client window before you click Get Fortune. Figure 8 Fortune client and server 8 CONCLUSION This tutorial letter is meant as a basic guide to network programming and a pointer to where you can find more information about the topic. It is by no means exhaustive, and you will only be expected to know the general processes involved rather than all the intricate details. © UNISA 2019","libVersion":"0.2.3","langs":""}