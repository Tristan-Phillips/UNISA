{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Notes/COS3711-Combined-Notes.pdf","text":"Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588   COS3711 Summary  For: An Introduction to Design Patterns in C++ with Qt  By: Wilco Breedt      Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588   1. Reflection 2 2. Validation 5 3. XML 7 4. MV/MVC - Model View Architecture 8 5. Momento 13 6. Concurrency 15 7. Singleton 17 8. UML 18 9. Factory Method 19 10. Notes 20   COS3711 Wilco Breedt 1 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 1. Reflection 1. Inherit QObject  2. Q_OBJECT Macro  3. Q_PROPERTY(int size READ getSize WRITE setSize)  4. Q_PROPERTY(type name READ getter WRITE setter)  5. MOC (Meta Object Compiler) Looks for QOBJECT Macro and compiles a meta object file. Before RUNTIME.  6. Dynamic Properties (When you use setProperty and the property you are trying to set was NOT in the class  Q_PROPERTY declared by yourself. This means you cannot use the QMetaProperty to get these values  because Dynamic properties are created at RUNTIME where static properties are created BEFORE RUNTIME  when the MOC generates the MetaObject for the class  7. QMetaObject - Object that carries meta data about another object (QObject) Used for reflection  8. Static Properties - Defined in the class - Information about static properties are created at compile time and  exist within QMetaObject  9. Dynamic Properties- Defined outside the class - created at runtime and you cannot obtain information about  them using the QMetaObject     ===================================image.h===================================   #ifndef​ ​IMAGE_H  #define​ ​IMAGE_H  #include​ ​<QObject>    class​ ​Image​:​ ​public​ ​QObject​ ​//​ ​Inherit​ ​from​ ​QObject  {  ​Q_OBJECT​ ​//​ ​QOBJECTMacro​ ​(MOC)  ​Q_PROPERTY​(​int​ ​size​ ​READ​ ​getSize​ ​WRITE​ ​setSize)​ ​//​ ​Q_PROPERTY​ ​(MOC)  ​Q_PROPERTY​(​QString​ ​name​ ​READ​ ​getName​ ​WRITE​ ​setName)​ ​//​ ​Q_PROPERTY​ ​(MOC)    ​public​:  ​Image​();  ​int​ ​getSize();  ​void​ ​setSize(​int​ ​s);  ​QString​ ​getName();  ​void​ ​setName(​QString​ ​s);    ​private​:  ​int​ ​length​;​ ​//​ ​Q_PROPERTY(int​ ​size​ ​...)​ ​This​ ​does​ ​not​ ​have​ ​to​ ​be​ ​the​ ​same​ ​as​ ​the​ ​Q_PROPERTY​ ​that​ ​gets​ ​its​ ​value  ​QString​ ​name​;  };  #endif​ ​//​ ​IMAGE_H    ===================================image.cpp===================================   #include​ ​\"image.h\"    Image​::Image() {}  void​ ​Image​::setSize(​int​ ​s)​ ​{  ​length​ ​=​ ​s;  }  int​ ​Image​::getSize()​ ​{  ​return​ ​length​;  }  void​ ​Image​::setName(​QString​ ​s)​ ​{  ​name​ ​=​ ​s;  }  QString​ ​Image​::getName()​ ​{  ​return​ ​name​;  }  COS3711 Wilco Breedt 2 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 ====================================main.cpp===================================    #include​ ​<QCoreApplication>  #include​ ​<QDebug>  #include​ ​<QMetaProperty>  #include​ ​\"image.h\"    void​ ​printObject(​QObject​ ​*obj)​ ​{​ ​//​ ​Method​ ​that​ ​uses​ ​reflective​ ​techniques  ​const​ ​QMetaObject​ ​*meta​ ​=​ ​obj->​metaObject​();  ​QString​ ​className​ ​=​ ​meta->className();  ​QString​ ​result​ ​=​ ​\"\"​;    ​//​ ​Static​ ​Properties​ ​(​ ​Was​ ​declared​ ​by​ ​yourself​ ​in​ ​the​ ​Q_PROPERTY​ ​of​ ​the​ ​class​ ​)​ ​(Declared​ ​at​ ​compile​ ​time)  ​//​ ​for​ ​(int​ ​i​ ​=​ ​meta->propertyOffset();​ ​i​ ​<​ ​meta->propertyCount();​ ​i++)​ ​Get​ ​rid​ ​of​ ​properties​ ​in​ ​base​ ​class  ​for​ ​(​int​ ​i​ ​=​ ​0​;​ ​i​ ​<​ ​meta->propertyCount();​ ​i++)  ​{  ​//​ ​First​ ​method​ ​to​ ​get​ ​value​ ​of​ ​meta​ ​property  ​const​ ​QMetaProperty​ ​metaProp​ ​=​ ​meta->property(i);  ​const​ ​char​ ​*name​ ​=​ ​metaProp.name();​ ​//​ ​Get​ ​the​ ​name​ ​of​ ​the​ ​meta​ ​property  ​QVariant​ ​value​ ​=​ ​obj->property(name); ​//​ ​Get​ ​the​ ​value​ ​of​ ​the​ ​meta​ ​property    ​//​ ​Convert​ ​meta​ ​property​ ​name​ ​to​ ​QString​ ​if​ ​you​ ​have​ ​to  ​//​ ​QString​ ​name​ ​=​ ​QString(metaProp.name());    ​//​ ​Second​ ​method​ ​to​ ​get​ ​value​ ​of​ ​meta​ ​property  // const QMetaProperty metaProp = meta->property(i);  ​//​ ​QVariant​ ​value​ ​=​ ​metaProp.read(obj);  ​result​ ​+=​ ​QString​(​\"%1​ ​%2​ ​\"​).arg(name).arg(value.toString());  ​}  ​//​ ​Dynamic​ ​Properties​ ​(Wasn’t​ ​declared​ ​in​ ​the​ ​Q_PROPERTY/​ ​Declared​ ​at​ ​RUNTIME)  ​foreach​(​QByteArray​ ​dynamicPropName,​ ​obj->dynamicPropertyNames())​ ​{  ​QVariant​ ​value​ ​=​ ​obj->property(dynamicPropName);  ​result​ ​+=​ ​QString​(​\"%1​ ​%2​ ​\"​)  ​.arg(​QString​(dynamicPropName))  ​.arg(value.toString());  ​}  ​qDebug​()​ ​<<​ ​result​ ​<<​ ​endl;  }  COS3711 Wilco Breedt 3 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 QString​ ​toString(​QList​<​Image​*>​ ​list)​ ​{  ​QStringList​ ​merge;  ​foreach​(​Image​ ​*i,​ ​list)​ ​{  ​const​ ​QMetaObject​ ​*metaObj​ ​=​ ​i->​metaObject​();  ​for​ ​(​int​ ​in​ ​=​ ​0​;​ ​in​ ​<​ ​metaObj->propertyCount();​ ​in++)​ ​{  ​const​ ​QMetaProperty​ ​metaProp​ ​=​ ​metaObj->property(in);  ​const​ ​char​ ​*name​ ​=​ ​metaProp.name();  ​QVariant​ ​value​ ​=​ ​i->property(name);  ​merge.append(​QString​(​\"Name​ ​%1,​ ​Value​ ​%2\"​).arg(name).arg(value.toString()));  ​}  ​foreach​(​QByteArray​ ​dynamicPropName,​ ​i->dynamicPropertyNames())​ ​{  ​QVariant​ ​value​ ​=​ ​i->property(dynamicPropName);  ​merge.append(​QString​(​\"DName​ ​%1,​ ​Value​ ​%2\"​).arg(​QString​(dynamicPropName)).arg(value.toString()));  ​}  ​}  //​ ​If​ ​the​ ​Object​ ​is​ ​not​ ​a​ ​pointer​ ​(Image​ ​*i)​ ​->​ ​Image​ ​i  //​ ​foreach(Image​ ​i,​ ​list)​ ​{  //​ ​const​ ​QMetaObject​ ​metaObj​ ​=​ ​i.metaObject();  //​ ​for​ ​(int​ ​in​ ​=​ ​0;​ ​in​ ​<​ ​metaObj.propertyCount();​ ​in++)​ ​{  //​ ​const​ ​QMetaProperty​ ​metaProp​ ​=​ ​metaObj.property(in);  //​ ​const​ ​char​ ​*name​ ​=​ ​metaProp.name();  //​ ​QVariant​ ​value​ ​=​ ​i.property(name);  //​ ​merge.append(QString(\"Name​ ​%1,​ ​Value​ ​%2\").arg(name).arg(value.toString()));  //​ ​}  //​ ​foreach(QByteArray​ ​dynamicPropName,​ ​i.dynamicPropertyNames())​ ​{  //​ ​QVariant​ ​value​ ​=​ ​i.property(dynamicPropName);  //​ ​merge.append(QString(\"DName​ ​%1,​ ​Value​ ​%2\").arg(QString(dynamicPropName)).arg(value.toString()));  //​ ​}  //​ ​}  ​qDebug​()​ ​<<​ ​merge.join(​\";\"​)​ ​<<​ ​endl;  ​return​ ​merge.join(​\";\"​);  }  int​ ​main(​int​ ​argc,​ ​char​ ​*argv[])  {  ​QCoreApplication​ ​a(argc,​ ​argv);  ​Image​ ​*img​ ​=​ ​new​ ​Image​();  ​//​ ​Setting​ ​values  ​img->setProperty(​\"name\"​,​ ​\"Wilco.png\"​);​ ​//​ ​img->setName(\"Wilco\");  ​img->setProperty(​\"size\"​,​ ​100​);​ ​//​ ​img->setSize(100);  ​img->setProperty(​\"name2\"​,​ ​\"Wilco2.png\"​);​ ​//​ ​Dynamic​ ​Property  ​//​ ​Getting​ ​Values  ​int​ ​imageSize​ ​=​ ​img->property(​\"size\"​).toInt();​ ​//​ ​->property​ ​returns​ ​QVariant  ​//​ ​OR  ​QVariant​ ​name​ ​=​ ​img->property(​\"name\"​);​ ​//​ ​->property​ ​returns​ ​QVariant  ​QString​ ​imageName​ ​=​ ​name.toString();​ ​//​ ​Convert​ ​to​ ​QString  ​qDebug​()​ ​<<​ ​imageName​ ​<<​ ​imageSize​ ​<<​ ​endl;​ ​//​ ​Log​ ​to​ ​debug​ ​console  ​printObject(img);    ​Image​ ​img2;​ ​//​ ​Image​ ​*img2​ ​(If​ ​you​ ​want​ ​to​ ​make​ ​it​ ​a​ ​pointer)  ​img2.setName(​\"Woohoo\"​);​ ​//​ ​img2->setName(\"Woohoo\")  ​img2.setSize(​100​);​ ​//​ ​img2->setSize(100)  ​img2.setProperty(​\"BLEH\"​,​ ​\"ABC123\"​);​ ​//​ ​Dynamic​ ​Property​ ​(img2->setProperty​ ​...  ​QList​<​Image​*>​ ​myImageList;​ ​//​ ​QList​ ​must​ ​have​ ​QObject​ ​POINTERS  ​myImageList.append(&img2);​ ​//​ ​myImageList.append(img)  ​myImageList.append(&img2);​ ​//​ ​myImageList.append(img)  ​qDebug​()​ ​<<​ ​myImageList[​0​]->​metaObject​()->className()​ ​<<​ ​endl;  ​toString(myImageList);  ​return​ ​a.exec();  }      COS3711 Wilco Breedt 4 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 2. Validation Input Masks ​​ - is an active pattern that controls what can be typed into an input widget by the user.    Validator ​​- are objects that can be attached to input widgets (such as QLineEdit , QSpinBox , and QComboBox ) to  provide a general framework for checking user input  AntiPattern ​​ - a commonly used programming practice that has proved to be ineffective, inefficient, or otherwise  counterproductive. Below is a list of antiPatterns.  ● Software design antiPatterns  ○ Input kludge​​ - Failing to specify and implement the handling of possibly invalid input.  ○ Interface bloat​​ - Making an interface so powerful and complicated that it is hard to reuse or implement.  ○ Race hazard​​ - Failing to see the consequence of different orders of events.   ● Object-oriented design antiPatterns   ○ Circular dependency ​​- Introducing unnecessary direct or indirect mutual dependencies between  objects or software modules.   ○ God Object ​​- An object that has too much information or too much responsibility. This can be the result  of having too many functions in a single class. It can arise from many situations, but it often happens  when code for a model and view are combined in the same class.   ● Programming antiPatterns   ○ Hard coding - Embedding assumptions about the environment of a system in its implementation.   ○ Magic numbers - Including unexplained numbers in algorithms.  ○ Magic strings - Including literal strings in code, for comparisons, as event types, etc.  ● Methodological antiPatterns  ○ Copy and paste programming​​ - Copying and modifying existing code without creating more generic  solutions.   ○ Reinventing the (square) wheel​​ - Failing to adopt an existing, adequate solution and, instead, adopting    Regular Expression  How to use a validator ?  1. A validate on a line edit (set a validator)  2. Use the validate functions within QT  Examples:  QRegularExpression​ ​exp(​\"[1-9]\\\\d*(\\\\.\\\\d+)?\"​);  ​QLineEdit​ ​*lineEdit​ ​=​ ​new​ ​QLineEdit​();  ​QRegularExpressionValidator​ ​*v​ ​=​ ​new​ ​QRegularExpressionValidator​(exp);  ​//​ ​Option​ ​1 : A validate on a QLineEdit  ​lineEdit->setValidator(v);  ​//​ ​Option​ ​2 Use validation functions of QT:  ​int​ ​pos​ ​=​ ​0​;  ​if​ ​(v->​validate​(lineEdit->text(),​ ​pos)​ ​==​ ​QValidator​::​Acceptable​)​ ​{  ​//​ ​QValidator::Acceptable (completely valid)  // QValidator::Intermediate​ ​(Almost valid)  // QValidator::Invalid​ ​(Not​ ​valid​ ​at​ ​all)  ​//​ ​Do​ ​something​ ​that​ ​must​ ​be​ ​done.  ​}      COS3711 Wilco Breedt 5 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588   Regex Guide:  [abc]​ ​Matches either an a, b or c character (A Single Character)  [^abc]​ ​Matches any character except for an a, b or c  [a-z]​ ​Matches any characters between a and z, including a and z  [^a-z] ​Matches any characters except those in the range a-z  . ​Matches any character other than newline (or including newline with the /s flag)  \\. ​Matches the `.` (fullstop) ​\\&​Matches the `&` (ampersand) ​\\@​Matches the `@` (at)  \\s ​Matches any space, tab or newline character  \\S ​Matches anything other than a space, tab or newline  \\d ​Matches any decimal digit. Equivalent to [0-9]  \\D ​Matches anything other than a decimal digit  \\w ​Matches any letter, digit or underscore. Equivalent to [a-zA-Z0-9_]  \\W ​Matches anything other than a letter, digit or underscore  (...)​Parts of the regex enclosed in parentheses may be referred to later in the expression or extracted from the results of  a successful match.  (a|b) ​Matches the a or the b part of the subexpression. (A or B)  a? ​Matches an `a` character or nothing (Zero or One)  a* ​Matches zero or more consecutive `a` characters.  a+ ​Matches one or more consecutive `a` characters.  (abc)+ ​Matches one or more consecutive `abc` characters. abcabcabc  a{3} ​Matches exactly 3 consecutive `a` characters.  a{3,} ​Matches at least 3 consecutive `a` characters.  a{3,6} ​Matches between 3 and 6 (inclusive) consecutive `a` characters  ^ ​Matches the start of a string without consuming any characters. If multiline mode is used, this will also match  immediately after a newline character  $ ​Matches the end of a string without consuming any characters. If multiline mode is used, this will also match  immediately before a newline character.  \\b ​Matches, without consuming any characters, immediately between a character matched by \\w and a character not  matched by \\w (in either order). It cannot be used to separate non words from words.  ^\\w+$ ​Matches the word from start till end. If any space, tab, newline breaks it it doesn’t match.  ^(\\w+)$​ Match enige aaneenlopende sin sonder spasies    COS3711 Wilco Breedt 6 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 3. XML   <​imageList​> ​imageList, image, name → QDomElements  <​image​ ​size​=2​> ​imageList → RootElement    <​name​>​Image 1​</​name​> ​“Image 2”, “Image 1” → QDomText  </​image​> ​size=2, size=5 → Attribute  <​image​ ​size​=5​> ​Complete XML → QDomDocument    <​name​>​Image 2​</​name​>  </​image​>  </​imageList​>    Code:  QDomDocument​ ​doc;  QDomElement​ ​imageList​ ​=​ ​doc.createElement(​\"imageList\"​);  doc.appendChild(imageList);  QDomElement​ ​image​ ​=​ ​doc.createElement(​\"image\"​);  imageList.appendChild(image); ​ \"size\"​,​ ​2​);  QDomElement​ ​name​ ​=​ ​doc.createElement(​\"name\"​);  image.appendChild(name);  QDomText​ ​nameText​ ​=​ ​doc.createTextNode(​\"Image​ ​2\"​);  name.appendChild(nameText);  QString​ ​xml​ ​=​ ​doc.toString();    void​ ​someFuction(​QList​<Image*>​ ​list)​ ​{  ​QDomDocument​ ​doc;  ​QFile​ ​file(​\"...\"​);  ​QDomElement​ ​imageList​ ​=​ ​doc.createElement(​\"imageList\"​);  ​doc.appendChild(imageList);    ​foreach​(Image​ ​*i,​ ​list)​ ​{  ​QDomElement​ ​image​ ​=​ ​doc.createElement(​\"image\"​);  ​imageList.appendChild(image);  ​image.setAttribute(​\"size\"​, i->getSize());  ​QDomElement​ ​name​ ​=​ ​doc.createElement(​\"name\"​);  ​image.appendChild(name);  ​QDomText nameText = doc.createTextNode(i->getName());  ​name.appendChild(nameText);  ​}  ​QString​ ​xml​ ​=​ ​doc.toString();  }  COS3711 Wilco Breedt 7 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 4. MV/MVC - Model View Architecture 1. Views - ONLY displays the data, declare one instance and set the Model (that is basically the only thing you do  with it) The rest of the things comes from the Model (use setModel to set the view)  a. QTableView (Model Based)  b. QListView (Model Based)  c. QTreeView (Model Based)  d. QTableWidget (Item Based/ Convenience class)  e. QListWidget (Item Based/ Convenience class)  f. QTreeWidget (Item Based/ Convenience class)  2. Models - Serve the DATA to the Views (Remember Abstract means you cannot use it, you can not make an  instance of it, you cannot instantiate it ! you need to inherit it and then you can use it !!! QAbstractItemModel,  QAbstractTableModel, QAbstractListModel) Concrete models are models of which you can make a instance of     Objectives when using a QAbstractTableModel (Nothing is done on the View, everything is done on the MODEL!) :  1. Headers  2. Edit table data (Double click on row and edit it)  COS3711 Wilco Breedt 8 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 3. Add table data (Add rows)  4. Remove / Delete data (Delete rows)    How to implement a QAbstractTableModel (subclassing it):  ● Functions YOU MUST IMPLEMENT !!!!!!!  ○ rowCount() (pure virtual)→ How many rows are in your data  ○ columnCount() (pure virtual) → How many columns are there in your data  ○ data() (pure virtual) → To return the actual value / data (provides the data for each and every CELL in  your table)  ○ headerData() (This is just to make it a WELL behaved model)  ● Functions to implement if you want your model to be EDITABLE !  ○ setData() (If you want your table to be editable)  ○ flags() that returns a value containing Qt::ItemIsEditable / Qt::ItemIsSelectable / Qt::ItemIsEnabled    int​ ​MyModel::rowCount(​const​ ​QQModelIndex​ ​&parent)​ ​const  {  ​//​ ​Q_UNUSED(parent);​ ​//​ ​Sodat​ ​jy​ ​nie​ ​warnings​ ​kry​ ​vir​ ​goed​ ​wat​ ​nie​ ​gebruik​ ​word​ ​nie.  ​return​ ​list.count();​ ​//​ ​list.length​ ​-​ ​1​ ​??  }  int​ ​MyModel::columnCount(​const​ ​QQModelIndex​ ​&parent)​ ​const  {  ​//​ ​Q_UNUSED(parent);​ ​//​ ​Sodat​ ​jy​ ​nie​ ​warnings​ ​kry​ ​vir​ ​goed​ ​wat​ ​nie​ ​gebruik​ ​word​ ​nie.  ​return​ ​headers.count();​ ​//​ ​headers.length​ ​-​ ​1​ ​??  }  //​ ​Get​ ​the​ ​header​ ​data  QVariant​ ​MyModel::headerData(​int​ ​section,​ ​Qt​::Orientation​ ​orientation,​ ​int​ ​role)​ ​const​ ​//​ ​MUST​ ​IMPLEMENT  {  ​if​ ​(role​ ​!=​ ​Qt​::DisplayRole)​ ​//​ ​If​ ​it​ ​is​ ​not​ ​for​ ​display​ ​purposes​ ​don't​ ​return​ ​QVariant  ​{​ ​//​ ​Readonly  ​return​ ​QVariant​();  ​}  ​if​ ​(orientation​ ​==​ ​Qt​::Vertical)​ ​//​ ​orientation​ ​!=​ ​Qt::Horizontal  ​{  ​return​ ​QVariant​();  ​}  ​return​ ​headers.at(section);​ ​//​ ​Headers​ ​are​ ​stored​ ​in​ ​QList<QString>​ ​||​ ​QStringList;  ​//​ ​return​ ​headers[section];  }    ​ ​Get​ ​the​ ​data​ ​for​ ​each​ ​cell  QVariant​ ​MyModel::data(​const​ ​QModelIndex​ ​&index,​ ​int​ ​role)​ ​const​ ​//​ ​MUST​ ​IMPLEMENT  {  COS3711 Wilco Breedt 9 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 ​if​ ​(!index.isValid())​ ​//​ ​Check​ ​if​ ​the​ ​index​ ​is​ ​VALID​ ​!  ​{  ​return​ ​QVariant​();  ​}  ​if​ ​(role​ ​==​ ​Qt​::DisplayRole​ ​||​ ​role​ ​==​ ​Qt​::EditRole)​ ​//​ ​Important  ​{  ​//​ ​int​ ​row​ ​=​ ​index.row();  ​//​ ​int​ ​col​ ​=​ ​index.column();  ​//​ ​QObject​ ​*object​ ​=​ ​list[row];  ​//​ ​QString​ ​columnName​ ​=​ ​headers[col];  ​//​ ​QVariant​ ​value​ ​=​ ​object->property(columnName.toStdString().c_str());​ ​//​ ​Return​ ​const​ ​char  ​//​ ​return​ ​value;  ​return​ ​list[index.row()]->property(headers[index.column()].toStdString().c_str());​ ​//​ ​Return​ ​the​ ​data​ ​requested.  ​}  ​return​ ​QVariant​();  }  void​ ​MyModel::insert()​ ​//​ ​Do​ ​not​ ​have​ ​to​ ​implement,​ ​just​ ​for​ ​fun.  {  ​QObject​ ​*object​ ​=​ ​new​ ​QObject​();  ​foreach​(​QString​ ​header,​ ​headers)  ​{  ​object->setProperty(header.toStdString().c_str(),​ ​\"MyTest\"​);  ​}  ​list.append(object);  }    ​ ​Set​ ​the​ ​data​ ​for​ ​a​ ​cell​ ​//​ ​Must​ ​be​ ​here​ ​to​ ​edit​ ​the​ ​MODEL​ ​!!  bool​ ​MyModel::setData(​const​ ​QModelIndex​ ​&index,​ ​const​ ​QVariant​ ​&value,​ ​int​ ​role)​ ​//​ ​MUST​ ​IMPLEMENT EDITABLE  {  COS3711 Wilco Breedt 10 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 ​if​ ​(role​ ​==​ ​Qt​::EditRole​ ​&&​ ​index.isValid())  ​{  ​int​ ​row​ ​=​ ​index.row();  ​int​ ​col​ ​=​ ​index.col();  ​//​ ​list[row]->setProperty(headers[col].toStdString().c_str(),​ ​value);  ​list.at(row)->setProperty(headers.at(col).toStdString().c_str(),​ ​value);  ​emit​ ​dataChanged(index,​ ​index);​ ​//​ ​Signal​ ​the​ ​view​ ​that​ ​the​ ​data​ ​changed.  ​return​ ​true​;  ​}  ​return​ ​false​;  }  //​ ​Must​ ​be​ ​here​ ​to​ ​edit​ ​the​ ​MODEL​ ​!!  Qt​::​ItemFlags​ ​MyModel::flags(​const​ ​QModelIndex​ ​&index) ​ ​//​ ​MUST​ ​IMPLEMENT EDITABLE  {  ​//​ ​Do​ ​some​ ​check​ ​here​ ​to​ ​see​ ​if​ ​you​ ​are​ ​allowed​ ​to​ ​edit​ ​it​ ​?  ​//​ ​If​ ​everything​ ​is​ ​editable​ ​then​ ​return​ ​everything​ ​!  ​return​ ​(​Qt::ItemIsEditable | Qt::ItemIsSelectable | Qt::ItemIsEnabled);  }  MVC  ​​: Model → Application object / data  V​​: View → Presentation  C​​: Controller → Controls data flow from the model to the view or from the view to the model. Notifies everyone of what is  happening.  MV  Delegat ​​e: Renders items for editing (QSpinBox, QLineEdit etc.) Sits between the Model and View    Transition from MVC to MV (Why MV is a good example of MVC):  ● Do not see the C (Controller)  ● View and Controller are merged together  ● If something changes in the model, the view is notified, if something changes on the view the model is notified    The controller is like an observer (it observes the changes on the model & view).    What is the relationship between MVC and observer pattern  ● In the observer pattern the observer automatically respond to events occurring in the subject/ its subjects  ● In the same way the model, view and controller automatically respond to data changes within each other.  ● This can hence be seen as they are observing each other    MV vs MVC  COS3711 Wilco Breedt 11 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 In the MV pattern there is no controller, there is however a delegate, which is used to render items for editing on the  view and update the model with values from the view when editing is done from the view. A delegate can therefore be  seen as playing the role of a controller in the MV vs MVC architecture.  Difference between QTableView/QAbstractItemModel and QTableWidget (What is the difference between item based  and model based views)  ● QTableWidget (Item based) handles the data for you/data is stored in the widget (This is a convenience class)  ● QTableView (Model based) requires a model to handle the data for you  ● Item based Less flexible  ○ In Model based the view and the model are separated, this makes it more flexible because you can  have multiple views for the same model, or multiple models for the same view.   ○ Model and View are tightly coupled together in the item based.  ○ Item based is not reusable because the data is stored within the widget (the view moves with the data)    COS3711 Wilco Breedt 12 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 5. Momento ● When you want to serve the state of an object (state = data within the class) in a previous time frame (basically it  is used to restore data)  ● 3 classes involved  ○ Originator → Class that has the state that you want to serve (The class you want to backup) The  originator must handle the back-up logic (So all the logic basically comes here)  ○ Memento → Copy the state of the Originator (This is where the backup is stored)  ○ Caretaker → Stores the memonto’s  ● Momento class (Backup class) → Only has the state + a getter and a setter to set the data    //​ ​Originator  class​ ​ImageList  {  public​:  ​ImageList​();  ​Backup​ ​getBackup();  ​void​ ​restore(​Backup​ ​b);  private​:  ​QList​<​Image​>​ ​list​;  };  // Implementation of the getters and setters within the ImageList  Backup​ ​ImageList​::getBackup()  {  ​Backup​ ​b;  ​b.setList(​list​);  ​return​ ​b;  }  void​ ​ImageList​::restore(​Backup​ ​b)  {  ​list​ ​=​ ​b.getList();  }  //​ ​Memento  class​ ​Backup  {  public​:  ​Backup​();  ​void​ ​setList(​QList​<​Image​>​ ​l);  ​QList​<​Image​>​ ​getList();  private​:  COS3711 Wilco Breedt 13 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 ​QList​<​Image​>​ ​list​;  };  //​ ​Caretaker  class​ ​BackupList​:​ ​public​ ​QList​<​Backup​>  {  public​:  ​BackupList​();  };  Basic steps of the client:  1. Backup  a. Get an instance from the originator using the getter you declared  b. Store that backup instance in the caretaker.  2. Restore  a. Get the instance of the backup in the caretaker  b. Use the setter you declared in the originator to restore the backup  //​ ​CLIENT  ​ImageList​ ​i;  ​BackupList​ ​bl;  ​//​ ​Backup  ​Backup​ ​b​ ​=​ ​i.getBackup();​ ​//​ ​Get​ ​a​ ​instance​ ​from​ ​originator.  ​bl.append(b);​ ​//​ ​Store​ ​the​ ​backup​ ​in​ ​the​ ​caretaker    ​//​ ​Restore  ​Backup​ ​r​ ​=​ ​bl.at(​0​);​ ​//​ ​bl[0]​ ​//​ ​Get​ ​the​ ​backup​ ​from​ ​the​ ​caretaker.  ​i.restore(r);​ ​//​ ​Restore​ ​the​ ​backup​ ​in​ ​the​ ​originator.    Encapsulation REQUIREMENT Should always satisfy this !  ● Caretaker must NOT be able to modify the memento  ● Make everything private and make the originator a friend class  ● See below how to do this !    //​ ​Memento  class​ ​Backup  {  private​:  ​friend​ ​class​ ​ImageList​;  ​Backup​();    ​void​ ​setList(​QList​<​Image​>​ ​l);  ​QList​<​Image​>​ ​getList();  ​QList​<​Image​>​ ​list​;  };    COS3711 Wilco Breedt 14 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 6. Concurrency ● The ability to run multiple processes at the same time (Threads)  ● Example: You want to loop a 900 times over 0 - 900. Then check if the numbers are prime numbers. Imagine if  it took 1 second for a check, this means your program will be busy for 900 seconds. But if you split it into  threads [0 - 300, 301 - 600, 601 - 900] and execute those loops at the same time, then it will take a ⅓ of the  time to complete the 900 loop.    Have two things involved in threads (Two classes involved)  1. Worker → Does the actual work (Does the loop)  a. Must be a QObject   b. Use signals to communicate with the Client  2. Client → The one telling the worker to do its stuffies    //​ ​Worker, USING THE QOBJECT is the RECOMMENDED APPROACH !!  class​ ​SearchImages​:​ ​public​ ​QObject  {  ​Q_OBJECT  public​:  ​SearchImages​();  ​//​ ​QList<Image>​ ​search(QList<Image>​ ​list,​ ​int​ ​size);  ​void​ ​search(​QList​<​Image​>​ ​list,​ ​int​ ​size);​ ​//​ ​Changed​ ​the​ ​above​ ​to​ ​this​ ​to​ ​make​ ​it​ ​use​ ​signals​ ​and​ ​slots  signals​:  ​void​ ​imageFound(​Image​);​ ​//​ ​Signal​ ​for​ ​when​ ​a​ ​image​ ​is​ ​found​ ​to​ ​emit​ ​outside​ ​the​ ​thread.  ​void​ ​finished();  };  //​ ​Client  ​QList​<​Image​>​ ​imgList;  ​QThread​ ​*thread​ ​=​ ​new​ ​QThread​();  ​SearchImages​ ​*s​ ​=​ ​new​ ​SearchImages​();  //​ ​Move​ ​the​ ​QObject​ ​to​ ​thread,​ ​moveToThread​ ​exists​ ​on​ ​QObject​ ​class  ​s->moveToThread(thread);  ​//​ ​connect(senderObject,​ ​signalOnSenderObject,​ ​receiverObject,​ ​slotOnReceiverObject)​ Connect Basic Params  //​ ​When​ ​the​ ​thread​ ​starts,​ ​start​ ​the​ ​search​ ​function​ ​in​ ​SearchImage​ ​Class  ​connect(thread,​ ​SIGNAL​(started()),​ ​s,​ ​SLOT​(search(imgList,​ ​300​)));   //​ ​Connect​ ​when​ ​the​ ​SearchImage​ ​finds​ ​an​ ​image​ ​and​ ​emits​ ​it​ ​and​ ​then​ ​sends​ ​the​ ​image​ ​to​ ​the​ ​handleImage​ ​function.  ​connect(s,​ ​SIGNAL​(imageFound(​Image​)),​ ​this​,​ ​SLOT​(handleImage(​Image​)));   ​//​ ​The​ ​following​ ​3​ ​steps​ ​ARE​ ​FOR​ ​CLEANUP​ ​!!  ​connect(s,​ ​SIGNAL​(finished()),​ ​thread,​ ​SLOT​(quit());​ ​//​ ​When​ ​done,​ ​quit​ ​the​ ​thread,​ ​CLEANUP  ​connect(thread,​ ​SIGNAL​(finished()),​ ​thread,​ ​SLOT​(deleteLater());​ ​//​ ​Delete​ ​the​ ​thread​ ​nicely,​ ​CLEANUP  ​connect(thread,​ ​SIGNAL​(finished()),​ ​si,​ ​SLOT​(deleteLater()));​ ​//​ ​Delete​ ​the​ ​worker​ ​nicely,​ ​CLEANUP  ​thread->start();​ ​//​ ​Emits​ ​the​ ​signal​ ​started​ ​...​ ​and​ ​then​ ​the​ ​above​ ​search(size)​ ​SIGNAL​ ​SLOT​ ​gets​ ​handled,    COS3711 Wilco Breedt 15 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588   QProcess  ● Run an exe  ● readyReadStandardOutput - Signal that gets emitted when something is printed to the CONSOLE !!!    QProcess​ ​*process​ ​=​ ​new​ ​QProcess​();  connect(process,​ ​SIGNAL​(readyReadStandardOutput()),​ ​this​,​ ​SLOT​(manage());  process->start(​\"image.exe\"​);    void​ ​manage()  {  ​QByteArray​ ​ba​ ​=​ ​process->readAllStandardOutput();​ ​//​ ​Readline  ​QString​ ​output​ ​=​ ​QString​(ba);  ​QStringList​ ​lines​ ​=​ ​output.split(​\"/n\"​);  }  COS3711 Wilco Breedt 16 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 7. Singleton ● ONE instance  ● Can be asked with Memento  ● Steps  ○ 1. Hide the constructor → Move the constructor to the private members  ○ 2. Create a method on the class to get an instance. (getInstance)  ○ 3. Make that method that you created (getInstace) a static method, this makes it easier so you can call it  like so. BookList bl = BookList::getInstance();  ○ This makes the getInstance function INSTANCE INDEPENDANT  ○ 4. Create a static Variable to STORE the instance in static BookList *instance;    ImageList​*​ ​ImageList​::list​ ​=​ ​NULL​; ​ // HOW TO INITIALIZE a static variable within a class (If it was a ImageList)  int​*​ ​ImageList​::size​ ​=​ ​0​;​ // HOW TO INITIALIZE a static variable within a class (If it was a int)    class​ ​BookList​:​ ​public​ ​QObject  {  public​:  ​static​ ​BookList​*​ ​getInstance();  private​:  ​BookList​();  ​QList​<Book>​ ​list​;  ​static​ ​BookList​*​ ​instance​;  };  BookList​*​ ​BookList​::​instance​ ​=​ ​NULL​;    BookList​*​ ​BookList​::getInstance()  {  ​If ​(​instance​ ​==​ ​NULL​)​ ​{​ ​//​ ​if​ ​(BookList::instance​ ​==​ ​NULL)  ​instance​ ​=​ ​new​ ​BookList​();​ ​//​ ​BookList::instance​ ​=​ ​new​ ​BookList();  ​}  ​return​ ​instance​;​ ​//​ ​return​ ​BookList::instance;  }     DO NOT TRY THE FOLLOWING THIS !  BookList ​l;​ // CANNOT instantiate an instance since the singleton pattern let you mark the constructor as private !  BookList ​b = I.getInstance() ​// This will not work since the previous line cannot be instantiated.    COS3711 Wilco Breedt 17 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 8. UML     COS3711 Wilco Breedt 18 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 9. Factory Method ● Anywhere where there are inheritance, you can possibly use the factory method    UML Before Factory Method: (Student is an abstract class in the UML Diagram)    UML After Factory Method applied  COS3711 Wilco Breedt 19 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 The whole idea of the factory method is to let the client NOT be aware of all of the other classes. The client only has to  be aware of the The AbstractFactory and the AbstractStudent. This makes it a lot easier and scalable if you have  multiple models inheriting from the one Student Object. This decouples the classes from each other.    How to implement the createStudent Function:  Student​*​ ​StudentFactory​::createStudent(n:​ ​QString)  {  ​if​ ​(n​ ​==​ ​\"diploma\"​)  ​return​ ​new​ ​Student();  ​if​ ​(n​ ​==​ ​\"degree\"​)  ​return​ ​new​ ​Student();  };  In your client: (this is usually your main.cpp file or you mainwindow.cpp file or something similar)   ​AbstractStudentFactory​ *f = ​new​ ​StudentFactory​();  ​Student​ *myDiplomaStudent = f.createStudent(​\"diploma\"​);    This is actually really simple as you can see, but it can be hard to understand at first if you are not sure what is going on,  please checkout the github repo for examples on this.  COS3711 Wilco Breedt 20 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 10. Notes 1. This summary is only there to explain some key concepts within the book that is unclear sometimes. You will  need to practice all of these concepts at least once to understand it. Below you will find a link to a github repo  containing one example for each of the topics within this summary. If you want to cover about 70% of your  exam really quickly just have a look at the QUESTIONS you HAD TO SUBMIT for the subject in your assignment  1 and  2. These are the core concepts that they WILL ask you in the exam. If you practice just the concepts you had in  your assignments then there is a good chance you will pass the exam with at least 70% if you have mastered  the concepts (And by this I mean, you can identify the concept quickly within a question and you can actually do  the code to implement it)  3. Another good tip to note is that they love to ask multiple concepts within an question the combos are usually:  a. MVC with Memento  b. Memento with Singleton  4. When the new operator is used, then the object that it returns is a POINTER !!!! Page 75 in the textbook explains  this in more detail  a. QString​ *myStr = ​new ​QString​(“ABC”) ​// Pointer;  b. QString​ myStr = ​QString​(“ABC”) ​// No pointer;  5. Incase you still struggle with the concepts please visit VTutorOnline, they provide a great course that will  definitely help you understand every concept clearly and help you to identify and sharpen your skills :  https://www.vtutoronline.com/courses/UNS_COS3711/lessons-schedule  6. Visit the GITHUB repository that has a few code examples within it .​https://github.com/WilcoBreedt/cos3711  COS3711 Wilco Breedt 21 Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588Libraries and Design PatternsCOS3711 -e-Tutor PowerpointLibraries and Design PatternsPowerpointChapter 7 •Outline 1.Library2.QtLibraries 3.Framework and Design pattern4.AntiPatternLibraries•Pre-compiled programming codes ready for use •Promote code reuse•Can be included in your project with the directive •The #include directive provide you with an interface to use the items (Classes, functions, variables, etc.) in the library•You do not have to incorporate the code of the library components into your program•You do not have to incorporate the code of the library components into your program•A system program caller linker establishes a link between your program and library codes at run time•The job of the linker is eased by the lib file•A lib file contains one or many compiled/object files indexed into one another to ease the linking process of library items and program codeprogramming codes ready for use by programmersCan be included in your project with the directive #includedirective provide you with an interface to use the items (Classes, functions, variables, etc.) in the libraryYou do not have to incorporate the code of the library components into You do not have to incorporate the code of the library components into establishes a link between your program lib filecontains one or many compiled/object files indexed into one of library items and program codeQtLibraries•Qtis a big library consisting of several smaller libraries•Common Qtlibraries are given on the table on the right ModuleQtCoreQt GUIQt MultimediaQt Multimedia WidgetsQt NetworkQt QMLQtQuick•You may find full definitions of these libraries at:http://doc.qt.io/qt-5/qtmodules.htmlQt Quick ControlsQt Quick DialogsQt Quick LayoutsQt SQLQt TestQt WebKit(Deprecated)Qt WebKit Widgets(Deprecated)Qt WidgetsDescriptionCore non-graphical classes used by other modules.Base classes for graphical user interface (GUI) components. Includes OpenGL.Classes for audio, video, radio and camera functionality.Widget-based classes for implementing multimedia functionality.Classes to make network programming easier and more portable.Classes for QML and JavaScript languages.A declarative framework for building highly dynamic applications with custom user interfaces.Reusable QtQuick based UI controls to create classic desktop-style user interfaces.Types for creating and interacting with system dialogs from a QtQuick application.Layouts are items that are used to arrange QtQuick 2 based items in the user interface.Classes for database integration using SQL.Classes for unit testing Qtapplications and libraries.Classes for a WebKit2 based implementation and a QML API. Deprecated in favorofQtWebEngine.WebKit1 andQWidget-based classes from Qt4.Classes to extend QtGUI with C++ widgets.Framework and Design Pattern•A frameworkis a large collection of components and conventions with a well-documented public API that enable the development of complex software •Qtis a framework; other are Eclipse, Spring, Microsoft .NET, etc.•A framework is implemented with •Design patterns are efficient and elegant problems in object-oriented software design•Design patterns are efficient and elegant problems in object-oriented software design•Design patterns are high-level abstract templates to particular kings of design problems•Several Qtclasses implement design patterns •Qtclasses QTextStreamand QDataStreamthe SerializerpatternFramework and Design Patternis a large collection of components and conventions documented public API that enable the development of ; other are Eclipse, Spring, Microsoft .NET, etc.A framework is implemented with design patternsare efficient and elegant solutions to common oriented software designare efficient and elegant solutions to common oriented software designlevel abstract templates that can be applied to particular kings of design problemsclasses implement design patterns QDataStreamare implementations of AntiPatterns•AntiPatternsare commonly used programming practices to recurring programming problems ineffective or inefficient•Examples of antiPatternare:•Design of a complicated interface that is hard to reuse or implement (Interface bloat)implement (Interface bloat)•Design of a class with too many functions combines model and view at the same •Introduction of unnecessary dependencies between object of software modules (Circular dependency•Copying and pasting existing programming codes (programming)commonly used programming practices / solutions to recurring programming problems that have proved to be Design of a complicated interface that is hard to reuse or Design of a class with too many functions , e.g. a class that model and view at the same time(Interface bloat)Introduction of unnecessary dependencies between object of Circular dependency)Copying and pasting existing programming codes (Copy and paste . The Qt object model and the signal slot concept Qt in Education © 2010 Nokia Corporation and its Subsidiary(-ies). The enclosed Qt Educational Training Materials are provided under the Creative Commons Attribution-Non-Commercial-Share Alike 2.5 License Agreement. The full license text is available here: http://creativecommons.org/licenses/by-nc-sa/2.5/legalcode. Nokia, Qt and the Nokia and Qt logos are the registered trademarks of Nokia Corporation in Finland and other countries worldwide. The QObject ● QObject is the base class of almost all Qt classes and all widgets ● It contains many of the mechanisms that make up Qt ● events ● signals and slots ● properties ● memory management The QObject ● QObject is the base class to most Qt classes. Examples of exceptions are: ● Classes that need to be lightweight such as graphical primitives ● Data containers (QString, QList, QChar, etc) ● Classes that needs to be copyable, as QObjects cannot be copied The QObject ● They can have a name (QObject::objectName) ● They are placed in a hierarchy of QObject instances ● They can have connections to other QObject instances ● Example: does it make sense to copy a widget at run-time? “QObject instances are individuals!” Meta data ● Qt implements introspection in C++ ● Every QObject has a meta object ● The meta object knows about ● class name (QObject::className) ● inheritance (QObject::inherits) ● properties ● signals and slots ● general information (QObject::classInfo) Meta data ● The meta data is gathered at compile time by the meta object compiler, moc. sources *.cpp executables object files *.o headers *.h Ordinary C++ Build Process includes compiles links Meta data ● The meta data is gathered at compile time by the meta object compiler, moc. ● The moc harvests data from your headers. sources *.cpp executables object files *.o headers *.h generated moc_*.cpp Qt C++ Build Process includes compiles links compiles mocs Meta data ● What does moc look for? class MyClass : public QObject { Q_OBJECT Q_CLASSINFO(\"author\", \"John Doe\") public: MyClass(const Foo &foo, QObject *parent=0); Foo foo() const; public slots: void setFoo( const Foo &foo ); signals: void fooChanged( Foo ); private: Foo m_foo; }; Qt keywords General info about the class The Q_OBJECT macro, usually first Make sure that you inherit QObject first (could be indirect) Introspection ● The classes know about themselves at run-time ● Great for implementing scripting and dynamic language bindings if (object->inherits(\"QAbstractItemView\")) { QAbstractItemView *view = static_cast<QAbstractItemView*>(widget); view->... enum CapitalsEnum { Oslo, Helsinki, Stockholm, Copenhagen }; int index = object->metaObject()->indexOfEnumerator(\"CapitalsEnum\"); object->metaObject()->enumerator(index)->key(object->capital()); Enables dynamic casting without RTTI Example:It is possible to convert enumeration values to strings for easier reading and storing The meta object knows about the details Properties ● QObject have properties with getter and setter methods ● Naming policy: color, setColor ● For booleans: isEnabled, setEnabled class QLabel : public QFrame { Q_OBJECT Q_PROPERTY(QString text READ text WRITE setText) public: QString text() const; public slots: void setText(const QString &); }; Setter, returns void, takes value as only argument Getter, const, returns value, takes no arguments Properties ● Why setter methods? ● Possible to validate settings ● Possible to react to changes void setMin( int newMin ) { if( newMin > m_max ) { qWarning(\"Ignoring setMin(%d) as min > max.\", newMin); return; } ... void setMin( int newMin ) { ... m_min = newMin; updateMinimum(); } Properties ● Why getter method? ● Indirect properties QSize size() const { return m_size; } int width() const { return m_size.width(); } Properties Q_PROPERTY(type name READ getFunction [WRITE setFunction] [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool] [SCRIPTABLE bool] [STORED bool] [USER bool] [CONSTANT] [FINAL]) Using properties ● Direct access ● Through the meta info and property system ● Discover properties at run-time QString text = label->text(); label->setText(\"Hello World!\"); QString text = object->property(\"text\").toString(); object->setProperty(\"text\", \"Hello World\"); int QMetaObject::propertyCount(); QMetaProperty QMetaObject::property(i); QMetaProperty::name/isConstant/isDesignable/read/write/... Dynamic properties ● Lets you add properties to objects at run-time ● Can be used to “tag” objects, etc bool ret = object->setProperty(name, value); QObject::dynamicPropertyNames() const true if the property has been defined using Q_PROPERTY false if it is dynamically added returns a list of the dynamic properties Creating custom properties class AngleObject : public QObject { Q_OBJECT Q_PROPERTY(qreal angle READ angle WRITE setAngle) public: AngleObject(qreal angle, QObject *parent = 0); qreal angle() const; void setAngle(qreal); private: qreal m_angle; }; Macro describing the property Initial value Getter Setter Private state Creating custom properties AngleObject::AngleObject(qreal angle, QObject *parent) : QObject(parent), m_angle(angle) { } qreal AngleObject::angle() const { return m_angle; } void AngleObject::setAngle(qreal angle) { m_angle = angle; doSomething(); } Initial value Getter simply returns the value. Here you can calculate complex values. Update internal state, then react to the change. Custom properties - enumerations class AngleObject : public QObject { Q_OBJECT Q_ENUMS(AngleMode) Q_PROPERTY(AngleMode angleMode READ ...) public: enum AngleMode {Radians, Degrees}; ... }; Ordinary enum declaration. Macro informing Qt that AngleMode is an enum type. Property using enum as type. Memory Management ● QObject can have parent and children ● When a parent object is deleted, it deletes its children QObject *parent = new QObject(); QObject *child1 = new QObject(parent); QObject *child2 = new QObject(parent); QObject *child1_1 = new QObject(child1); QObject *child1_2 = new QObject(child1); delete parent; parent child1 child2 child1_1 child1_2 parent deletes child1 and child2 child1 deletes child1_1 and child1_2 Memory Management ● This is used when implementing visual hierarchies. QDialog *parent = new QDialog(); QGroupBox *box = new QGroupBox(parent); QPushButton *button = new QPushButton(parent); QRadioButton *option1 = new QRadioButton(box); QRadioButton *option2 = new QRadioButton(box); delete parent; parent deletes box and button box deletes option1 and option2 Usage Patterns ● Use the this-pointer as top level parent ● Allocate parent on the stack void Widget::showDialog() { Dialog dialog; if (dialog.exec() == QDialog::Accepted) { ... } } Dialog::Dialog(QWidget *parent) : QDialog(parent) { QGroupBox *box = QGroupBox(this); QPushButton *button = QPushButton(this); QRadioButton *option1 = QRadioButton(box); QRadioButton *option2 = QRadioButton(box); ... dialog is deleted when the scope ends Heap ● When using new and delete, memory is allocated on the heap. ● Heap memory must be explicitly freed using delete to avoid memory leaks. ● Objects allocated on the heap can live for as long as they are needed. new delete Construction Destruction Stack ● Local variables are allocated on the stack. ● Stack variables are automatically destructed when they go out of scope. ● Objects allocated on the stack are always destructed when they go out of scope. int a } Construction Destruction Stack and Heap ● To get automatic memory management, only the parent needs to be allocated on the stack. MyMainWindow QApplication int main(int argc, char **argv) { QApplication a(argc, argv); MyMainWindow w; w.show(); return a.exec(); } MyMainWindow::MyMainWindow(... { new QLabel(this); new ... } Changing Ownership ● QObjects can be moved between parents ● The parents know when children are deleted ● Methods that return pointers and “take” releases data from its owner and leaves it in the takers care obj->setParent(newParent); delete listWidget->item(0); // Removes the first item (unsafe) QLayoutItem *QLayout::takeAt(int); QListWidgetItem *QListWidget::takeItem(int); // Safe alternative QListWidgetItem *item = listWidget->takeItem(0); if (item) { delete item; } List items are not children per se, but owned. The example demonstrates the nomenclature. Constructor Etiquette ● Almost all QObjects take a parent object with a default value of 0 (null) ● The parent of QWidgets are other QWidgets ● Classes have a tendency to provide many constructors for convenience (including one taking only parent) ● The parent is usually the first argument with a default value QLabel(const QString &text, QWidget *parent=0, Qt::WindowFlags f=0); QObject(QObject *parent=0); QPushButton(QWidget *parent=0); QPushButton(const QString &text, QWidget *parent=0); QPushButton(const QIcon &icon, const QString &text, QWidget *parent=0); Constructor Etiquette ● When creating your own QObjects, consider ● Always allowing parent be 0 (null) ● Having one constructor only accepting parent ● parent is the first argument with a default value ● Provide several constructors to avoid having to pass 0 (null) and invalid (e.g. QString()) values as arguments Break Signals and Slots ● Dynamically and loosely tie together events and state changes with reactions ● What makes Qt tick Signals and Slots in Action emit clicked(); Signals and Slots in Action private slots: void on_addButton_clicked(); void on_deleteButton_clicked(); connect(clearButton,SIGNAL(clicked()),listWidget,SLOT(clear())); connect(addButton,SIGNAL(clicked()),this,SLOT(...)) ; 2x clear(); Signals and Slots in Action { ... emit clicked(); ... } { ... emit clicked(); ... } { ... emit clicked(); ... } { QString newText = QInputDialog::getText(this, \"Enter text\", \"Text:\"); if( !newText.isEmpty() ) ui->listWidget->addItem(newText); } { foreach (QListWidgetItem *item, ui->listWidget->selectedItems()) { delete item; } } clear(); Signals and Slots vs Callbacks ● A callback is a pointer to a function that is called when an event occurs, any function can be assigned to a callback ● No type-safety ● Always works as a direct call ● Signals and Slots are more dynamic ● A more generic mechanism ● Easier to interconnect two existing classes ● Less knowledge shared between involved classes What is a slot? ● A slot is defined in one of the slots sections ● A slot can return values, but not through connections ● Any number of signals can be connected to a slot ● It is implemented as an ordinary method ● It can be called as an ordinary method public slots: void aPublicSlot(); protected slots: void aProtectedSlot(); private slots: void aPrivateSlot(); connect(src, SIGNAL(sig()), dest, SLOT(slt())); What is a signal? ● A signal is defined in the signals section ● A signal always returns void ● A signal must not be implemented ● The moc provides an implementation ● A signal can be connected to any number of slots ● Usually results in a direct call, but can be passed as events between threads, or even over sockets (using 3rd party classes) ● The slots are activated in arbitrary order ● A signal is emitted using the emit keyword signals: void aSignal(); emit aSignal(); Making the connection QObject::connect( src, SIGNAL( signature ), dest, SLOT( signature ) ); <function name> ( <arg type>... ) clicked() toggled(bool) setText(QString) textChanged(QString) rangeChanged(int,int) setTitle(QString text) setValue(42) A signature consists of the function name and argument types. No variable names, nor values are allowed. Custom types reduces reusability. QObject* setItem(ItemClass) Making the connection ● Qt can ignore arguments, but not create values from nothing Signals rangeChanged(int,int) rangeChanged(int,int) rangeChanged(int,int) valueChanged(int) valueChanged(int) valueChanged(int) textChanged(QString) clicked() clicked() Slots setRange(int,int) setValue(int) updateDialog() setRange(int,int) setValue(int) updateDialog() setValue(int) setValue(int) updateDialog() Automatic Connections ● When using Designer it is convenient to have automatic connections between the interface and your code ● Triggered by calling QMetaObject::connectSlotsByName ● Think about reuse when naming ● Compare on_widget_signal to updatePageMargins on_ object name _ signal name ( signal parameters ) on_addButton_clicked(); on_deleteButton_clicked(); on_listWidget_currentItemChanged(QListWidgetItem*,QListWidgetItem*) updatePageMargins can be connected to a number of signals or called directly. Synchronizing Values ● Connect both ways ● An infinite loop must be stopped – no signal is emitted unless an actual change takes place connect(dial1, SIGNAL(valueChanged(int)), dial2, SLOT(setValue(int))); connect(dial2, SIGNAL(valueChanged(int)), dial1, SLOT(setValue(int))); void QDial::setValue(int v) { if(v==m_value) return; ... This is the responsibility of all code that can emit signals – do not forget it in your own classes Custom signals and slots class AngleObject : public QObject { Q_OBJECT Q_PROPERTY(qreal angle READ angle WRITE setAngle NOTIFY angleChanged) public: AngleObject(qreal angle, QObject *parent = 0); qreal angle() const; public slots: void setAngle(qreal); signals: void angleChanged(qreal); private: qreal m_angle; }; Add a notify signal here. Setters make natural slots. Signals match the setters Setter implementation details void AngleObject::setAngle(qreal angle) { if(m_angle == angle) return; m_angle = angle; emit angleChanged(m_angle); } Protection against infinite loops. Do not forget this! Update the internal state, then emit the signal. Signals are “protected” so you can emit them from derived classes. Temperature Converter ● Uses the TempConverter class to convert between Celsius and Fahrenheit ● Emits signals when temperature changes Temperature Converter ● The dialog window contains the following objects ● A TempConverter instance ● Two QGroupBox widgets, each containing – A QDial widget – A QLCDNumber widget Temperature Converter class TempConverter : public QObject { Q_OBJECT public: TempConverter(int tempCelsius, QObject *parent = 0); int tempCelsius() const; int tempFahrenheit() const; public slots: void setTempCelsius(int); void setTempFahrenheit(int); signals: void tempCelsiusChanged(int); void tempFahrenheitChanged(int); private: int m_tempCelsius; }; Q_OBJECT macro first QObject as parent parent pointer Read and write methods Emitted on changes of the temperature Internal representation in integer Celsius. Temperature Converter void TempConverter::setTempCelsius(int tempCelsius) { if(m_tempCelsius == tempCelsius) return; m_tempCelsius = tempCelsius; emit tempCelsiusChanged(m_tempCelsius); emit tempFahrenheitChanged(tempFahrenheit()); } void TempConverter::setTempFahrenheit(int tempFahrenheit) { int tempCelsius = (5.0/9.0)*(tempFahrenheit-32); setTempCelsius(tempCelsius); } ● The setTempCelsius slot: ● The setTempFahrenheit slot: Test for change to break recursion Update object state Emit signal(s) reflecting changes Convert and pass on as Celsius is the internal representation Temperature Converter ● The dials are interconnected through the TempConverter ● The LCD displays are driven directly from the dials TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Temperature Converter ● The user moves the celsiusDial TempConverter setTempCelsius setTempFahrenheit tempCelsiusChanged tempFahrenheitChangedvalueChanged → setTempCelsiusvalueChanged → setTempFahrenheittempCelsiusChanged → setValuetempFahrenheitChanged → setValue valueChanged → display connect(celsiusDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempCelsius(int))); connect(celsiusDial, SIGNAL(valueChanged(int)), celsiusLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempCelsiusChanged(int)), celsiusDial, SLOT(setValue(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), tempConverter, SLOT(setTempFahrenheit(int))); connect(fahrenheitDial, SIGNAL(valueChanged(int)), fahrenheitLcd, SLOT(display(int))); connect(tempConverter, SIGNAL(tempFahrenheitChanged(int)), fahrenheitDial, SLOT(setValue(int))); Connect with a value? ● A common scenario is that you want to pass a value in the connect statement ● For instance, the keyboard example ● This is not valid – it will not connect connect(key, SIGNAL(clicked()), this, SLOT(keyPressed(1))); Connect with a value? ● Solution #1: multiple slots { ... public slots: void key1Pressed(); void key2Pressed(); void key3Pressed(); void key4Pressed(); void key5Pressed(); void key6Pressed(); void key7Pressed(); void key8Pressed(); void key9Pressed(); void key0Pressed(); ... } connections Connect with a value? ● Solution #2: sub-class emitter and add signal QPushButton QIntPushButton { ... signals: void clicked(int); ... } { QIntPushButton *b; b=new QIntPushButton(1); connect(b, SIGNAL(clicked(int)), this, SLOT(keyPressed(int))); b=new QIntPushButton(2); connect(b, SIGNAL(clicked(int)), this, SLOT(keyPressed(int))); b=new QIntPushButton(3); connect(b, SIGNAL(clicked(int)), this, SLOT(keyPressed(int))); ... } Solution evaluation ● #1: multiple slots ● Many slots containing almost the same code ● Hard to maintain (one small change affects all slots) ● Hard to extend (new slot each time) ● #2: sub-class emitter and add signal ● Extra class that is specialized (hard to reuse) ● Hard to extend (new sub-class for each special case) The signal mapper ● The QSignalMapper class solves this problem ● Maps a value to each emitter ● Sits between reusable classes { QSignalMapper *m = QSignalMapper(this); QPushButton *b; b=new QPushButton(\"1\"); connect(b, SIGNAL(clicked()), m, SLOT(map())); m->setMapping(b, 1); ... connect(m, SIGNAL(mapped(int)), this, SLOT(keyPressed(int))); } Create a signal mapper Connect the buttons to the mapper Associate an emitter with a value Connect the mapper to the slot The signal mapper QSignalMapper { ... public slots: void keyPressed(); ... } connections connection ● The signal mapper associates each button with a value. These values are mapped ● When a value is mapped, the signal mapper emits the mapped(int) signal, carrying the associated valueModel/View Tutorial Every UI developer should know about ModelView programming and the goal of this tutorial is to provide you with an easily understandable introduction to this topic. Table, list and tree widgets are components frequently used in GUIs. There are 2 different ways how these widgets can access their data. The traditional way involves widgets which include internal containers for storing data. This approach is very intuitive, however, in many non-trivial applications, it leads to data synchronization issues. The second approach is model/view programming, in which widgets do not maintain internal data containers. They access external data through a standardized interface and therefore avoid data duplication. This may seem complicated at first, but once you take a closer look, it is not only easy to grasp, but the many benefits of model/view programming also become clearer. In the process, we will learn about some basic technologies provided by Qt, such as: • The difference between standard and model/view widgets • Adapters betweeen forms and models • Developing a simple model/view application • Predefined models • Intermediate topics such as: o Tree views o Selection o Delegates o Debugging with model test You will also learn whether your new application can be written easier with model/view programming or if classic widgets will work just as well. This tutorial includes example code for you to edit and integrate into your project. 1. Introduction Model/View is a technology used to separate data from views in widgets that handle data sets. Standard widgets are not designed for separating data from views and this is why Qt 4 has two different types of widgets. Both types of widgets look the same, but they interact with data differently. Standard widgets use data that is part of the widget. View classes operate on external data (the model) 1.1 Standard Widgets Let's have a closer look at a standard table widget. A table widget is a 2D array of the data elements that the user can change. The table widget can be integrated into a program flow by reading and writing the data elements that the table widget provides. This method is very intuitive and useful in many applications, but displaying and editing a database table with a standard table widget can be problematic. Two copies of the data have to be coordinated: one outside the widget; one inside the widget. The developer is responsible for synchronizing both versions. Besides this, the tight coupling of presentation and data makes it harder to write unit tests. 1.2 Model/View to the Rescue Model/view stepped up to provide a solution that uses a more versatile architecture. Model/view eliminates the data consistency problems that may occur with standard widgets. Model/view also makes it easier to use more than one view of the same data because one model can be passed on to many views. The most important difference is that model/view widgets do not store data behind the table cells. In fact, they operate directly from your data. Since view classes do not know your data's structure, you need to provide a wrapper to make your data conform to the QAbstractItemModel interface. A view uses this interface to read from and write to your data. Any instance of a class that implements QAbstractItemModel is said to be a model. Once the view receives a pointer to a model, it will read and display its content and be its editor. 1.3 Overview of the Model/View Widgets Here is an overview of the model/view widgets and their corresponding standard widgets. Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QListWidget QListView Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QTableWidget QTableView QTreeWidget QTreeView Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QColumnView shows a tree as a hierarchy of lists QComboBox can work as both a view class and also as a traditional widget 1.4 Using Adapters between Forms and Models Having adapters between forms and models can come in handy. We can edit data stored in tables directly from within the table itself, but it's much more comfortable to edit data in text fields. There is no direct model/view counterpart that separates data and views for widgets that operate on one value (QLineEdit, QCheckBox ...) instead of a dataset, so we need an adapter in order to connect the form to the source of data. QDataWidgetMapper is a great solution because it maps form widgets to a table row and makes it very easy to build forms for database tables. Another example of an adapter is QCompleter. Qt has QCompleter for providing auto-completions in Qt widgets such as QComboBox and, as shown below, QLineEdit. QCompleter uses a model as its data source. 2. A Simple Model/View Application If you want to develop a model/view application, where should you start? We recommend starting with a simple example and extending it step-by-step. This makes understanding the architecture a lot easier. Trying to understand the model/view architecture in detail before invoking the IDE has proven to be less convenient for many developers. It is substantially easier to start with a simple model/view application that has demo data. Give it a try! Simply replace the data in the examples below with your own. Below are 7 very simple and independent applications that show different sides of model/view programming. 2.1 A Read Only Table We start with an application that uses a QTableView to show data. We will add editing capabilities later. // main.cpp #include <QtGui/QApplication> #include <QtGui/QTableView> #include \"mymodel.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); QTableView tableView; MyModel myModel(0); tableView.setModel( &myModel ); tableView.show(); return a.exec(); } We have the usual main() function: Here is the interesting part: We create an instance of MyModel and use tableView.setModel(&myModel); to pass a pointer of it to to tableView. tableView will invoke the methods of the pointer it has received to find out two things: • How many rows and columns should be displayed. • What content should be printed into each cell. The model needs some code to respond to this. We have a table data set, so let's start with QAbstractTableModel since it is easier to use than the more general QAbstractItemModel. // mymodel.h #include <QAbstractTableModel> class MyModel : public QAbstractTableModel { Q_OBJECT public: MyModel(QObject *parent); int rowCount(const QModelIndex &parent = QModelIndex()) const ; int columnCount(const QModelIndex &parent = QModelIndex()) const; QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const; }; QAbstractTableModel requires the implementation of three abstract methods. // mymodel.cpp #include \"mymodel.h\" MyModel::MyModel(QObject *parent) :QAbstractTableModel(parent) { } int MyModel::rowCount(const QModelIndex & /*parent*/) const { return 2; } int MyModel::columnCount(const QModelIndex & /*parent*/) const { return 3; } QVariant MyModel::data(const QModelIndex &index, int role) const { if (role == Qt::DisplayRole) { return QString(\"Row%1, Column%2\") .arg(index.row() + 1) .arg(index.column() +1); } return QVariant(); } The number of rows and columns is provided by MyModel::rowCount() and MyModel::columnCount(). When the view has to know what the cell's text is, it calls the method MyModel::data(). Row and column information is specified with parameter index and the role is set to Qt::DisplayRole. Other roles are covered in the next section. In our example, the data that should be displayed is generated. In a real application, MyModel would have a member called MyData, which serves as the target for all reading and writing operations. This small example demonstrates the passive nature of a model. The model does not know when it will be used or which data is needed. It simply provides data each time the view requests it. What happens when the model's data needs to be changed? How does the view realize that data has changed and needs to be read again? The model has to emit a signal that indicates what range of cells has changed. This will be demonstrated in section 2.3. 2.2 Extending the Read Only Example with Roles In addition to controlling what text the view displays, the model also controls the text's appearance. When we slightly change the model, we get the following result: In fact, nothing except for the data() method needs to be changed to set fonts, background colour, alignment and a checkbox. Below is the data() method that produces the result shown above. Remember to include the directives #include <qdebug.h> #include <qfont.h> and #include <qbrush.h> in mymodel.cpp. The difference is that this time we use parameter int role to return different pieces of information depending on its value. // mymodel.cpp QVariant MyModel::data(const QModelIndex &index, int role) const { int row = index.row(); int col = index.column(); // generate a log message when this method gets called qDebug() << QString(\"row %1, col%2, role %3\") .arg(row).arg(col).arg(role); switch(role){ case Qt::DisplayRole: if (row == 0 && col == 1) return QString(\"<--left\"); if (row == 1 && col == 1) return QString(\"right-->\"); return QString(\"Row%1, Column%2\") .arg(row + 1) .arg(col +1); break; case Qt::FontRole: if (row == 0 && col == 0) //change font only for cell(0,0) { QFont boldFont; boldFont.setBold(true); return boldFont; } break; case Qt::BackgroundRole: if (row == 1 && col == 2) //change background only for cell(1,2) { QBrush redBackground(Qt::red); return redBackground; } break; case Qt::TextAlignmentRole: if (row == 1 && col == 1) //change text alignment only for cell(1,1) { return Qt::AlignRight + Qt::AlignVCenter; } break; case Qt::CheckStateRole: if (row == 1 && col == 0) //add a checkbox to cell(1,0) { return Qt::Checked; } } return QVariant(); } Each formatting property will be requested from the model with a separate call to the data() method. The role parameter is used to let the model know which property is being requested: enum Qt::ItemDataRole Meaning Type Qt::DisplayRole text QString Qt::FontRole font QFont BackgroundRole brush for the background of the cell QBrush Qt::TextAlignmentRole text alignment enum Qt::AlignmentFlag enum Qt::ItemDataRole Meaning Type Qt::CheckStateRole suppresses checkboxes with QVariant(), sets checkboxes with Qt::Checked or Qt::Unchecked enum Qt::ItemDataRole Now we need to determine how using a separated model impacts the application's performance, so let's trace how often the view calls the data() method. In order to track how often the view calls the model, we have put a debug statement in the data() method, which logs onto the error output stream. In our small example, data() will be called 42 times. Each time you move the cursor over the field, data() will be called again — 7 times for each cell. That's why it is important to make sure that your data is available when data() is invoked and expensive lookup operations are cached. 2.3 A Clock inside a Table Cell We still have a read only table, but this time the content changes every second because we are showing the current time. QVariant MyModel::data(const QModelIndex &index, int role) const { int row = index.row(); int col = index.column(); if (role == Qt::DisplayRole) { if (row == 0 && col == 0) { return QTime::currentTime().toString(); } } return QVariant(); } Something is missing to make the clock tick. We need to tell the view every second that the time has changed and that it needs to be read again. We do this with a timer. In the constructor, we set its interval to 1 second and connect its timeout signal. MyModel::MyModel(QObject *parent) :QAbstractTableModel(parent) { // selectedCell = 0; timer = new QTimer(this); timer->setInterval(1000); connect(timer, SIGNAL(timeout()) , this, SLOT(timerHit())); timer->start(); } Here is the corresponding slot: void MyModel::timerHit() { //we identify the top left cell QModelIndex topLeft = createIndex(0,0); //emit a signal to make the view reread identified data emit dataChanged(topLeft, topLeft); } We ask the view to read the data in the top left cell again by emitting the dataChanged() signal. Note that we did not explicitly connect the dataChanged() signal to the view. This happened automatically when we calledsetModel(). 2.4 Setting up Headers for Columns and Rows Headers can be hidden via a view method: tableView->verticalHeader()->hide(); The header content, however, is set via the model, so we re-implement the headerData() method: QVariant MyModel::headerData(int section, Qt::Orientation orientation, int role) const { if (role == Qt::DisplayRole) { if (orientation == Qt::Horizontal) { switch (section) { case 0: return QString(\"first\"); case 1: return QString(\"second\"); case 2: return QString(\"third\"); } } } return QVariant(); } Note that method headerData() also has a parameter role which has the same meaning as inMyModel::data(). 2.5 The Minimal Editing Example In this example, we are going to build an application that automatically populates a window title with content by repeating values entered into table cells. To be able to access the window title easily we put theQTableView in a QMainWindow. The model decides whether editing capabilities are available. We only have to modify the model in order for the available editing capabilities to be enabled. This is done by reimplementing the following virtual methods: setData() and flags(). // mymodel.h #include <QAbstractTableModel> #include <QString> const int COLS= 3; const int ROWS= 2; class MyModel : public QAbstractTableModel { Q_OBJECT public: MyModel(QObject *parent); int rowCount(const QModelIndex &parent = QModelIndex()) const ; int columnCount(const QModelIndex &parent = QModelIndex()) const; QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const; bool setData(const QModelIndex & index, const QVariant & value, int role = Qt::EditRole); Qt::ItemFlags flags(const QModelIndex & index) const ; private: QString m_gridData[ROWS][COLS]; //holds text entered into QTableView signals: void editCompleted(const QString &); }; We use the two-dimensional array QString m_gridData to store our data. This makes m_gridData the core of MyModel. The rest of MyModel acts like a wrapper and adapts m_gridData to theQAbstractItemModel interface. We have also introduced the editCompleted() signal, which makes it possible to transfer the modified text to the window title. bool MyModel::setData(const QModelIndex & index, const QVariant & value, int role) { if (role == Qt::EditRole) { //save value from editor to member m_gridData m_gridData[index.row()][index.column()] = value.toString(); //for presentation purposes only: build and emit a joined string QString result; for(int row= 0; row < ROWS; row++) { for(int col= 0; col < COLS; col++) { result += m_gridData[row][col] + \" \"; } } emit editCompleted( result ); } return true; } setData() will be called each time the user edits a cell. The index parameter tells us which field has been edited and value provides the result of the editing process. The role will always be set to Qt::EditRole because our cells only contain text. If a checkbox were present and user permissions are set to allow the checkbox to be selected, calls would also be made with the role set to Qt::CheckStateRole. Qt::ItemFlags MyModel::flags(const QModelIndex & /*index*/) const { return Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsEnabled ; } Various properties of a cell can be adjusted with flags(). Returning Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsEnabled is enough to show an editor that a cell can be selected. If editing one cell modifies more data than the data in that particular cell, the model must emit adataChanged() signal in order for the data that has been changed to be read. 3. Intermediate Topics 3.1 TreeView You can convert the example above into an application with a tree view. Simply replace QTableView with QTreeView, which results in a read/write tree. No changes have to be made to the model. The tree won't have any hierarchies because there aren't any hierarchies in the model itself. QListView, QTableView and QTreeView all use a model abstraction, which is a merged list, table and tree. This makes it possible to use several different types of view classes from the same model. This is how our example model looks so far: We want to present a real tree. We have wrapped our data in the examples above in order to make a model. This time we use QStandardItemModel, which is a container for hierarchical data that also implements QAbstractItemModel. To show a tree, QStandardItemModel must be populated withQStandardItems, which are able to hold all the standard properties of items like text, fonts, checkboxes or brushes. //mainwindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include <QMainWindow> QT_BEGIN_NAMESPACE // QT_BEGIN_NAMESPACE / QT_END_NAMESPACE are not needed in Qt user code class QTreeView; //forward declarations class QStandardItemModel; class QStandardItem; QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT private: QTreeView *treeView; QStandardItemModel *standardModel; QList<QStandardItem *> prepareRow( const QString &first, const QString &second, const QString &third ); public: MainWindow(QWidget *parent = 0); }; #endif // MAINWINDOW_H // modelview.cpp #include <QTreeView> #include <QStandardItemModel> #include <QStandardItem> #include \"mainwindow.h\" const int ROWS = 2; const int COLUMNS = 3; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { treeView = new QTreeView(this); setCentralWidget(treeView); standardModel = new QStandardItemModel ; QList<QStandardItem *> preparedRow =prepareRow(\"first\", \"second\", \"third\"); QStandardItem *item = standardModel->invisibleRootItem(); // adding a row to the invisible root item produces a root element item->appendRow(preparedRow); QList<QStandardItem *> secondRow =prepareRow(\"111\", \"222\", \"333\"); // adding a row to an item starts a subtree preparedRow.first()->appendRow(secondRow); treeView->setModel(standardModel); treeView->expandAll(); } QList<QStandardItem *> MainWindow::prepareRow(const QString &first, const QString &second, const QString &third) { QList<QStandardItem *> rowItems; rowItems << new QStandardItem(first); rowItems << new QStandardItem(second); rowItems << new QStandardItem(third); return rowItems; } To run your application, update the main.cpp file as follows. #include <QApplication> #include <QTreeView> #include \"mymodel.h\" #include \"mainwindow.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); //QTableView tableView; //MyModel myModel(0); //tableView.setModel(&myModel ); //tableView.show(); MainWindow w; w.show(); return a.exec(); } We simply instantiate a QStandardItemModel and add a couple of QStandardItems to the constructor. We can then make a hierarchical data structure because a QStandardItem can hold other QStandardItems. Nodes are collapsed and expanded within the view. 3.2 Working with Selections We want to access a selected item's content in order to output it into the window title together with the hierarchy level. So let's create a couple of items: update the modelview.cpp to the following code, build and run your application. #include <QTreeView> #include <QStandardItemModel> #include <QItemSelectionModel> #include \"mainwindow.h\" MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { treeView = new QTreeView(this); setCentralWidget(treeView); standardModel = new QStandardItemModel ; QStandardItem *rootNode = standardModel->invisibleRootItem(); //defining a couple of items QStandardItem *americaItem = new QStandardItem(\"America\"); QStandardItem *mexicoItem = new QStandardItem(\"Canada\"); QStandardItem *usaItem = new QStandardItem(\"USA\"); QStandardItem *bostonItem = new QStandardItem(\"Boston\"); QStandardItem *europeItem = new QStandardItem(\"Europe\"); QStandardItem *italyItem = new QStandardItem(\"Italy\"); QStandardItem *romeItem = new QStandardItem(\"Rome\"); QStandardItem *veronaItem = new QStandardItem(\"Verona\"); //building up the hierarchy rootNode-> appendRow(americaItem); rootNode-> appendRow(europeItem); americaItem-> appendRow(mexicoItem); americaItem-> appendRow(usaItem); usaItem-> appendRow(bostonItem); europeItem-> appendRow(italyItem); italyItem-> appendRow(romeItem); italyItem-> appendRow(veronaItem); //register the model treeView->setModel(standardModel); treeView->expandAll(); //selection changes shall trigger a slot QItemSelectionModel *selectionModel= treeView->selectionModel(); connect(selectionModel, SIGNAL(selectionChanged (const QItemSelection &, const QItemSelection &)), this, SLOT(selectionChangedSlot(const QItemSelection &, const QItemSelection &))); } Views manage selections within a separate selection model, which can be retrieved with the selectionModel() method. We retrieve the selection Model in order to connect a slot to its selectionChanged() signal. void MainWindow::selectionChangedSlot(const QItemSelection & /*newSelection*/, const QItemSelection & /*oldSelection*/) { //get the text of the selected item const QModelIndex index = treeView->selectionModel()->currentIndex(); QString selectedText = index.data(Qt::DisplayRole).toString(); //find out the hierarchy level of the selected item int hierarchyLevel=1; QModelIndex seekRoot = index; while(seekRoot.parent() != QModelIndex()) { seekRoot = seekRoot.parent(); hierarchyLevel++; } QString showString = QString(\"%1, Level %2\").arg(selectedText) .arg(hierarchyLevel); setWindowTitle(showString); } We get the model index that corresponds to the selection by calling treeView->selectionModel()->currentIndex() and we get the field's string by using the model index. Then we just calculate the item's hierarchyLevel. Top level items do not have parents and the parent() method will return a default constructed QModelIndex(). This is why we use the parent() method to iterate to the top level while counting the steps performed during iteration. The selection model (as shown above) can be retrieved, but it can also be set withQAbstractItemView::setSelectionModel. This is how it's possible to have 3 view classes with synchronised selections because only one instance of a selection model is used. To share a selection model between 3 views use selectionModel() and assign the result to the second and third view class withsetSelectionModel(). Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Model/View Tutorial Every UI developer should know about ModelView programming and the goal of this tutorial is to provide you with an easily understandable introduction to this topic. Table, list and tree widgets are components frequently used in GUIs. There are 2 different ways how these widgets can access their data. The traditional way involves widgets which include internal containers for storing data. This approach is very intuitive, however, in many non-trivial applications, it leads to data synchronization issues. The second approach is model/view programming, in which widgets do not maintain internal data containers. They access external data through a standardized interface and therefore avoid data duplication. This may seem complicated at first, but once you take a closer look, it is not only easy to grasp, but the many benefits of model/view programming also become clearer. In the process, we will learn about some basic technologies provided by Qt, such as: • The difference between standard and model/view widgets Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 • Adapters betweeen forms and models • Developing a simple model/view application • Predefined models • Intermediate topics such as: o Tree views o Selection o Delegates o Debugging with model test You will also learn whether your new application can be written easier with model/view programming or if classic widgets will work just as well. This tutorial includes example code for you to edit and integrate into your project. 1. Introduction Model/View is a technology used to separate data from views in widgets that handle data sets. Standard widgets are not designed for separating data from views and this is why Qt 4 has two different types of widgets. Both types of widgets look the same, but they interact with data differently. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Standard widgets use data that is part of the widget. View classes operate on external data (the model) 1.1 Standard Widgets Let's have a closer look at a standard table widget. A table widget is a 2D array of the data elements that the user can change. The table widget can be integrated into a program flow by reading and writing the data elements that the table widget provides. This method is very intuitive and useful in many applications, but displaying and editing a database table with a standard table widget can be problematic. Two copies of the data have to be coordinated: one outside the widget; one inside the widget. The developer is responsible for synchronizing both versions. Besides this, the tight coupling of presentation and data makes it harder to write unit tests. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 1.2 Model/View to the Rescue Model/view stepped up to provide a solution that uses a more versatile architecture. Model/view eliminates the data consistency problems that may occur with standard widgets. Model/view also makes it easier to use more than one view of the same data because one model can be passed on to many views. The most important difference is that model/view widgets do not store data behind the table cells. In fact, they operate directly from your data. Since view classes do not know your data's structure, you need to provide a wrapper to make your data conform to the QAbstractItemModel interface. A view uses this interface to read from and write to your data. Any instance of a class that implements QAbstractItemModel is said to be a model. Once the view receives a pointer to a model, it will read and display its content and be its editor. 1.3 Overview of the Model/View Widgets Here is an overview of the model/view widgets and their corresponding standard widgets. Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QListWidget QListView Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QTableWidget QTableView QTreeWidget QTreeView Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QColumnView shows a tree as a hierarchy of lists QComboBox can work as both a view class and also as a traditional widget 1.4 Using Adapters between Forms and Models Having adapters between forms and models can come in handy. We can edit data stored in tables directly from within the table itself, but it's much more comfortable to edit data in text fields. There is no direct model/view counterpart that separates data and views for widgets that operate on one value (QLineEdit, QCheckBox ...) instead of a dataset, so we need an adapter in order to connect the form to the source of data. QDataWidgetMapper is a great solution because it maps form widgets to a table row and makes it very easy to build forms for database tables. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Another example of an adapter is QCompleter. Qt has QCompleter for providing auto-completions in Qt widgets such as QComboBox and, as shown below, QLineEdit. QCompleter uses a model as its data source. 2. A Simple Model/View Application Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 If you want to develop a model/view application, where should you start? We recommend starting with a simple example and extending it step-by-step. This makes understanding the architecture a lot easier. Trying to understand the model/view architecture in detail before invoking the IDE has proven to be less convenient for many developers. It is substantially easier to start with a simple model/view application that has demo data. Give it a try! Simply replace the data in the examples below with your own. Below are 7 very simple and independent applications that show different sides of model/view programming. 2.1 A Read Only Table We start with an application that uses a QTableView to show data. We will add editing capabilities later. // main.cpp #include <QtGui/QApplication> #include <QtGui/QTableView> #include \"mymodel.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); QTableView tableView; MyModel myModel(0); tableView.setModel( &myModel ); tableView.show(); return a.exec(); } We have the usual main() function: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Here is the interesting part: We create an instance of MyModel and use tableView.setModel(&myModel); to pass a pointer of it to to tableView. tableView will invoke the methods of the pointer it has received to find out two things: • How many rows and columns should be displayed. • What content should be printed into each cell. The model needs some code to respond to this. We have a table data set, so let's start with QAbstractTableModel since it is easier to use than the more general QAbstractItemModel. // mymodel.h #include <QAbstractTableModel> class MyModel : public QAbstractTableModel { Q_OBJECT public: MyModel(QObject *parent); int rowCount(const QModelIndex &parent = QModelIndex()) const ; int columnCount(const QModelIndex &parent = QModelIndex()) const; QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const; }; QAbstractTableModel requires the implementation of three abstract methods. // mymodel.cpp #include \"mymodel.h\" Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 MyModel::MyModel(QObject *parent) :QAbstractTableModel(parent) { } int MyModel::rowCount(const QModelIndex & /*parent*/) const { return 2; } int MyModel::columnCount(const QModelIndex & /*parent*/) const { return 3; } QVariant MyModel::data(const QModelIndex &index, int role) const { if (role == Qt::DisplayRole) { return QString(\"Row%1, Column%2\") .arg(index.row() + 1) .arg(index.column() +1); } return QVariant(); } The number of rows and columns is provided by MyModel::rowCount() and MyModel::columnCount(). When the view has to know what the cell's text is, it calls the method MyModel::data(). Row and column information is specified with parameter index and the role is set to Qt::DisplayRole. Other roles are covered in the next section. In our example, the data that should be displayed is Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 generated. In a real application, MyModel would have a member called MyData, which serves as the target for all reading and writing operations. This small example demonstrates the passive nature of a model. The model does not know when it will be used or which data is needed. It simply provides data each time the view requests it. What happens when the model's data needs to be changed? How does the view realize that data has changed and needs to be read again? The model has to emit a signal that indicates what range of cells has changed. This will be demonstrated in section 2.3. 2.2 Extending the Read Only Example with Roles In addition to controlling what text the view displays, the model also controls the text's appearance. When we slightly change the model, we get the following result: In fact, nothing except for the data() method needs to be changed to set fonts, background colour, alignment and a checkbox. Below is the data() method that produces the result shown above. Remember to include the directives #include <qdebug.h> #include <qfont.h> and #include <qbrush.h> in mymodel.cpp. The difference is that this time we use parameter int role to return different pieces of information depending on its value. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 // mymodel.cpp QVariant MyModel::data(const QModelIndex &index, int role) const { int row = index.row(); int col = index.column(); // generate a log message when this method gets called qDebug() << QString(\"row %1, col%2, role %3\") .arg(row).arg(col).arg(role); switch(role){ case Qt::DisplayRole: if (row == 0 && col == 1) return QString(\"<--left\"); if (row == 1 && col == 1) return QString(\"right-->\"); return QString(\"Row%1, Column%2\") .arg(row + 1) .arg(col +1); break; case Qt::FontRole: if (row == 0 && col == 0) //change font only for cell(0,0) { QFont boldFont; boldFont.setBold(true); return boldFont; } break; case Qt::BackgroundRole: if (row == 1 && col == 2) //change background only for cell(1,2) { QBrush redBackground(Qt::red); Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 return redBackground; } break; case Qt::TextAlignmentRole: if (row == 1 && col == 1) //change text alignment only for cell(1,1) { return Qt::AlignRight + Qt::AlignVCenter; } break; case Qt::CheckStateRole: if (row == 1 && col == 0) //add a checkbox to cell(1,0) { return Qt::Checked; } } return QVariant(); } Each formatting property will be requested from the model with a separate call to the data() method. The role parameter is used to let the model know which property is being requested: enum Qt::ItemDataRole Meaning Type Qt::DisplayRole text QString Qt::FontRole font QFont BackgroundRole brush for the background of the cell QBrush Qt::TextAlignmentRole text alignment enum Qt::AlignmentFlag Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 enum Qt::ItemDataRole Meaning Type Qt::CheckStateRole suppresses checkboxes with QVariant(), sets checkboxes with Qt::Checked or Qt::Unchecked enum Qt::ItemDataRole Now we need to determine how using a separated model impacts the application's performance, so let's trace how often the view calls the data() method. In order to track how often the view calls the model, we have put a debug statement in the data() method, which logs onto the error output stream. In our small example, data() will be called 42 times. Each time you move the cursor over the field, data() will be called again — 7 times for each cell. That's why it is important to make sure that your data is available when data() is invoked and expensive lookup operations are cached. 2.3 A Clock inside a Table Cell We still have a read only table, but this time the content changes every second because we are showing the current time. QVariant MyModel::data(const QModelIndex &index, int role) const { int row = index.row(); Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 int col = index.column(); if (role == Qt::DisplayRole) { if (row == 0 && col == 0) { return QTime::currentTime().toString(); } } return QVariant(); } Something is missing to make the clock tick. We need to tell the view every second that the time has changed and that it needs to be read again. We do this with a timer. In the constructor, we set its interval to 1 second and connect its timeout signal. MyModel::MyModel(QObject *parent) :QAbstractTableModel(parent) { // selectedCell = 0; timer = new QTimer(this); timer->setInterval(1000); connect(timer, SIGNAL(timeout()) , this, SLOT(timerHit())); timer->start(); } Here is the corresponding slot: void MyModel::timerHit() { //we identify the top left cell QModelIndex topLeft = createIndex(0,0); Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 //emit a signal to make the view reread identified data emit dataChanged(topLeft, topLeft); } We ask the view to read the data in the top left cell again by emitting the dataChanged() signal. Note that we did not explicitly connect the dataChanged() signal to the view. This happened automatically when we calledsetModel(). 2.4 Setting up Headers for Columns and Rows Headers can be hidden via a view method: tableView->verticalHeader()->hide(); The header content, however, is set via the model, so we re-implement the headerData() method: QVariant MyModel::headerData(int section, Qt::Orientation orientation, int role) const { if (role == Qt::DisplayRole) { if (orientation == Qt::Horizontal) { switch (section) { Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 case 0: return QString(\"first\"); case 1: return QString(\"second\"); case 2: return QString(\"third\"); } } } return QVariant(); } Note that method headerData() also has a parameter role which has the same meaning as inMyModel::data(). 2.5 The Minimal Editing Example In this example, we are going to build an application that automatically populates a window title with content by repeating values entered into table cells. To be able to access the window title easily we put theQTableView in a QMainWindow. The model decides whether editing capabilities are available. We only have to modify the model in order for the available editing capabilities to be enabled. This is done by reimplementing the following virtual methods: setData() and flags(). // mymodel.h #include <QAbstractTableModel> #include <QString> const int COLS= 3; const int ROWS= 2; class MyModel : public QAbstractTableModel Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 { Q_OBJECT public: MyModel(QObject *parent); int rowCount(const QModelIndex &parent = QModelIndex()) const ; int columnCount(const QModelIndex &parent = QModelIndex()) const; QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const; bool setData(const QModelIndex & index, const QVariant & value, int role = Qt::EditRole); Qt::ItemFlags flags(const QModelIndex & index) const ; private: QString m_gridData[ROWS][COLS]; //holds text entered into QTableView signals: void editCompleted(const QString &); }; We use the two-dimensional array QString m_gridData to store our data. This makes m_gridData the core of MyModel. The rest of MyModel acts like a wrapper and adapts m_gridData to theQAbstractItemModel interface. We have also introduced the editCompleted() signal, which makes it possible to transfer the modified text to the window title. bool MyModel::setData(const QModelIndex & index, const QVariant & value, int role) { if (role == Qt::EditRole) { //save value from editor to member m_gridData m_gridData[index.row()][index.column()] = value.toString(); //for presentation purposes only: build and emit a joined string QString result; for(int row= 0; row < ROWS; row++) { for(int col= 0; col < COLS; col++) Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 { result += m_gridData[row][col] + \" \"; } } emit editCompleted( result ); } return true; } setData() will be called each time the user edits a cell. The index parameter tells us which field has been edited and value provides the result of the editing process. The role will always be set to Qt::EditRole because our cells only contain text. If a checkbox were present and user permissions are set to allow the checkbox to be selected, calls would also be made with the role set to Qt::CheckStateRole. Qt::ItemFlags MyModel::flags(const QModelIndex & /*index*/) const { return Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsEnabled ; } Various properties of a cell can be adjusted with flags(). Returning Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsEnabled is enough to show an editor that a cell can be selected. If editing one cell modifies more data than the data in that particular cell, the model must emit adataChanged() signal in order for the data that has been changed to be read. 3. Intermediate Topics Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 3.1 TreeView You can convert the example above into an application with a tree view. Simply replace QTableView with QTreeView, which results in a read/write tree. No changes have to be made to the model. The tree won't have any hierarchies because there aren't any hierarchies in the model itself. QListView, QTableView and QTreeView all use a model abstraction, which is a merged list, table and tree. This makes it possible to use several different types of view classes from the same model. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 This is how our example model looks so far: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 We want to present a real tree. We have wrapped our data in the examples above in order to make a model. This time we use QStandardItemModel, which is a container for hierarchical data that also implements QAbstractItemModel. To show a tree, QStandardItemModel must be populated withQStandardItems, which are able to hold all the standard properties of items like text, fonts, checkboxes or brushes. //mainwindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include <QMainWindow> QT_BEGIN_NAMESPACE // QT_BEGIN_NAMESPACE / QT_END_NAMESPACE are not needed in Qt user code class QTreeView; //forward declarations class QStandardItemModel; class QStandardItem; QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT private: QTreeView *treeView; QStandardItemModel *standardModel; Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 QList<QStandardItem *> prepareRow( const QString &first, const QString &second, const QString &third ); public: MainWindow(QWidget *parent = 0); }; #endif // MAINWINDOW_H // modelview.cpp #include <QTreeView> #include <QStandardItemModel> #include <QStandardItem> #include \"mainwindow.h\" const int ROWS = 2; const int COLUMNS = 3; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { treeView = new QTreeView(this); setCentralWidget(treeView); standardModel = new QStandardItemModel ; QList<QStandardItem *> preparedRow =prepareRow(\"first\", \"second\", \"third\"); QStandardItem *item = standardModel->invisibleRootItem(); // adding a row to the invisible root item produces a root element item->appendRow(preparedRow); QList<QStandardItem *> secondRow =prepareRow(\"111\", \"222\", \"333\"); // adding a row to an item starts a subtree preparedRow.first()->appendRow(secondRow); Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 treeView->setModel(standardModel); treeView->expandAll(); } QList<QStandardItem *> MainWindow::prepareRow(const QString &first, const QString &second, const QString &third) { QList<QStandardItem *> rowItems; rowItems << new QStandardItem(first); rowItems << new QStandardItem(second); rowItems << new QStandardItem(third); return rowItems; } To run your application, update the main.cpp file as follows. #include <QApplication> #include <QTreeView> #include \"mymodel.h\" #include \"mainwindow.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); //QTableView tableView; //MyModel myModel(0); //tableView.setModel(&myModel ); //tableView.show(); MainWindow w; w.show(); return a.exec(); } Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 We simply instantiate a QStandardItemModel and add a couple of QStandardItems to the constructor. We can then make a hierarchical data structure because a QStandardItem can hold other QStandardItems. Nodes are collapsed and expanded within the view. 3.2 Working with Selections We want to access a selected item's content in order to output it into the window title together with the hierarchy level. So let's create a couple of items: update the modelview.cpp to the following code, build and run your application. #include <QTreeView> #include <QStandardItemModel> #include <QItemSelectionModel> #include \"mainwindow.h\" Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { treeView = new QTreeView(this); setCentralWidget(treeView); standardModel = new QStandardItemModel ; QStandardItem *rootNode = standardModel->invisibleRootItem(); //defining a couple of items QStandardItem *americaItem = new QStandardItem(\"America\"); QStandardItem *mexicoItem = new QStandardItem(\"Canada\"); QStandardItem *usaItem = new QStandardItem(\"USA\"); QStandardItem *bostonItem = new QStandardItem(\"Boston\"); QStandardItem *europeItem = new QStandardItem(\"Europe\"); QStandardItem *italyItem = new QStandardItem(\"Italy\"); QStandardItem *romeItem = new QStandardItem(\"Rome\"); QStandardItem *veronaItem = new QStandardItem(\"Verona\"); //building up the hierarchy rootNode-> appendRow(americaItem); rootNode-> appendRow(europeItem); americaItem-> appendRow(mexicoItem); americaItem-> appendRow(usaItem); usaItem-> appendRow(bostonItem); europeItem-> appendRow(italyItem); italyItem-> appendRow(romeItem); italyItem-> appendRow(veronaItem); //register the model treeView->setModel(standardModel); treeView->expandAll(); Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 //selection changes shall trigger a slot QItemSelectionModel *selectionModel= treeView->selectionModel(); connect(selectionModel, SIGNAL(selectionChanged (const QItemSelection &, const QItemSelection &)), this, SLOT(selectionChangedSlot(const QItemSelection &, const QItemSelection &))); } Views manage selections within a separate selection model, which can be retrieved with the selectionModel() method. We retrieve the selection Model in order to connect a slot to its selectionChanged() signal. void MainWindow::selectionChangedSlot(const QItemSelection & /*newSelection*/, const QItemSelection & /*oldSelection*/) { //get the text of the selected item const QModelIndex index = treeView->selectionModel()->currentIndex(); QString selectedText = index.data(Qt::DisplayRole).toString(); //find out the hierarchy level of the selected item int hierarchyLevel=1; QModelIndex seekRoot = index; while(seekRoot.parent() != QModelIndex()) { seekRoot = seekRoot.parent(); hierarchyLevel++; } QString showString = QString(\"%1, Level %2\").arg(selectedText) .arg(hierarchyLevel); setWindowTitle(showString); } We get the model index that corresponds to the selection by calling treeView->selectionModel()->currentIndex() and we get the field's string by using the model index. Then we just calculate the item's hierarchyLevel. Top level items do not have parents and Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 the parent() method will return a default constructed QModelIndex(). This is why we use the parent() method to iterate to the top level while counting the steps performed during iteration. The selection model (as shown above) can be retrieved, but it can also be set withQAbstractItemView::setSelectionModel. This is how it's possible to have 3 view classes with synchronised selections because only one instance of a selection model is used. To share a selection model between 3 views use selectionModel() and assign the result to the second and third view class withsetSelectionModel(). Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588Design Pattern in Qt4Design Pattern in Qt4More Design Patternse-Tutor COS3711 –Ch 16 Libraries Groups code modules, reusable Pre-compiled programming codes ready for use Design Patterns Efficient and elegant solutions to common problems Structural = how organize objects + connect them Behavioral = how organize code Creational = how organize code to manage object creation Serializer Pattern Responsible reading and writing objects QTextStream = read + write human-readablefiles QDataStream = read + write structured data binary Client Class1Reader Class1Writer +read(Class1) Class1 +writer(Class1) ANTIPATTERNS Common used programming practices/solutions to recurring programming problems that is ineffective/inefficient 1) Software Design antiPattern > Input kludge – failing handling invalid input > Interface bloat – interface powerful/complicated, hard to reuse > Race hazard – fail see consequence order of events 2) Object-oriented design antiPattern > Circular dependency – mutual dependencies between objects > God object – too much information/responsibility 3) Programming antiPattern > Hard coding – embedding assumptions > Magic numbers – unexplained numbers > Magic strings – literal strings 4) Methodological antiPattern > Copy + paste programming – existing code > Reinvent the (square) wheel – existing solution Included in project with directive #include System program caller linker establish link between program and library code at run time lib file ease job of linker – contains compiled/object files, ease linking process of library items and program codeFramework and Design Pattern Framework is large colletion components and conventions documented public API Qt is a framework – framework implemented with design patterns Design patterns efficient solution to common problems QMetaObject Meta object describe structure of another object MetaObject Pattern (Reflective pattern): information about properties and methods of QObject Q_PROPERTY macro Describe QObject Properties Access data members: > Direct (getters and setters) – faster more efficient > Indirect (QObject / QMetaObject interface) – more reusable code Q_PROPERTY (type name READ getFunction [WRITE setfunction] [RESET resetFunction] [NOTIFY ntifySignal]) [. . . .] Customer::Customer(const QString name, QObject * parent) :QObject(parent){ setObjectName(name); } Void Customer::setId(const QString &newId){ if (newId !- m_id) { Qstring oldId = m_id; m_id = newId; emit valueChanged( id newId, oldId); } Void Customer::setType(CustomerType theType){ if (m_Type != theType) { CustomerType oldType = m_type; m_Type = theType; } Void TestCustomerProps::test() { Customer cust; cust.setObjectName( Customer cust.setName( Falafal cust.setType( Government //enumproperty as string QString originalId = cust.setId(orifinalId); QVariant V = cust.propert id QString str = v.toString(); return; } Class Customer: public QObject{ Q_OBJECT Q_PROPERTY (QString id READ getID WRITE setID NOTIFY valueChanged) Q_PROPERTY (QString name READ getName WRITE setName) Q_PROPERTY (CustomerType type READ getType WRITE setType) Q_PROPERTY (Qdate dateEstablished READ getDateEstablished) //read-only public: enum CustomerType {Corporate, Individual, Educational, Government}; Q_ENUMS(CustomerType); explicit Customer (const QString name = QString(), QObject * parent = 0); QString getId() const { return m_id; } QString getName() const { return m_name; } CustomerType getType() const { return m_type; } private: QString m_id, m_name; CustomerType m_type; }; [. . . .] Using reflective programming, can write general-purpose operations work on classes of varied structures. To make class reflective: Inherit from QObject Include Q_OBJECT macro Q_PROPERY(QString name READ getName WRITE setName) [. . . .] /* Method for setting enum values from Strings */ Void Customer::setType (Qstring newType){ 1 static const QMetaObject* meta = metaObject(); 2 static int propindex = meta->indexOfProperty( type static const QMetaProperty mp = meta->property(propindex); QMetaEnum menum = mp.enumerator(); const char* ntype = newType.toAscii().data(); 3 CustomerType theType = static_cast<CustomerType>(menum.keyToValue(ntyp)); if (theType != m_type) { 4 CustomerType oldType = m_type; m_type = theType; emit valueChanged( type theType, oldType); } } 1 Overloaded version accept string as argument. Set value -1 if unknown. 2 Static locals, initializations happen only once. 3 Executed each time 4 Check if valueChanged signal needed What kinds of information can you obtain from a QMetaObject? className(), which returns the class name as a const char* superClass(), which returns a pointer to the QMetaObject of the base class if there is one (or 0 if there is not) methodCount(), which returns the number of member functions of the class method(index), which returns the meta-data for the method with the given index propertyCount(), which returns the number of properties in this class, including base class properties. property(index), which returns the meta-data for the property with the given index. What Qt classes are used to do data reflection? QMetaObject, QMetaProperty, QSqlDatabase::tables, QSqlRecord, Qvariant How does the QMetaObject code for each of your QObject-derived classes get generated? moc generates QMetaObject classes to support properties, signals and slots. Normally, you do not run moc directly. It is run automatically by make on the header files listed in HEADERS which use the Q_OBJECT macro. What are the advantages of using property() and setProperty() over direct getters and setters? Q_PROPERTY macros make it possible for moc to generate code for QObject's property() and setProperty() member functions. The advantage of using these functions is that client code can determine which properties are available by iterating through QMetaProperty objects of the QMetaObject corresponding to that class. What does the property() function return? How do you obtain the actual stored value? property() returns a QVariant, which is a union wrapper around every possible basic type, and also several Qt classes/types. With QVariant, you can ask for its type() and convert to the actual value<>(). Benefits are most apparent when implementing script engines or developer tools. It becomes possible to define \"handle anything\" kinds of functions without using anything but the QObject interface to read and write values. Explain how it is possible to add new properties, acquired at runtime, to a Qobject setProperty(\"propName\") sets a dynamic property for that object even if it is not declared as a Q_PROPERTY Explain how dynamic properties can be serialized They are stored in a QVariantMap, which can be serialized via a QDataStream. QDataStream out(...); QVariant v(123); // The variant now contains an int int x = v.toInt(); // x = 123 out << v; // Writes a type tag and an int to out v = QVariant(\"hello\"); // The variant now contains a QByteArray v = QVariant(tr(\"hello\")); // The variant now contains a QString int y = v.toInt(); // y = 0 since v cannot be converted to an int QString s = v.toString(); // s = tr(\"hello\") (see QObject::tr()) out << v; // Writes a type tag and a QString to out ... QDataStream in(...); // (opening the previously written stream) in >> v; // Reads an Int variant int z = v.toInt(); // z = 123 qDebug(\"Type is %s\", // prints \"Type is int\" v.typeName()); v = v.toInt() + 100; // The variant now hold the value 223 v = QVariant(QStringList()); QMetaObject Qt support reflective programming via QMetaObject Provides generic interface through which state of any Qobject accessed and manipulated Instance of QMetaObject class used as mirror reflect and change stated of Qobjects without manupulating Qobject directly Qobject Person -name:Qstring -birthDate:QDate +Person() +Person(QString, Qdate) +getName():Qstring +getBirthDate():Qdate +setName(Qstring) +setBirthDate(Qdate) Product -name:Qstring -price:double +Product() +Product(QString, double) +getName():Qstring +getPrice():double +setName(Qstring) +setPrice(double) writeToFile(Qobject*); Class Person: public Qobject { Q_OBJECT Q_PROPERTY(Qstring name READ getName WRITE setName) Q_PROPERTY(Qdate birth READ getBirthDate WRITE setBirthDate) public: Person(); Person(Qstring n, Qdated); Qstring getName()const; Qdate getBirthDate()const; void setName(Qstring n); void setBirthDate(QDate d); private: QString name; Qdate birthDate; }; Person * person = newPerson; writeToFile(person); Product* product = new Product; writeToFile(product); writeToFile(Qobject *obj){ QFile file( dat.txt file.open(QIODevide::Append); QTextStreamtoFile(&file); const QMetaObject *mo = obj->metaObject(); for (int i=mo->propertyOffset(); i<mo-propertyCount();i++) { const QMetaProperty prop = mo->property(i); QString name = prop.name(); QVariant value = prop.read(obj); Qstring valStr = value.toString(); toFile << name << valStr << endl; } file.close(); } Models and Views Separate underlying data class (model) from GUI (view) Data View Standard Widgets ->use data as part of widget View class operate external data (model) Model View setModel() Data • Separate model from view – reduces complexity • Different maintenance imperatives – easier maintain both kept separate • Possible maintain different, consistent views of same data • Different, consistent views of same data • Do not store data • Do not know data structure Standard Widgets: • Two copies data: one outside widget, one inside • Synchronize both • Tight coupling present data, hard write unit test Example QFileSystemModeluser QTreeView: #include <QtGui> int main(int argc, char *argv[]){ Qapplication app(argc, argv); QFileSystemModel model; model.setRootPath( QTreeView tree; tree.setModel(&model); tree.setSortingEnabled(true); tree.header()->setResizeModel(QHeaderView:: ResizeToContent); tree.resize(640, 480); tree.show(); return app.exec(); } MVC consists of three kinds of objects. 1) Model = application object 2) View = screen presentation 3) Controller = defines way user interface reacts to user input QFileSystemModel in a QTreeView QFileSystemModel is already populated with data, so we can simply create one, create a view, and view->setModel(model). #include <QtGui> int main(int argc, char *argv[]) { QApplication app(argc, argv); QFileSystemModel model; model.setRootPath(\"/\"); QTreeView tree; tree.setModel(&model); tree.setSortingEnabled(true); 1 tree.header()- >setResizeMode(QHeaderView::ResizeToContents); tree.resize(640, 480); tree.show(); return app.exec(); } //1 - Enable HeaderView sort buttons. Qt provides its model-view architecture to separate models and view. In this architecture a number of abstract and concrete model and view classes are provided. Though this architecture supports the separation of model/logic from the views, it does not provide controller classes like the classic MVC pattern. Qt s model-view architecture uses signals and slots for the communication between models and views. A model class in Qt either has the data or communicates with the data source. In order to make use of Qt s model-view architecture one has to either use the built-in, concrete model or view classes or implement a model or view class derived from model/view interfaces provided in Qt. In order to make use of the architecture the view has to be set up with a model. In other words, view has a model and not the other way around. In a sense, Qt replaces the controller in its model-view architecture with delegates that are responsible for the rendering/display and editing of model data in a view. Validate Regular Expression QLineEdit validate input: A > ASCII alphabetic character N > ASCII alphanumeric character X > ASCII any character D > ASCII nonzero digit 9 > ASCII digit # > Hexadecimal digit B > Binary digit Validators = attached to input widgets 1) QDoubleValidator = floating point 2) QIntValidator = integer 3) QRegExpValidator = text regular expression int main (int argc, char* argv[]){ QApplication app(argc, argv); QLineEdit e; e.setIntputMask( - - - e.show(); return app.exec(); } int main (int argc, char* argv[]){ QApplication app(argc, argv); QLineEdit e; QIntValidator *v = new QIntValidator(0,100); e.setValidator(v); e.show(); return app.exec(); } Regular Expression Special characters . any character \\n newline \\f form feed \\t tab \\xhhhh hex Quantifiers + 1 or more ? 0 or 1 * 0 or more {i, j} at leat i, no more than j Chracter Sets: \\S white space \\S non-whitepace \\d digital 0 to 9 \\D non-digital \\w any word character (letter/ digit/underscore) \\W non-word character [AEIOU] match A, E, I, O, U [a-g] range from a to g [^xyz] except x, y, z QLineEdit e; QRegExp re( a-zA-Z][_a-zA-Z0-9]+ QRegExpValidator *v = new QRegExpValidator(re); e.setValidator(v); e.show(); Consist 4 digits (0-9): d{4} Consist 6 character, forst 3 alphabetic, last 3 digits A-Za-z]{3}[0-9]{3} Minimum 4, max 6 characters, except0, z and Z zZ]{4,6} Parsing Xml Each <tag> must have closing </tag> Or selfclosing <br/> NB: Case-sensitive Tags with attributes: <library> <book title = Computer Algorithm pages = <book title = C++ unleashed pages = </library> Tags with text: <library> <book> <title>Computer Algotithm</title> <pages>688</pages> </book> <book> <title>C++ unleashed</title> <pages>918</pages> </book> </library> • Event driven • Low-level • Sequential-access while parsing document • Any file size • Forward direction QT+ - xml QXmlReader +parse() QXmlSimpleReader QXmlContentHandler +startDocument() +endDocument() +startElement() +endElement() +characters QXmlDefaultHandler MyHandler SAX #include <QXmlDefaultHandler> class Qstring; class MyHandler:public QXmlDefaultHandler{ public: bool startDocument(); bool startElement(const Qstring & namespaceURI, const QString & LocalName, const QString & qName, const QXmlAttributes & atts); bool characters (const QString & text); bool endElement (const QString & namespaceURI, const QString & localName, const QString & qName); private: QString indents; }; Myhandler.cpp QTextStream cout(stdout); bool MyHandler::startDocument(){ indent = return TRUE;} bool MyHandler::characters(const Qstring & text){ QString t = text; cout << t.remove( n Bool MayHandler::startElement(const Qstring & namespaceURI, const QString & LocalName, const QString & qName, const QXmlAttributes & atts){ QString str = QString n%1\\\\%2).arg(indent).arg(qName); cout << str; if (atts.lenght()>0){ QString fildName = atts.qName(0); cout << QString .arg(fieldName).arg(fieldName); } cout << indent += return TRUE; } Three ways parse XML: Qt s XML module: 1) SAX (Simple API for XML) – parse event-driven 2) DOM (Document Object Module) – tree-style parse 3) Stream-style parsing with QXmlStreamReader DOM • XML elements as objects in tree structure • File in memory, limit RAM • Random access • Not handle parse errors • Creating documents Writing using DOM: 1) Create document (QDomDucument) 2) Create root element 3) for each contact, put in document 4) Write result to file Write to file: (open filem create text stream, call toStrin() method of DOM document) int main (int argc, char **argv){ QApplication a (argc, argv); QDomDocument doc AdBookML QDomElement root = doc.createElement adbook doc.appendChild(root); Contact c; c.name = Kal c.eMail = kal@gateborg.se c.phone = root.appendChaild(ContactToNode(doc, c)); QFile file c:/qt/text/xml if (file.open(Qfile::WriteOnly)) return -1; QTextStream ts(&file); ts << doc.toString(); file.close(); return 0; } Reading using DOM: 1) Create DOM document from file 2) Find root 3) Find children (elements) 4) Find attributes Reading file: QDomDocument doc adBookML Qfile file test.xml if (!file.open(IO_ReadOnly) return -1; file.close; Find root element: QDomElement root = doc.documentElement(); if (root.tagNam() != adbook return -3; Find element, check attributes: QDomNode n – root.firstChild(); while (!n.isNull()){ QDomElement e = n.toElement(); if (!e.isNull()){ if (e.tagName() == contact Contact c; c.name = e.attribute( name c.phone = e.attribute( phone c.eMail = e.attribute( email } } n = n.nextSibling(); } Create Document: QDomDocument doc adBookML Create root element: root element point to start root element called adbook QDomElement root = doc.creeateElement( adbook doc.appendChild(root); Each contact put in document: QDomElement ConstactToNode( QDomDocument &d, const Contact & c){ QDomElement cn = d.createElement( contract cn.setAttribute( name c.name); cn.setAttribute( phone c.phone); cn.setAttribute( email c.eMail); return cn; } Design Patterns Creational Patterns: Manage object creation during runtime, manage object deletion Factory Method Product Factory FactoryMethod(): Product Operation() ConcreteProduct ConcreteFactory FactoryMethod():product . . . Product = FactoryMethod() . . . return newConcreteProductcreate Bread WhiteBread BrownBread WholewheatBread AbstractBreadFactory BreadFactory Client +makeBread(QString):Bread + makeBread(Qstring):Bread - Bread *myBread +bake() uses create uses AbstractFactory Abstract Factory Pattern AbstractProductA Client ProductA1 ProductA2 createProductA() createProductB() AbstractProductB ProductB1 ProductB2 ConcreteFactory2 createProductA() createProductB() ConcreteFactory1 createPRoductA() createProductB() Singleton Class has only one instance, accessed via global access point Make constructor Private, creating one instance Class A { public: static A* getInstance(); private: A(); static A* onlyInstance; } A*A::onlyInstance = NULL; A::A(){} A*A::getInstance(){ if(onlyInstance == 0) onlyInstance = new A(); return onlyInstance; } Memento Pattern Object storing snapshot of internal state of another object Object state restored, allow undo/rollback operation Originator Memento Caretaker Object know how to save itself Object written and read by originator Object holds memento for originator state = m -> getState() Originator setMemento(Memento m) createMemento() state Memento getState() setState() state Caretaker Return new Memento(state) Memento Stares state of Originator Caretaker Keep Memento • Role of Caretaker store Memento, not allowed access state of Originator. • Achieved by making getState(), setState() and constructor of Memento provate, Caretaker cannot access state of Originator. • Originator need able access construcotr, getState() and setState() of Memento. Achieved making Originator friend of Memento. Class Memento { public: private: friend class Person; Memento(); QStringList getState(); void setState(QStringList s); QStringList state; }; Memento Person::createMemento() const { QStringList state; state << name << birthDate.toString(); Memento mem; mem.setState(state); return mem; } Void Person::setMemento(Memento m) { QStringList s = m.getState(); name = s.at(0); birthDate = QDate::fromString(s.at(1)); } int main(int argc, char *argv[]) { Person p( John Qdate(1990,12,25)); //create memento Memento caretaker = p.createMemento(); //change Person p //restore Memento p.setMemento(caretaler); } Façade Pattern Unified interface to set of interfaces in subsystem Defines higher-level interface making subsystem easier useConcurrency Similar in concept: start() function cause execution, fork (two things happening QProcess Qthread Runs different program Runs same process, share In same process, separate code, share memory with memery other threads Communicate with child Share memory and code Process via streams with peer threads. Sync (stdin, stdout stderr) locks, wait conditions, Pass data using command mutexes, semaphores Line arguments Managed by operating Managed by process system #include <QObject> #include <QProcess> class LogTail: public Qprocess { Q_OBJECT public: LogTail (Qstring fn=Qstring()); ~LogTail(); signals: void LogString() public slots: void LogOutPut(); }; LogTail::LogTail (Qstring fn){ connect (this SIGNAL (readyReadStandardOutput()), this SLOT (logOutput())); QString argv; argv << -f fn; start tail argv); } LogTail::~LogTail(){ terminate(); } QProcess: class for starting and controlling other process Derived from QObject using signals and slots QThread and QtConcurrent • QThread class provide platform-independent threads • Qt support multi-threading and encapsulates threads using QThread class • QObjects are thread safe and re-entrant, communicate across threads • Only have one GUI thread (QApplication) • Widgets inheritedfrom QWidget not thread safe • Executing in run() method • Start event loop calling exec Thread has: > Own stack pointer > instruction (program) counter > processor registers > execution state Access to: > shared resources (memory, wait conditionsm nutual exclusive data blocks, semaphores class MyThread: public QThread { public: void run (); //execute end when return from run() }; Void MyThread::run(){ QTcpSocket socket; socket.connectToHost(hostName, portNumber); exec(); } Networking Concepts WebKit: open source web content rendering and editing engine QT += webkit Main classes: > QWebElement = access and edit QWebFrame DOM elements > QWebFrame = data object represent frame in web page > QWebHistory = history of visited links associated with QWebPage > QWebHistoryItem = object represent one visited link in QWebHistory > QWebPage = data object represent web page > QWebSettings = data object holds settings used by QWebFrame or QWebPage > QWebView = widget visualizes QWebPage Only Widget in QWebKit is QWebView QWebPage download web content behind scenes, process content, reflect results user interface Viewing webpage: QWebView *view = new QWebView(); View -> load(QUrl( www.unisa.ac.za Networking Concepts QWebView = widget used to view and edit web documents QWebPage = object to view and edit web document QUrl = interface for workin with URL s QWebFrame = data object represent frame in web page QWebElement = class eccess and edit QWebFrame DOM elements Browsing web using HTTP protocol (hypertext transfer protocol) HTTP built on top of TCP (transmission control protocol) which is built in IP (internet protocol) QUrl class: ftp://ftp.qt.nokia.com:2021 Scheme Host port http://qt-project.org/documents#qt-other fragment http://qt-project.org/products/qt-for-mobile path ftp://person:Q3dfr4_$5@ftp.qt.nokia.com:2021 userName password TCP Sockets UDP Sockets Guaranteed in-order delivery File and forget Point-to-point only Point-to-pint or broadcast Correct delivery important Time more important than delivery QTcpSocket = represent a socket QTcpServer = represent a server, listen incomming onnections generating QToSocket instances for each connection QT += network Person - name: QString - birthDate: QDate + Person(QString, QDate) + setMemento(Memento) + createMemeonto(): Memento Memento - state: QStringList - Memento() - getState)_: QStringList - setState(QStringList) Caretaker - person: Person - memento: Memento Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 COS3711 Notes Unit 1 – Libraries After completing this chapter, you should be able to: • Know different containers of code and how they support code reuse • Install and use the libraries which accompany the prescribed book • Understand the concept of frameworks and APIs • Understand, identify, and implement the Serializer pattern • Describe the concept of an antiPattern Design patterns are efficient and elegant solutions to common problems in object-oriented software design. They are high-level abstract templates that can be applied to particular kinds of design problems. They are subdivided into three categories: 1. Creational patterns describe how to organize code that manages object creation. 2. Structural patterns describe how to organize objects and connect them. 3. Behavioural patterns describe how to organize code. serializer is an object that is responsible only for reading or writing objects. Qt has the QTextStream for reading and writing human-readable files, and the QDataStream for reading and writing structured, binary data. These classes are implementations of the Serializer pattern. can serialize and deserialize all QVariant supported types, including QList, QMap, QVector, and others. With QTextStream , if you want the extraction (>>) operator to work with the output of the insertion (<<) operator on your custom type, you must define proper field and record delimiters for the string types, and write and test the operators properly with sample data. Because these streams can be created from any QIODevice , and there are many other Qt classes that use QIODevice to communicate, your operators can send objects over a network, or through pipes, or to a database. NEED TO HAVE SOME CODE EXAMPLES HERE AntiPattern is a term that describe a commonly used programming practice that has proved to be ineffective, inefficient, or otherwise counterproductive. Software design antiPatterns: • Input kludge - Failing to specify and implement the handling of possibly invalid input. • Interface bloat - Making an interface so powerful and complicated that it is hard to reuse or implement. • Race hazard - Failing to see the consequence of different orders of events. Object-oriented design antiPatterns • Circular dependency - Introducing unnecessary direct or indirect mutual dependencies between objects or software modules. • God Object - An object that has too much information or too much responsibility. This can be the result of having too many functions in a single class. It can arise from many situations, but it often happens when code for a model and view are combined in the same class. Programming antiPatterns • Hard coding - Embedding assumptions about the environment of a system in its implementation. • Magic numbers - Including unexplained numbers in algorithms. • Magic strings - Including literal strings in code, for comparisons, as event types, etc. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Methodological antiPatterns • Copy and paste programming - Copying and modifying existing code without creating more generic solutions. • Reinventing the (square) wheel - Failing to adopt an existing, adequate solution and, instead, adopting a custom solution (which performs much worse than the existing one). Unit 2 – Meta Objects, Properties and Reflective Programming After completing this chapter, you should be able to: • Understand the MetaObject pattern • Understand Qt’s implementation of MetaObject • Implement reflective programming • Understand Qt’s support for run-time type identification • Understand the use of QMetaType QMetaObject is Qt’s implementation of the MetaObject pattern. It provides information about the properties and methods of a QObject . The MetaObject pattern is sometimes known as the Reflection pattern. A class that has a MetaObject supports reflection. You can use these methods of QMetaObject to get information about a QObject : • className(), which returns the class name as a const char* • superClass(), which returns a pointer to the QMetaObject of the base class if there is one (or 0 if there is not) • methodCount(), which returns the number of member functions of the class The signal and slot mechanism also relies on the QMetaObject . By using the QMetaObject and QMetaProperty , you can write code that is generic enough to handle all self-describing classes. The Q_PROPERTY Macro facility gives you a choice of ways to access data members: • Directly, through the classic getters/setters (faster, more efficient) • Indirectly, through the QObject / QMetaObject interface (enables more reusable code) You can specify read-only access to some properties, by leaving out a WRITE function. In addition, you can provide a NOTIFY signal to emit when the property is changed. To retrieve the value of any property, you call this method: QVariant is a union wrapper for all the basic types and all permitted Q_PROPERTY types. You can create a QVariant as a wrapper around another typed value. A QVariant remembers its type and has member functions for getting and setting its value. has a rich interface for data conversion and validity checking. In particular, there is a toString() function that returns a QString representation Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 QMetaObject Example: Customer.h Customer.cpp Main.cpp Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Dynamic properties are acquired at runtime and are specific to the object that acquired them. In other words, two objects of the same class have the same meta property list, but they can have different lists of dynamic properties. For example: The example below shows a way to display fixed and dynamic properties. The list of the fixed properties comes from the QMetaObject . You can access property values using QMetaProperty::read() or QObject::property(). The propertyCount() function sets a limit for iteration through the QMetaProperty list. The dynamic properties are not known by the QMetaObject . Instead, you must use QObject methods. You can iterate through the QList returned by QObject::dynamicPropertyNames() for the list of names and use QObject::property() to obtain values. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Unit 3 – Models and Views After completing this chapter, you should be able to: • Understand and identify the Model-View-Controller pattern • Design and implement applications with separated models and views • Have an overview of Qt’s in-built models and views • Use Qt’s in-built model and view classes • Understand the role of delegates in Qt’s model/view framework • Understand the value of smart pointers Model-View-Controller (MVC) consists of three kinds of objects: 1. The model is the application object 2. the view is its screen presentation 3. the controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse. Controller code manages the interactions among events, models, and views. Factory methods, delegates, and creation and destruction code in general fall into the realm of the controller. In the Qt framework, much of the controller mechanism can be found in delegates. Delegates control the rendering and editing of individual items in views. Views supply default delegates that are sufficient for most purposes, although you can refine the ways that the default delegates render items by deriving a custom model from QAbstractItemModel . There are two approaches to implementing the data model. Each has advantages. 1. Implement the passive interface of a QAbstractItemModel, including the data representation. It offers more flexibility in implementation. It is possible to use data structures that are optimized for specific access patterns or data distributions. 2. Reuse a general-purpose concrete data model, such as QStandardItemModel, and fill in the data. Reusing the QStandardItem (Model) classes, makes it possible to write tree/item code in a style similar to that used by QListWidget, QTableWidget, and QTreeWidget. QFileSystemModel / QTreeView QListView Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 QTableView QColumnView A delegate class, usually derived from QAbstractItemDelegate , adds several kinds of controller features to the Qt model-view framework. A delegate class can provide a factory method that enables view classes to create Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 editors and virtual getters and setters for moving editor data to and from the model. It can also provide a virtual paint() method for custom display of items in the view. Delegates can be set up for an entire QAbstractItemView or for just one of its columns. A class is called a smart pointer if it overrides operator*() and operator->() , the pointer dereference operators. This enables instances to act as if they were built-in pointers. Such classes are almost always template classes, so in definitions, we must supply the referenced type in template arguments. The most common places to find these operators overloaded are in iterators and smart pointers. What makes them smart is usually due to customized behaviour during construction, destruction, or assignment. Unit 4 – Validation and Regular Expressions After completing this chapter, you should be able to: • Use input masks to control user input • Know the purpose of validators and Qt’s support for validators • Know how to set validators for input widgets in Qt • Know the purpose of regular expressions and an overview of the regular expression syntax • Understand the relationship between validators and regular expressions • Be able to write simple regular expressions for validation of input in Qt An input mask is an active pattern that controls what can be typed into an input widget by the user. It can help to prevent certain types of incorrect data from being entered. The set of predefined mask characters consists of the following: Lowercase versions of the mask letters listed in above specify that the corresponding input characters are permitted in that position but not required: • Using zero (0) instead of nine (9) indicates that an ASCII digit is permitted in that position but not required. • # indicates that an ASCII digit or a plus (+) or a minus (–) is permitted in that position but not required. In addition, there are a few meta characters, shown below: Input masks are used on QLineEdits as follows: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Validators are objects that can be attached to input widgets (such as QLineEdit, QSpinBox, and QComboBox) to provide a general framework for checking user input. Qt has an abstract class named QValidator that establishes the interface for all built-in and custom validators. Two of QValidator ’s concrete subclasses can be used for numeric range checking: • QIntValidator • QDoubleValidator There is also a concrete subclass that can be used for validating a string with a specified regular expression. QValidator::validate() is a pure virtual method that returns one of the following enumerated values: • Invalid —The expression does not satisfy the required conditions, and further input will not help. • Intermediate —The expression does not satisfy the required conditions, but further input might produce an acceptable result. • Acceptable —The expression satisfies the required conditions. Other member functions enable the setting of the values that validate() uses (e.g., range limits). Generally, a working validator will not permit the user to enter data that causes it to return the value Invalid. QIntValidator and QDoubleValidator are used as follows: Regular expressions are powerful tools for validating input, for extracting data from input, and for searching and replacing. A regular expression, regexp (or regex for short), describes constraints on the way a string is composed, using a formal language for pattern matching. A regular expression is a series of characters; however, not all characters are taken literally. For example, while an 'a' in a regular expression will match an 'a' in the target string, the character '.' will match any character. Here '.' is called a meta-character . Another common meta-character is '*', which is used to indicate that zero or more of the preceding character may exist in the target string. For example, 'a*' would match any number of 'a's (including zero) in a row. Following are some of the most commonly used meta-characters. 1. Special characters • . (the dot matches any character) • \\n (matches the newline character) • \\f (matches the form feed character) • \\t (matches the tab character) • \\x hhhh (matches the Unicode character whose code is the hexadecimal number hhhh in the range 0x0000 to 0xFFFF ) 2. Quantifiers —Modifiers that specify the number of occurrences of the preceding character (or group) that may appear in the matching expression. • + (1 or more occurrences) • ? (0 or 1 occurrences) • * (0 or more occurrences) • { i , j } (at least i but not more than j occurrences) Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 3. Character Sets —Sets of allowable values for the character in the specified position of the matching expression. Several character sets are predefined: • \\s (matches any whitespace character) • \\S (matches any non-whitespace character) • \\d (matches any digit character: 0 to 9 ) • \\D (matches any non-digit character) • \\w (matches any “word” character; i.e., any letter or digit or the underscore _ ) • \\W (matches any non-word character) Character sets can also be specified in square brackets: • [AEIOU] (matches any of the characters A , E , I , O , or U ) • [a-g] (the dash makes this a range from a to g ) • [^xyz] (matches any character except for x , y , and z ) 4. Grouping and Capturing Characters - (round parentheses) can be used to form a group. Groups can be back-referenced, meaning that if there is a match, the grouped values can be captured and accessed in various ways. • Up to nine groups can be referenced within the regular expression by using the identifiers \\1 thru \\9 . • There is also a QRegExp member function cap(int nth) , which returns the nth group (as a QString). 5. Anchoring Characters —Assertions that specify the boundaries of a matching effort. • The caret (^), if it is the first character in the regex, indicates that the match starts at the beginning of the string. • The dollar sign ($), when it is the last character in the regex, means that the effort to match must continue to the end of the string. • In addition, there are word boundary (\\b) or non-word boundary (\\B) assertions that help to focus the attention of the regex. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 The class QRegExpValidator uses a QRegExp to validate an input string. The example below shows the use of QRegExpValidator: When the requirements for validating user input go beyond simple numeric range checking or validation with a regular expression, you can define your own validator class by deriving from QValidator. For the next example, we define a palindrome as a string that reads the same backward or forward, ignoring case, whitespace, and punctuation. Usage of the above class: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Unit 5 – Parsing XML After completing this chapter, you should be able to: • Understand Qt’s support for parsing XML • Have an understanding of SAX and DOM parsing in Qt • Implement parsing using the SAX-parser • Generate XML files using DOM • Implement parsing using DOM Working with XML Note that XML files can be set up in 2 different ways: • one format uses tags (like book) with attributes (like title and pages): • or, using tags (book, title, and pages) with text (like Computer Algorithms and 688) An element is anything from the start tag to the end tag of an element. So, library is an element, as is pages. Strictly speaking, attributes are supposed to supply extra information that is not part of the data (or text). However, there are no rules about when to use attributes and when to use elements. Some argue that using attributes is more limiting, and that using elements is more extensible. Note also that the indenting of the above text is simply to make it more readable. SAX Parsing The example given here simply parses the xml file and displays it. Suppose you had a Person class that had a name and an age. An xml file for this could look as follows: You thus know the structure of the xml file. If you now wanted to parse this file and then create instances of your Person class, you could do something along the lines of the following: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 However, if the xml file is not based on attributes but on text, we could have the following: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Parsing this is different, and would involve something along the lines of the following. The variables used in the example (inName and inAge) would need to be members of the XMLHandler class: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Using QDomDocument to parse the xml as shown above: To write XML with DOM when “attributes” are being used: To write XML with DOM when <tags> are being used: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Unit 6 – More Design Patterns After completing this chapter, you should be able to: • Understand, identify and implement the Factory Method pattern • Understand, identify and implement the Abstract Factory pattern • Understand, identify and implement the Singleton pattern • Understand, identify and implement the Memento pattern • Understand, identify and implement the Façade pattern • Understand, identify and implement the Strategy pattern • Understand, identify and implement the Adapter/Wrapper Pattern In C++, a factory is a program component, generally a class, that is responsible for creating objects. The idea of a factory is to separate object creation from object usage. A factory class generally has a function that obtains dynamic memory for the new object and returns a (base class) pointer to that object. This approach enables new derived types to be introduced without necessitating changes to the code that uses the factory. In laymen’s terms: This design pattern is applicable when a class needs to create objects but doesn’t know which objects to create, and the responsibility for creating objects can be transferred to the subclasses. So, this design pattern defines a class with a function for creating an object, but the subclasses implement this function to create appropriate objects. The UML structure of this design pattern is given below: The main classes included in the UML diagram are: • Product: defines the interface of the objects to be created by the Factory. • ConcreteProduct: implements the Product interface, which is created by the ConcreteFactory. • Factory: declares the factoryMethod(), which returns an object of type Product. • ConcreteFactory: overrides the factoryMethod() to return an instance of type ConcreteProduct. There are a number of variations of this design pattern. Firstly, the FactoryMethod() in Factory may provide a default implementation of the factory method, and it may call the FactoryMethod in one of its functions (operation()). This means the Factory is not always necessarily abstract. Secondly, the factory method could take parameters and based on them, several different objects can be created. This means a ConcreteFactory may create more than one type of object. Abstract Factory pattern provides an interface for defining factories that share abstract features but differ in concrete details. Client code can instantiate a particular subfactory and then use the abstract interface to create objects. In laymen’s terms: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 This design pattern is applicable when you need to create families of related or dependent objects. This design pattern mainly has two hierarchies: 1. Hierarchies of product classes, whose objects are meant to be used together. 2. Then you have a hierarchy of factory classes to facilitate creation of the product classes. The UML structure of the design pattern is given below: The main classes included in the UML diagram are: • AbstractProductA and AbstractProductB: abstract classes of two related product classes. • ProductA1 and ProductA2: concrete product A classes. • ProductB1 and ProductB2: concrete product B classes. • AbstractFactory: abstract factory class that declares functions for creating product A and B objects. • ConcreteFactory1 and ConcreteFactory2: concrete factories, which implement functions declared in the AbstractFactory to create concrete product A and B classes. • Client: it only uses the functions declared in AbstractProductA, AbstractProductB and AbstractFactory. Using this design pattern, the client does not know about the implementation details of the concrete product families and it can interchangeably use any of the concrete factories to create the appropriate concrete products. Singleton pattern restricts a class so that only one instance can be created. Th is can be accomplished by making its constructor private or protected and providing an instance() member that returns a pointer to a new instance if one does not already exist but returns a pointer to that instance if it does. A Singleton is implemented as follows: As demonstrated in the code, the single instance of ActorList is stored in the static variable actorList. When a request for an ActorList instance is made via getInstance(), an instance of ActorList is created and stored in actorList. All subsequent calls to getActorList() do not create new instances but rather return the only instance of ActorList stored in actorList. Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 According to the Gang of Four, a memento is an object that stores a snapshot of the internal state of another object, and this state can only be “read” by the original object. This allows an object’s state to be restored at some later point, allowing for an “undo” or a rollback operation. The Memento pattern is a behavioural pattern. This design pattern is applicable when the state of an object needs to be saved so that its state can be restored later without violating the encapsulation of the class. The data members of the class, which determine the state of its objects, may not all be accessible (via setters and getters) outside the class. Hence the class itself has to be involved in saving and restoring the state of its objects. The UML structure of the design pattern is given below: The main classes involved in the UML diagram are: • Originator: state of the objects of this class are being saved and restored. To save the state of an object, it creates a snapshot of its state by creating a Memento, via the createMemento() function. To restore the state of the object, it uses a Memento via the setMemento() function. • Memento: stores the state of an Originator. • Caretaker: it keeps the Memento. The role of the Caretaker is only to store the Memento, and it is not allowed to access the state of the Originator saved in the Memento. One way of achieving this is by making the getState(), setState(),and even the constructor of Memento, private, so that the Caretaker cannot access the state of the Originator. However Orginator needs to be able to access the constructor, getState(), and setState() of Memento. One way of achieving this is by making Originator a friend of Memento. Caretaker requests a snapshot of an Originator using the createMemento() function. The Originator in turn creates a snapshot of its state by passing its state to Memento, and thus creating a Memento, which is then passed to the Caretaker. If the state of the Originator has to be restored, then Caretaker can invoke the setMemento() function to restore the state of the Originator. Memento implementation: Creating a memento: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Restoring a memento: The Façade pattern is a structural pattern. The Façade pattern is applicable when you would like to provide a simplified interface to a complicated set of systems but yet allowing the client to access the functionality of the underlying system. This design pattern defines a Façade that interacts and invokes the subsystems to satisfy the request of the client. A simplified diagram of this design pattern is given below: Strategy pattern is applicable when there is a family of algorithms that needs to be made interchangeable based on the context. Using this design pattern, each algorithm is encapsulated in a class, and the run time selection of a relevant algorithm is made possible. The UML diagram of this design pattern is given below: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 The classes involved in this UML diagram are: • Strategy: It is the class which defines a common interface (here the function Algorithm()) for the classes that represents the family of algorithms. It is generally an abstract class, and is sometimes referred to as an abstract strategy. • StrategyOne, StrategyTwo and StrategyThree: These are the concrete strategies, which each define the Algorithm() function. These classes are sometimes referred to as concrete strategies. • Context: Context has a reference to a Strategy, and it can decide on the concrete strategy to choose, based on the requirement. Adapter / Wrapper design pattern is applicable when the functionality of a class can be reused but the interface of the class is not compatible with the existing classes. So, this design pattern converts the interface of an existing class into another, as expected by the client. This design pattern is sometimes called a Wrapper pattern, since it can be seen as wrapping around an existing class to present a different interface to other classes. There are two forms (Class Adapter and Object Adapter) of the Adapter pattern, and the UML diagrams of both forms of the Adapter pattern are given below: The main classes included in the UML diagram are: • Client: uses objects conforming to the Target interface • Target: defines the domain-specific interface used by the Client • Adaptee: defines the interface of an existing class to be reused • Adapter: adapts the interface of Adaptee to the Target interface Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 In a Class Adapter, Adapter adapts the interface of Adaptee by inheriting from Adaptee. In the Request() function of the Adapter, it simply invokes the SpecificRequest() function in Adaptee. Here the client call operates on an Adapter instance, which in turn calls Adaptee operations (SpecificRequest(), for instance), which carry out the operation. In an Object Adapter, Adapter adapts the interface of Adaptee by creating an instance of Adaptee (adaptee). In the Request() function of the Adapter, it simply invokes the SpecificRequest() function on the instance of Adaptee. Here the client call operates on an Adapter instance, which in turn calls operations on the Adaptee instance to carry out the operation. Unit 7 - Concurrency After completing this chapter, you should be able to: • Know the different classes in Qt for implementing concurrency • Understand and implement multiprocessing using the QProcess class • Understand and implement multithreading using the QThread class • Understand thread safety and the classes available in Qt for thread safety QThread itself is an object, not a thread; it is just a wrapper around a thread that allows you to control the thread. So, the thread affinity of the QThread object is not necessarily the same as the actual thread (that is, the QThread object may be running in a different thread from the thread that is being created: the QThread object’s affinity will be the same as the thread that constructed the object, which would be the main thread). See the following example of the alternative approach, based on a PrimeFinder class that is used to find prime numbers, where PrimeFinder is implemented as a thread: As PrimeFinder is a QObject, its thread affinity is the same as that which created it – in this case the main thread. If you want it to run in a different thread, then you use the moveToThread() function. The moveToThread() function tells Qt that the event handlers, and the signals and slots, are dealt with from the indicated thread context. The started() signal of the thread is connected to the function in PrimeFinder that does the work; this function in PrimeFinder should emit a finished() signal once it is done. Then, the finished() signal of the PrimeFinder object is linked to the quit() slot of the thread. It is possible to have multiple instances of the PrimeFinder class assigned to a single thread, or multiple instances of several different classes assigned to a single thread. There is no need to tie a single instance of a class to a single thread. Starting a process from QT: Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588 Unit 8 – Networking and the Web NETWORKING CONCEPTS • Protocols Browsing the web uses the HTTP protocol (hypertext transfer protocol), and it may be encrypted as https. HTTP is built on top of TCP (transmission control protocol), which in turn is built on top of IP (internet protocol). Other protocols, such as FTP, SMTP, POP, and IMAP are also built on top of TCP/IP. • QUrl The QUrl class can be used to split a URL into its parts. See the image below (adapted from the Qt Assitant) to see the various parts of the URL: • Accessing sockets Qt supports accessing TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) directly at socket level. See the Table below for a comparison of TCP and UDP sockets: There are two TCP classes in Qt: 1. QTcpSocket – representing a socket 1. QTcpServer – representing a server, listening for incoming connections, generating QTcpSocket instances for each connection However, TCP/IP traffic is easy to overhear. Qt thus provides QSslSocket to use encrypted TCP sockets (using connectToHostEncrypted). SSL (secure sockets layer) is a layer on top of TCP which relies on certificate authorities. The QUdpSocket provides a UDP (user datagram protocol) socket that is usable for both clients and servers. Datagrams are sent as one block, and the following should be borne in mind. o 512 bytes is okay, 8192 bytes usually work, larger might be possible o Can arrive or not o Can arrive out of order o Can arrive in duplicates Downloaded by Tristan Walker (t-promotional@pm.me) lOMoARcPSD|4157588","libVersion":"0.2.3","langs":""}