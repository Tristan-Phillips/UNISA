{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/202_2020_1_b.pdf","text":"BAR CODE Deﬁne Tomorrow. university of south africa Tutorial Letter 202/1/2020 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 Computer Science School of Computing CONTENTS Model solutions for Assignment 02 COS3751/202/1/2020 ASSIGNMENT 2 Solution Unique Assignment Number: 879267 Study material: Chapters 5, 6, 7, and 8. You may skip sections 5.5, 5.6, and 5.7, 7.6, and 8.4. Question 1 (1.1) Clearly explain what an evaluation function is, and why it is used during adversarial searches. An evaluation function provides the apparent value of a state s. It is thus an estimate of the ultimate utility of the most likely terminal state reached from s. (1.2) Is the ideal strategy only available if we have perfect information? Explain your answer. No. Agents can still get the ideal strategy when playing without all the informa- tion. This means the ideal strategy includes the notion of limited information, however, an agent that has perfect information will most likely outperform and agent that has limited/imperfect information for the same problem. (1.3) Explain how forward pruning works. Provide at least one approach to forward pruning in your explanation, as well as a problem that may be encountered with forward pruning. Forward pruning means that some nodes are pruned without even considering them. Beam search [others are also considered] only considers a sample of the best moves at each ply, but this may lead to the best move being pruned away. (1.4) Does the order in which nodes are examined in minimax matter? Explain your answer. Only if we prune. Otherwise minimax is an exhaustive search (for the parameters such as depth – plys – it is conﬁgured for) and node orders do not matter. Question 2 Consider Figure 1 and answer the questions that follow. (The utility value of the leaf nodes are provided below the in brackets in the leaf node.) (2.1) Provide the minimax values for all the nodes. A = 7, B = 7, C = 6, E = 9, G = 6 (2.2) Which move should MAX make? Explain your answer. B. The utility value for MAX for move B is higher than that of move C. (2.3) Write down the α/β values for all the nodes (except the leaf nodes) if alpha/beta pruning is applied to the tree. 2 COS3751/202/1/2020 A B D 7 E I 9 J -2 F 9 C G K -3 L 6 H 17 M 9 Figure 1: Minimax, alpha/beta Provided below is < node >= (α, β): 3 A B D 7 E I 9 J -2 F 9 C G K -3 L 6 H 17 M 9 v ≥ β: J cut v ≤ α: H,M cut v = \b\b−∞ 7 α = \b\b−∞ 7 β = ∞ v =ˆ∞ 7 α = −∞ β =ˆ∞ 7 v =ˆ∞ 6 α = 7 β = ∞ v = \b\b−∞ 9 α = −∞ β = 7 v = \b\b−∞ ˆˆ−3 6 α = \b\b−∞ ˆˆ−3 6 β = ∞ (1) (2) (3) 7 (4) (5) (6) 9 (7) 9 (8) (9) 9 (10) 7 (11) (12) (13) (14) -5 (15) (16) 6 (17) 6 (18) 6 The ﬁnal values are: A = (7, ∞), B = (−∞, 7), E = (−∞, 7), C = (7, ∞), G = (6, ∞) (2.4) Write down which nodes were cut and what type of cut was made in each case (alpha, or beta). J was beta-cut, H and M were alpha-cut. Question 3 Answer the following questions on Constraint Satisfaction Problems (CSPs). (3.1) Deﬁne the Least Constraining Value (LCV) heuristic. The heuristic prefers values that rule out the fewest choices for neighbours (it tries not to limit the number of choices that remain for neighbours). (3.2) Explain why establishing strong k-consistency is a problem. This means we must show that the graph is k-consistent, k − 1-consistent and so on. This can only be done in exponential time which makes large problems intractable. 4 COS3751/202/1/2020 (3.3) Deﬁne the degree heuristic. This heuristic attempts to reduce the branching factor on future choices. (3.4) If no legal assignments for a variable remain during a solution to a CSP, does it mean that the algorithm will be able to ﬁnd a solution by simply backtracking? Explain your answer. No. It may very well be that there is no answer (there is no form of consistency for the problem given the constraints, resulting in no solution). (3.5) Explain what forward checking for a CSP is. It is a domain reduction technique which establishes arc consistency[2]. (Or: it removes values from the domain of the neighbours of the variable for which the forward checking is being done[0][0] – also acceptable answer.) Question 4 Consider the crossword puzzle provided in Figure 2. 1 2 3 4 5 6 7 Figure 2: Crossword Puzzle It is possible to represent the problem of generating puzzles as a CSP. Suppose you are given the puzzle grid as above, as well as a dictionary W of words to use for generating the puzzle. The variables for this problem is easily represented as the collection of vertical or horizontal cells. Such a collection is called a box. A horizontal box is identiﬁed as Ai with i being the number of the box, and a vertical box is Dj with j being the number of the box. Boxes consisting of only one cell is not allowed. Suppose you are given the following functions: 1. BLen(v): returns the number of cells that a box contains, for example BLen(A1) = 4 2. W Len(w): returns the length of a word w, for example W Len( ′hi ′) = 2 3. Cell(v, n): returns the letter in cell n of variable v. For example, if A1 = ‘Ahoy’, then Cell(A1, 2) = ‘h’. Answer the following questions. 5 (4.1) Provide the variables for this problem. Make sure to use the correct notation. X = {A1, A3, A6, A7, D1, D2, D4, D5} (4.2) Deﬁne the domain for the variables, make sure to use the correct notation, and to use all the information provided. (Hint: Remember that the number of cells in a box and the number of letters in a word must match.) Dx∈X = {w|w ∈ W ∧ W Len(w) = BLen(x)} (must include a reference to the dictionary). (4.3) Deﬁne the constraints for this problem. 1. Cell(A1, 1) = Cell(D1, 1) 2. Cell(A1, 3) = Cell(D2, 1) 3. Cell(A3, 2) = Cell(D4, 1) 4. Cell(A3, 3) = Cell(D2, 3) 5. Cell(A3, 4) = Cell(D5, 1) 6. Cell(A6, 2) = Cell(D4, 3) 7. Cell(A6, 4) = Cell(D5, 3) 8. Cell(A7, 2) = Cell(D4, 5) 9. Cell(A7, 4) = Cell(D5, 5) 10. Alldiﬀ(A1, A3, A6, A7, D1, D2, D4, D5) (4.4) You are given the following list of words as your dictionary. W = { GAB, WIN, VAN, VET, GET, GIVE, GRAB, GROW, DRUM, BEND, BARE, DRAB, DRAG, EYES, FEEL, FOOL, EELS, ERRS, TARDY, BARES, EARLY, DUMPS, FEELS, DRUMS }. Use the Minimum Remaining Values (MRV) heuristic to generate the crossword, apply arc-consistency when you’ve made an assignment to a variable. The Solution is: G I V E A A B E N D A U D R U M L P E Y E S This answer is marked based on your attempt. However, note the following: 6 COS3751/202/1/2020 1. Domain reduction must be applied after each assignment. 2. Only variables with the smallest domain must be considered for assignment. This means that once assignment has taken place, and domain reduction has been ap- plied, then only variables with the smallest domains can be considered. 3. Domain reduction is based on the constraints. Thus each time assignment takes place, the domain of the remaining variables are reduced based on the words in the dictionary that meet the constraints. 4. Providing only the solution will earn you only 1 mark. Question 5 Consider the following English sentences: 1. Anyone who passes their history exam, and wins the lottery is happy. 2. Anyone who studies, or who is lucky will pass their exam. 3. John did not study. 4. John is lucky. 5. Anybody who is lucky will win the lottery. a (5.1) Provide a First-order Logic (FOL) vocabulary for the sentences. 1. Lucky(p). A predicate (property). Person p is lucky. 2. P ass(p, s). A predicate. Person p, passes subject s. 3. W in(p, e). A predicate. Person p wins event e. 4. Study(p). A predicate. Person p studies. 5. Happy(p). A predicate. Person p is happy. 6. John. A constant depicting people. 7. History. A constant depicting subjects. 8. Lottery. A constant depicting events. 7 (5.2) Using your vocabulary, translate the sentences in FOL. 1. (∀x)[(P ass(x, History) ∧ W in(x, Lottery)) ⇒ Happy(x)] 2. (∀y)(∀z)[(Study(y) ∨ Lucky(y)) ⇒ P ass(y, z)] 3. ¬Study(john) 4. Lucky(john) 5. (∀w)[Lucky(w) ⇒ W in(w, Lottery)] It is important to standardise the variables (to use diﬀerent variable names) to avoid confusion when dropping the universal quantiﬁers. (5.3) Convert the statements obtained in (5.2) into clausal form. Variables must be standard- ised. The statements are converted as follows to clause form: 1. ¬pass(x, history) ∨ ¬win(x, lottery) ∨ happy(x) 2. ¬study(y) ∨ pass(y, z) 3. ¬lucky(y) ∨ pass(y, z) 4. ¬study(john) 5. lucky(john) 6. ¬lucky(w) ∨ win(w, lottery) Note that universal quantiﬁers have been dropped because all variables were universally quantiﬁed. (5.4) Use resolution refutation to prove that John is happy. 7 ¬happy(john) negation of goal 8 ¬win(x, lottery) ∨ happy(x) ∨ ¬lucky(x), 1&3, {x/y}, {history/z} 9 ¬win(john, lottery) ∨ happy(john), 5&8, {john/x} 10 ¬win(john, lottery), 9&7 11 win(john, lottery), 5&6, {john/w} 12 ∅, 10&11 8 COS3751/202/1/2020 Question 6 Do excercise 8.9 b, d, f, g in the textbook. The translation is straight forward using the vocabulary provided. b. Occupation(Joe, Actor) ∧ ∃p(p ̸= Actor ∧ Occupation(Joe, p)) d. ¬∃p(Occupation(p, Lawyer) ∧ Customer(Joe, p)) f. ∃p(Occupation(p, Lawyer) ∧ ∀q(Customer(q, p) ⇒ Occupation(q, Doctor))) g. ∀p(Occupation(p, Surgeon) ⇒ ∃q(Occupation(q, Lawyer) ∧ Customer(q, p))) Copyright c⃝UNISA 2020 (v2020.1.0) 9","libVersion":"0.2.3","langs":""}