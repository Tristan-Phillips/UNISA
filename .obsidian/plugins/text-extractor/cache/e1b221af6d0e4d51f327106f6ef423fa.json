{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/201_2018_1_b_v2.pdf","text":"BAR CODE Deﬁne Tomorrow. university of south africa Tutorial Letter 201/1/2018 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 School of Computing IMPORTANT INFORMATION This tutorial letter contains the updated model solutions for assignment 01 COS3751/201/1/2018 ASSIGNMENT 01 Solution Total Marks: 100 UNIQUE ASSIGNMENT NUMBER: 698500 Study material: Chapters 1 through 4. You may skip sections 4.2 and 4.5. Important: When we use the phrase ‘formally deﬁne’, we are looking for a formal deﬁnition us- ing some form of formal notation, and not simply an English description or deﬁnition. For exam- ple: ‘Deﬁne the initial state for an agent in Johannesburg.’ Answer: In(Johannesburg). ‘Deﬁne the actions available to this agent given that the agent simply moves between major metropoli- tan areas.’ Answer: Actions(In(Johannesburg)) = {Go(Bloemontein), Go(Durban),. . . }. When we want an English deﬁnition, we will explicitly ask for it. Changes from the ﬁrst version of this tutorial letter are highlighted in yellow. Question 1: 10 Marks (1.1) Consider an agent that is designed to deliver medication to a rural area. The area has very little road access, and the nature of the settlement is such that there are no up-to-date maps of the lay-out of the settlement. The agent is a drone that is designed to ﬂy at low altitudes in order to deliver the medication to people who may not have access to medical services. The agent is capable of determining its location using a GPS, can determine its altitude, and speed, and can control these aspects (speed and altitude). It can thus ﬂy to a particular location and deliver medicine. Using a barcode reader it can determine that the correct medicine has been delivered to the correct person. Its fuel supply is sufﬁcient for deliveries and is thus not of consequence. Agents can also detect the presence of other agents. The company that provides the service may have many agents that deliver medicines. Choose from among the following environmental descriptions, and justify your choices in each case. (a) Is the environment fully, or partially observable? It is important to consider the environment in terms of what the agent needs in order to complete its task. Since the agent can observe its altitude, and speed, and location. It can also determine that it delivered medicine to the correct person. Given all the above, this may be considered enough to make the environment fully observable. (b) Is the environment competitive, or cooperative? (You only need to consider medicine delivery agents.) No indication is provided that agents help each other, or compete with each other. In fact, the only evidence that agents know about each other is that they can detect each other. We could thus classify this as a partially cooperative environment. 2 COS3751/201 (Agents don’t crash into each other, but don’t take actions to help other agents maximise their performance directly.) (c) Is the environment static, or dynamic? We need not consider anything other than the agent operating in an environment where humans (or other agents) are busy moving around. The agent thus has to consider these movements during deliberation. The environment is therefore dynamic. (1.2) Is this an example of a model-based, or reﬂex-based agent? Justify your answer. Model-based. The agent has to keep track of the environment in order to plan its delivery. Question 2: 10 Marks One night three friends come to a rickety bridge spanning a torrential river. They want to cross it, but do not trust the bridge to carry all of them at the same time. They decide to cross the bridge two at a time. To make matters worse, the bridge is in such disrepair that some of the wooden planks that make up the bridge have fallen away leaving gaping holes – making the crossing very dangerous. Luckily the three friends (Andile, Bob, and Charlize) have a single torch with them. They decide that the people crossing the bridge will take the torch with them. Suppose the state is represented as a set S : {p | p ∈ P} with P = {Andile, Bob, Charlize, Torch}. If pi ∈ S, then pi is on the right-hand side of the bridge, otherwise they (it) are on the left-hand side. Torch represents the torch and, as with the people, if it is present in S, then it means the torch is on the right-hand side of the bridge, otherwise it is on the left-hand side. As people (and the torch) move from one side of the bridge to the other, they are added/removed to the set representing the current state. For example, suppose we start with S = {Andile, Bob, Charlize, Torch} and Andile walks across the bridge with the torch, we have S′ = {Bob, Charlize}. (2.1) Deﬁne the goal state for this problem. Since we are implicitly tracking people on the other side of the bridge,: Sg = {} (2.2) Suppose the current state is Sc = {Bob}. Deﬁne the applicable actions for this state. (Hint: you will ﬁrst need to deﬁne the possible actions that are available in general, then deﬁne the applicable actions for this state.) We deﬁne an action as Cross(Q) where Q ⊆ P − {Torch} such that 1 ≤ |Q| ≤ 2. In other words, Q is a set of 1 or 2 persons from P. The direction of crossing is determined by the location of the torch. So the notation doesn’t include Torch. We must just make sure the transition function moves the Torch accordingly. Sc indicates that Andile, Charlize, and the Torch are on the other side of the bridge. So the applicable actions are: 1. Cross({Andile}) 2. Cross({Charlize}) 3. Cross({Andile, Charlize}) 3 (2.3) Provide the transition model for the search, but limit your answer to the case where S1 = {Andile, Bob, Torch}. You will again have to provide the applicable actions before providing the transition model. Make sure you show the resulting states when applying the actions. The applicable actions for this state are: 1. a0 = Cross({Andile}) 2. a1 = Cross({Bob}) 3. a2 = Cross({Andile, Bob}) Our transition model is then all the resulting states when applying these actions. 1. Result(a0, S1) 7→ S2 = {Bob} 2. Result(a1, S1) 7→ S′ 2 = {Andile} 3. Result(a2, S1) 7→ S′′ 2 = {} Question 3: 10 Marks (3.1) Explain how a Breadth First Search (BFS) ensures that it always expands the shallow- est node ﬁrst. Provide an example to aid your discussion. BFS uses a FIFO queue for its frontier. This means whenever a node is expanded, the generated nodes are placed on the frontier as they are generated. This means a node’s immediate children are placed on the queue, and will be expanded before any nodes further away from the node are expanded. Your example was evaluated based on the correctness of your FIFO discussion. (3.2) Explain when one might want to choose Depth First Search (DFS) over BFS. (Hint: In which version of the algorithm does one have an advantage over the other?) DFS has a clear space complexity advantage over BFS when a tree search is per- formed. Question 4: 20 Marks Consider the search tree in Figure 1. Show the order in which the nodes will be expanded at each level (start with level 0 and continue until the goal test is successful), given that Iterative Deepening Search (IDS) is used. Assume the goal node is G, and that nodes are expanded from left to right (M is expanded before E and so on). (Hint: Make sure you understand the difference between expansion and generation, and also that you understand when goal checks occur.) Expansion means we apply legal actions to a chosen node – this, by deﬁnition, means that our order looks somewhat different from what one might expect. Also, note that the IDS is a repeated 4 COS3751/201 O M D K I C J H E L F G B N A Figure 1: Search Tree (IDS) invocation of depth limited search. In depth limited search, once we generate a node, we recur- sively call depth limited search on that node. Thus, goal state checking happens immediately after generation for each node. In general, the children of nodes that are expanded are thus goal checked. 1. Limit 0: (No expansion – O is just goal tested) 2. Limit 1: O (M and E are just goal tested, not expanded) 3. Limit 2: O M E 4. Limit 3: O M D C E L 5. Limit 4: None, search terminates once L is expanded – once L is expanded, G will be gener- ated and goal tested on the recursive call. Visually, this is what happens (squares are goal tests and circles are expansions): Limit 0: O Limit 1: O M E 5 Limit 2: O M D C E L B Limit 3: O M D K I C J H E L F G {0} Question 5: 20 Marks Consider the graph provided in Figure 2, and answer the questions that follow. The step cost between nodes is provided next to the edges. (5.1) Prove that a consistent heuristic is admissible. (Hint: if you can prove that admissibility holds for nodes 1 step away from the goal, then you can prove that nodes k-steps away from the goal is admissible.) 6 COS3751/201 K B J A O F M G I D E H L N C 8 2 7 5 2 4 8 4 6 2 2 10 7 8 6 5 2 Figure 2: Search We ﬁrst repeat the two applicable definitions: A heuristic is consistent if its estimate of the cost to the goal is always less- than-or-equal to the sum of the actual cost to any successor node plus its estimate from that node to the goal. As an equation: h(n) ≤ c(n, n′) + h(n′) where n is a node and n′ is a neighbour of n. Also, h(m) = 0 if m is the goal. A heuristic is admissible if the estimated cost to the goal is always less- than-or-equal to the actual cost to the goal. As an equation: h(n) ≤ c(n, m) As suggested in the hint, we give a proof by induction: Say h is consistent. 1. Base case: Assume that the goal is a neighbour of n, i.e. n′ = m. Since h is consistent, h(n′) = 0 and h(n) ≤ c(n, n′) + 0. So h is admissible, 1 step from the goal. 2. Inductive case: Let n′ be a node on the shortest path between n and m, k steps from m, and say h(n′) ≤ c(n′, m). Since h is consistent, h(n) ≤ c(n, n′) + h(n′). So h(n) ≤ c(n, n′) + c(n′, m) = c(n, m). Since n is k + 1 steps from the goal, we conclude that the heuristic is admissible. 7 (5.2) Perform a Uniform Cost Search (UCS) on the graph. The start node is M and the goal node is F . Provide a step-wise explanation of the search as it progresses. At each step, provide the frontier, and show which node is selected for expansion. Provide the ﬁnal path from the start to the goal. Use the following format for your answer (step 1 has been completed below): Step Node expanded Frontier 1. M( ˆg = 0) . . . . . . . . . Remember: the ﬁrst step of a good search algorithm is always to generate the start node (i.e. place the start node in the frontier). Step two should begin with expanding the node in the frontier with the smallest ˆg value. Step Node expanded Frontier 1. M( ˆg = 0) 2. M K-M(2), O-M(4) 3. K-M O-M(4), E-K-M(6) 4. O-M E-K-M(6), J-O-M(6), D-O-M(9) 5. E-K-M J-O-M(6), D-E-K-M(8), N-E-K-M(8) 6. J-O-M D-E-K-M(8), N-E-K-M(8), A-J-O-M(12), H-J-O-M(13) 7. D-E-K-M N-E-K-M(8), A-J-O-M(12), H-J-O-M(13) 8. N-E-K-M G-E-K-M(10), A-J-O-M(12), H-J-O-M(13) 9. G-E-K-M A-J-O-M(12), H-J-O-M(13) 10. A-J-O-M H-J-O-M(13), F-A-J-O-M(18) 11. H-J-O-M F-A-J-O-M(18) 12. F-A-J-O-M When F is expanded, it is also goal tested. Notice that at step 5, expanding E-K-M, we generate D-E-K-M which is shorter than D- O-M, so we replace D-O-M with this shorter route. At step 10, G-. . . generates A-G-. . . , but it is a longer path than A-J-. . . , so we don’t put it on the frontier. At step 10, expanding A-. . . actually generates F-. . . (a goal path), but since there may still be a shorter path to F, the algorithm carries on. H-. . . only generates longer paths so F-A-. . . ends up at the front of the queue, and is chosen for expansion in step 12. Ties were broken using lexicographical name ordering of the node name in the state space. The ﬁnal path is thus: M-O-J-A-F with a path cost of 18. (5.3) Perform an A ∗ search on the graph in Figure 2. The start node is G and the goal node is H. Provide a step-wise explanation of the search as it progresses. At each step, provide the frontier, and show which node is selected for expansion. Provide the ﬁnal path from the start to the goal. Use Table 1 for the ˆh values for each node in the graph. Use the following format for your answer (step 1 has been completed below): Step Node expanded Frontier 1. G( ˆg = 0, ˆh = 19, ˆf = 19) 2. . . . . . . 8 COS3751/201 Remember: the ﬁrst step of a good search algorithm is always to generate the start node (i.e. place the start node in the frontier). Step two should begin with expanding the node in the frontier with the smallest ˆf value. Node Estimated distance to goal A 12 B 15 C 8 D 13 E 15 F 18 G 19 H 0 I 7 J 7 K 14 L 14 M 12 N 17 O 8 Table 1: Estimated distance to goal for A ∗ search. Step Node expanded Frontier 1. G( ˆg = 0, ˆh = 19, ˆf = 19) 2. G N-G(2,17,19), A-G(10,12,22) 3. N-G E-N-G(4,15,19), A-G(10,12,22) 4. E-N-G D-E-N-G(6,13,19), K-E-N-G(8,14,22), A-G(10,12,22) 5. D-E-N-G O-D-E-N-G(11,8,19), K-E-N-G(8,14,22), A-G(10,12,22) 6. O-D-E-N-G J-O-D-E-N-G(13,7,20), K-E-N-G(8,14,22), A-G(10,12,22), M-O-D-E-N-G(15,12,27) 7. J-O-D-E-N-G H-J-O-D-E-N-G(20,0,20), K-E-N-G(8,14,22), A-G(10,12,22), M-O-D-E-N-G(15,12,27) 8. H-J-O-D-E-N-G When H is expanded, it is also goal tested. Notice that at step 7, we don’t add A-J-O-D-E-N-G since ˆf = 31 which is greater than the existing path of A-G. The ﬁnal path is: G-N-E-D-O-J-H, with a length of 20. Question 6: 30 Marks Consider the four-queens problem. We would like to populate a 4 × 4 board with 4 queens. A queen is a piece (from chess) that can capture any other piece on the same diagonal, or in the same ﬁle 1 or rank 2. 1File is chess parlance for column. 2Rank is chess parlance for row. 9 Using local search algorithms, a search is performed as follows: • Initialise a board with queens placed randomly (one in each ﬁle), • Deﬁne an objective function to aid the local search, • Generate a successor state from the current state by moving one queen randomly either up or down one square (in the same ﬁle), • An optimum (minimum/maximum) is considered a goal. Consider the following random start state (we represent the state grahically to aid your effort, and you are welcome to provide graphical representations of successor states if asked): 4 0Z0Z 3 ZqZq 2 0ZqZ 1 l0Z0 a b c d Figure 3: Four Queens Initial State (6.1) Provide a good objective function that can be used as a maximizer (i.e. a global maxi- mum, a reward function) for the problem. Hint: 1. An objective function (also called either a loss, or reward function) is a function that maps the current state to some linear value which can be used to judge the ﬁtness or goodness of the state. When we want to avoid loss, we deﬁne an objective function with respect to loss, and we try to minimize loss by minimising the evaluation of the state using the objective function (i.e. we look for a state that results in the smallest value when evaluated using the objective function). When we want reward, we deﬁne an objective function with respect to reward and we try to maximize the objective function. 2. First write down the function in plain English, and then provide the mathematical equation for it. 3. Use the ranks, ﬁles, and diagonals in the state as part of your equation. We deﬁne the following: CP(Qi ) is the number of queens on the board that cannot capture the queen (Qi). P(Qi) provides the rank and ﬁle position of queen Qi. The objective function is then simply a sum of these values: F (S) = 4∑ i=1 CP(Qi ) (1) 10 COS3751/201 (6.2) Now that you have deﬁned your objective function, use it to evaluate the start state as provided in Figure 3. Show your calculations. Ca1 + Cb3 + Cc2 + Cd3 = 3 + 1 + 1 + 1 = 6 (6.3) A hill-climb/hill-descent local search generates a series of successors, and takes the best one from among them (using the objective function). Beginning from the initial state in Figure 3, provide two successors, one that is worse, and one that is an im- provement. Show why the successor is better, or worse by using the objective function to evaluate it. Remember: generate all possible successors, and choose the bet- ter/worse from among them. Remember, a successor state is generated by moving one queen, one row up or down. Worse: S1 = 4 0Z0Z 3 ZqZq 2 qZqZ 1 Z0Z0 a b c d , F (S1) = 0 Better: S′ 1 = 4 0l0Z 3 Z0Zq 2 0ZqZ 1 l0Z0 a b c d , F (S′ 1) = 10 (6.4) From the previous question, take the ’better’ state you identiﬁed. Generate all possible successors (remember: a successor is generated by moving one queen, one row up or down). Are there any improvements (show your calculations for each state)? The tree is split for layout reasons. From: 4 0l0Z 3 Z0Zq 2 0ZqZ 1 l0Z0 a b c d there are no improvements, only same or worse. The objective function evaluation for each state is provided below it. 11 4 0l0Z 3 Z0Zq 2 qZqZ 1 Z0Z0 a b c d 4 0Z0Z 3 ZqZq 2 0ZqZ 1 l0Z0 a b c d 4 0l0Z 3 Z0Zq 2 0Z0Z 1 l0l0 a b c d (2+3+1+2=8) (3+1+1+1=6) (2+3+2+3=10) 4 0l0Z 3 Z0lq 2 0Z0Z 1 l0Z0 a b c d 4 0l0l 3 Z0Z0 2 0ZqZ 1 l0Z0 a b c d 4 0l0Z 3 Z0Z0 2 0Zql 1 l0Z0 a b c d (2+2+0+2=6) (2+2+3+1=8) (3+2+2+1=8) (6.5) What type of topographical feature is most likely being created by the situation in the previous question? (Provide a rough sketch of this type of feature in a one dimensional state-space landscape.) This is most likely a local maximum. A typical sketch is provided in Figure 4.1 of the prescribed book. c⃝UNISA 2018 (v2018.1.2) 12","libVersion":"0.2.3","langs":""}