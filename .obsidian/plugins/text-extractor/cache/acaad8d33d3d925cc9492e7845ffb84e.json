{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Virtual Classes/VC05_Ch13_Models_Views.pdf","text":"COS3711 – Advanced Programming Virtual Class: COS3711 - 22 - ALL Chapter 13 – Models and Views Lecturer: Dr C Pilkington Tutor: Ron Barnard Models and Views Outcomes ▪ Understand and identify the Model-View-Controller pattern ▪ Design and implement applications with separated models and views ▪ Have an overview of Qt’s in-built models and views ▪ Use Qt’s in-built model and view classes ▪ Understand the role of delegates in Qt’s model / view framework ▪ Understand the value of smart pointers Models and Views Model-View-Controller (MVC) • M-V-C – Divides application logic into three components, based on their responsibilities. Decouples data from on-screen representation and user input – ◦ reduces complexity; ◦ promotes flexibility and code re-use; ◦ allows multiple views of the same data; ◦ separation of concerns; • Model – Manages access to data – can be stored in file, database etc. • View – The screen representation (User interaction). • Controller – Processes user input, instructs Model. Models and Views Model-View-Controller (MVC) ◦ The “Gang-of-Four” do not recognize MVC as an actual design pattern, but rather as a “Triad of Classes”, which implement Design Patterns - ▪ Observer – Communication between objects; ▪ Composite – Groups of objects treated as a single object eg: nested views; ▪ Strategy – View / Controller relationship. Can change the way view responds to a user at run time. Models and Views M-V-C (Classic) M-V-C (Classic) Other patterns have evolved from MVC - • Model-View-Presenter (MVP) – Presenter between Model and View, used in .NET. • Model-View-ViewModel (MVVM) – ViewModel between Model and View, used by Angular, React, Knockout. Models and Views Model-View (Qt) Qt implementation of Model-View • Qt combines the View and Controller – M-V architecture; • Separates the way data is stored from the way it is presented; • Same data can be displayed in different Views, and new types of Views implemented, without changing data structure; • Adds Delegate – allows flexible handling of user input, and customization of rendering and editing of data; • M-V Classes separated into 3 groups – Models, Views, Delegates; • Each defined by abstract Classes that provide common interfaces / implementations; • Abstract Classes must be sub-classed to provide full / additional functionality. • Models, Views, and Delegates communicate using signals and slots - ◦ Signals from Model inform View about changes to the data; ◦ Signals from View provide information about user interaction with View; ◦ Signals from Delegate inform Model (Data) and View (Rendering) about any editing. Models and Views M-V Models Models • All Models are based on QAbstractItemModel; • Defines interface used by Views and Delegates to access data; • Can handle tables, lists, and trees; • QAbstractTableModel and QAbstractListModel are better for Tables / Lists - provide default implementations of common methods. • Ready-made models - ◦ QStringListModel – Lists of QString items; ◦ QStandardItemModel – Multipurpose – list, table, and tree views; ▪ Must use QStandardItem for data in the model; ◦ QFileSystemModel – Files and directories in local file system. • NB: Abstract (must be sub-classed) vs concrete classes. Models and Views M-V Models Models Indexes - Each piece of data that can be accessed from a model is represented by a model index. Used by Views and Delegates to request items of data. Index is temporary – changes. Need to specify three properties to get an Index: row, column, model index of parent - QModelIndex index = model->index(row, column, parent); // Trees index to parent QModelIndex index = model->index(row, column, QModelIndex()); // Tables, lists Roles – allows different kinds of data to be supplied – Views can display roles differently. • Qt::DisplayRole (Default) – text data (QString); • Qt::EditRole – data in a form suitable for editing (QString); // Not QVariant; • Qt::StatusTipRole – data displayed in the status bar (QString); • Qt:BackgroundRole – background Brush used for rendering. QBrush(Qt::green) There are several others. Models and Views M-V Models Models Sorting – Model is made sortable by overriding QAbstractItemModel::sort() method, Interactive sorting – Connect QHeaderView::sortIndicatorChanged() signal to sortByColumn() slot of QTableView, or QTreeView. Can also setSortingEnabled() in view. For list Views, you need to use a Proxy Model. Methods to be overridden / implemented for concrete Classes - QAbstractItemModel - requires index(), and parent() to be implemented, in addition to - QAbstractTableModel - rowCount(), columnCount(), data(); Editable models - setData(), and flags(); Well behaved model – headerData(), and setHeaderData(). Models and Views M-V Models Methods to be overridden / implemented for concrete Classes - QAbstractItemModel - • index() - Returns index of item in the model, specified by row, column, and parent; • parent() - Returns parent of model item with given index. Returns invalid if none; QAbstractTableModel - • rowCount() - Returns number of rows of data in the model; • columnCount() - Returns the number of fields per record; • data() - Fetches data from the model to display in view, depends on role. Editable models - • setData() - Sends updated data to model when view is edited; • flags() - Returns item flags for given index; Well behaved model – • headerData() - Returns headers for columns in the view. Based on field names; • setHeaderData() - Sets header data. Models and Views M-V Views Views • All Views are based on QAbstractItemView; • Defines interface used by Views; • Can handle tables, lists, trees and columns; • Ready-made Views (Can be sub-classed) - ◦ QListView – Displays list of items; ◦ QTableView – Displays data from a model in a table; ◦ QTreeView – Displays tree representation of items from a model; ◦ QColumnView – Displays multiple QListViews, based on trees (Cascading list). Headers – access the same Model as the View that contains them. Use QHeaderView Class – displays headers in views QTableView, QTreeView. Retrieve data from model: QAbstractItemModel::headerData() method. Set header data: QAbstractItemModel::setHeaderData(); Models and Views M-V Views Selection – • Handled by QItemSelection Class; • The standard Views construct their own selection models by default; • Selection model in use obtained by: selectionModel(); • Selection model can be specified by: setSelectionModel(); • Useful to provide consistent multiple Views. • Indexes stored in the selection model can be read using the selectedIndexes() method of QSelectionModel. Returns a QModelIndexList. Sorting - • Most views have a setSortingEnabled(bool) method. Easier than sorting in model. Multiple Views – • Can use multiple Views by setting same model for each view; • Use setModel(model) to set multiple Views. Models and Views M-V Delegates Delegates • M-V does not include separate component (Controller) for managing user interaction. Generally, View is responsible for processing user input, and presenting model data. • Delegates – control rendering and editing of individual items in Views. • Provide editing capabilities (flexibility) for Views. • All Delegates are based on QAbstractItemDelegate; • QStyledItemDelegate - default Delegate provided by Views; • Provides default implementation of Delegate interface; • Can be sub-classed, to change appearance of View. Models and Views M-V Convenience Classes Convenience Classes • Merge Model and View into one Widget (No Delegate); • Self-contained, not intended to be sub-classed; • Derived from standard View Classes; • Trade-off – ease of use vs less flexibility / re-usability; Advantage - • Easier to learn to use / implement; Disadvantages - • Difficult to re-use / subclass (Not recommended); • Difficult to use multiple views on same set of data; • Strong dependency between user interface / underlying data (Closely coupled). • “Take-it or leave-it” approach. Models and Views Example - QListView #include <QApplication> #include <QListView> #include <QAbstractItemModel> #include <QStringListModel> int main(int argc, char *argv[]) { QApplication a(argc, argv); QStringList list; list << \"COS3711\" << \"COS2614\" << \"COS1512\" << \"COS1511\"; QAbstractItemModel *model = new QStringListModel(list); QListView *view = new QListView; view->setModel(model); view->show(); return a.exec(); } Models and Views Example - QListWidget #include <QApplication> #include <QlistWidget> int main(int argc, char *argv[]) { QApplication a(argc, argv); QStringList list; list << \"COS3711\" << \"COS2614\" << \"COS1512\" << \"COS1511\"; QListWidget *lw = new QListWidget; lw->addItems(list); lw->show(); return a.exec(); }","libVersion":"0.2.3","langs":""}