{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Notes/qtQuestions.pdf","text":"Advanced programming Theory Questions Chapter7 1.For each of these items, decide whether it would normally be found in a header (.h) file or an implementation (.cpp) file and explain why. a. Function definitions [solution] implementation - they should be only compiled once, and not included by other modules that use it. b. Function declarations [solution] usually the header file, to refer to functions defined in other separate implementation files. c. static object declarations [solution] header files, like most declarations. d. static object definitions [solution] implementation file, just like functions. We do not wish to have redundant storage allocation for statics. e. Class definitions [solution] These go in the header file. f. Class declarations [solution] header file - usually they are forward declarations. g. inline function definitions [solution] header files - unlike regular functions which can be linked together, inline functions need to be fully defined before they can be used. h. inline function declarations [solution] Header file - Rarely used for member functions except when the declaration is separated from the definition - but kept in the same header file. a.  Default argument specifiers [solution] header file - default arguments to a function changes the way the function is called. This is the realm of the header file . 2. What is the difference between a compile time dependency and a link time dependency? [solution] A compile time dependency exists if we need to #include the header file in order to reuse the symbol. A link time dependency exists if we can get away with just a declaration of the symbol, which requires the linker to be able to find the referenced symbol. 3 What is a framework? Are you using one? 4 What is a design pattern? What do most design patterns have in common? [solution] Most design patterns describe how to separate code by responsibility. Each has a pattern name, a description of the problem to which the pattern applies, a description of how the pattern solves the problem, and a discussion of the consequences of employing the pattern. 3. What is an AntiPattern? Chapter12 Reflection 1. What kinds of information can you obtain from a QMetaObject? [solution] a. [solution] className(), which returns the class name as a const char* b. [solution] superClass(), which returns a pointer to the QMetaObject of the base class if there is one (or 0 if there is not) c. [solution] methodCount(), which returns the number of member functions of the class d. [solution] method(index), which returns the meta-data for the method with the given index. e. [solution] propertyCount(), which returns the number of properties in this class, including base class properties. f. [solution] property(index), which returns the meta-data for the property with the given index. [solution] 2. What Qt classes are used to do data reflection? Explain why. [solution] QMetaObject, QMetaProperty, QSqlDatabase::tables, QSqlRecord, QVariant 3. How does the QMetaObject code for each of your QObject-derived classes get generated? [solution] moc generates QMetaObject classes to support properties, signals and slots. Normally, you do not run moc directly. It is run automatically by make on the header files listed in HEADERS which use the Q_OBJECT macro. 4. What is a downcast? In what situations do you use them? [solution] A downcast is a conversion from something \"higher\" (more general) in the inheritance graph, to a \"lower\" class (one of its derived types). We use downcasts in situations where we are forced to use a base class pointer (usually because a function we did not write is using that type) but we require a non-polymorphic derived class member function. 5. What is RTTI? How does Qt provide RTTI? 6. Discuss the differences between the dynamic_cast and qobject_cast operators. 7. What is a QVariant? How might you make use of one? 8. What are the advantages of using property() and setProperty() over direct getters and setters? [solution] Q_PROPERTY macros make it possible for moc to generate code for QObject's property() and setProperty() member functions. The advantage of using these functions is that client code can determine which properties are available by iterating through QMetaProperty objects of the QMetaObject corresponding to that class. 9. What does the property() function return? How do you obtain the actual stored value? [solution] property() returns a QVariant, which is a union wrapper around every possible basic type, and also several Qt classes/types. With QVariant, you can ask for its type() and convert to the actual value<>(). Benefits are most apparent when implementing script engines or developer tools. It becomes possible to define \"handle anything\" kinds of functions without using anything but the QObject interface to read and write values. 10. Explain how it is possible to add new properties, acquired at runtime, to a QObject. [solution] setProperty(\"propName\") sets a dynamic property for that object even if it is not declared as a Q_PROPERTY 11. Explain how dynamic properties can be serialized. [solution] They are stored in a QVariantMap, which can be serialized via a QDataStream. Chapter13 Modelview 1. What are model classes? What are view classes? What relationship should be maintained between them? 2. What tools are provided by Qt to work with models and views? 3. What is MVC? Model–view–controller (MVC) is a software architectural pattern for implementing user interfaces. It divides a given software application into three interconnected parts, so as to separate internal representations of information from the ways that information is presented to or accepted from the user. MVC consists of three kinds of objects. The Model is the application object, the View is its screen presentation, and the Controller defines the way the user interface reacts to user input. Before MVC, user interface designs tended to lump these objects together. MVC decouples them to increase flexibility and reuse. 4. What is controller code? Which Qt classes are controller classes? [solution] Code which creates, destroys, or connects objects together is considered controller code. QApplication and QAction are both containers for controller code, but the ItemDelegate is also considered a controller. 5. What are delegates? Where are they found? 6. In relation to delegates, what are roles? 7. How do you determine what item(s) is/are selected in a QListView? [solution] Each view has a SelectionModel which can describe which item(s) are selected in a view. 8. If you want to iterate through items in an QAbstractItemModel, what would be a good class to use? [solution] QModelIndex is a \"cursor\", or an indirect reference to data in a model. This can be used to iterate through items in the model. 9. There are two hierarchies of classes for storing and displaying tree-like data: *Widget/Item and *ItemModel/View. What reasons might you have for using one rather than the other? 10. Why would you use the QStandardItemModel rather than the QAbstractItemModel? Or vice versa? [solution] StandardItemModel holds onto the data, while an abstract model can be a proxy for data elsewhere. StandardItemModel can lead to duplication of data. It is recommended to implement abstract methods from an AbstractItemModel for custom models. Chapter14 Validation 1. What is an input mask? What can an input mask do for you? [solution] An inputMask is a QString property of a QLineEdit which can contain mask chars to constrain the incoming text. An inputMask can specify what kinds of characters are allowed in certain positions of a string that is being typed into a QLineEdit. 2. What is a regular expression? What can you use it for? 3. What is a validator? What is it used for? 4. Describe three different kinds of validators. 5. What is a regular expression meta-character? There are four kinds of metacharacters: quantifier, character set, group, and anchor. Give examples of each type and explain what they mean. [solution] A meta-character is a character that \"describes\" other characters. Quantifiers are ?*+{m,n} - they modify the preceeding thing with a quantity. Character Sets are things that can be replaced by other characters: .\\d\\D\\s\\S\\w\\W[a-z]. Grouping characters are parantheses (), which let you back-reference parts of the matched result. Anchoring characters describe what goes at the beginning or end of the pattern: ^\\b\\B$. 6. Why would you want to extend QValidator? [solution] When the thing you are checking is not a simple regular expression, but something that requires advance calculation. Chapter15 Xmlparsing 1. If there is a syntax error in your XML file, how do you determine the cause and location? [solution] xmllint is one way. Also, you can define an ErrorHandler in SAX, or ask the QXmlStreamReader for the line number of errors. Also, XML editors such as jEdit with the XML plugin can parse and show you where errors in XML documents are. 2. SAX is an event-driven parser. What kinds of events does it respond to? [solution] Start of element, end of element, characters, etc 3. Compare and contrast SAX and DOM. Why would you use one rather than the other? [solution] SAX is a lower-level API, which handles individual parse events (start of element, end of elementm etc). DOM is an Object Model, which uses SAX under the covers to parse the data into an in-memory tree structure. SAX is useful if you need a way to quickly process infinitely large XML files in a stream-like way. DOM is nice if you want to load the entire tree into memory and traverse/manipulate it. 4. If you have a QDomNode and it is actually \"pointing\" to a QDomElement, how do you get a reference to the QDomElement? [solution] You can't use normal typecasts because QDomNode and QDomElement are not pointers. Therefore, use the toElement() function instead. 5. What are the advantages of using QXmlStreamReader over SAX? [solution] It is faster, uses less memory, and is easier to learn and use. 6. What are the advantages of using QXmlStreamReader over DOM? [solution] DOM needs to load an entire document in memory, using a very inefficient representation. With the QXmlStreamReader, you can choose to create or not create objects of any size you want as you are parsing the document. Chapter16 Morepatterns 1. How can a creational pattern help manage object destruction? [solution] By adding the pointer to a list of objects to be destroyed, before returning it from the Factory method. This can be achieved in a number of ways, such as adding it as a child to another object, or a managed pointer collection. 2. How can properties help you write a more general-purpose Writer? [solution] Properties can be inspected at runtime to find out what names/values need to be loaded/saved. This way, you can write one serializer for all QObjects. 3. How can an Abstract Factory help us write a more general-purpose Reader? [solution] With an Abstract Factory, we can \"plug in\" different kinds of ObjectFactory objects into the same Reader, to support different libraries of types. This helps separate the Reader code from the library-specific code. 4. What Qt classes are implementations of the Facade pattern? Explain why they are facades or wrappers. [solution] QString, QWidget, QThread, QProcess, QSqlDatabase, QFile, and many others. Chapter17 Concurrency 1. List and explain at least two mechanisms by which a parent process communicates information to its child process. [solution] a. [solution] Command-line arguments b. [solution] standard input and output streams c. [solution] environment variables [solution] 2. List and explain at least two mechanisms by which threads synchronize with each other. [solution] a. [solution] locks b. [solution] wait conditions c. [solution] mutexes d. [solution] semaphores [solution] 3. In what situations can a QTimer be used instead of a QThread? Why would one want to do that? [solution] A QTimer is useful if the simultaneous task that needs to be performed can be implemented as an incremental algorithm that requires repeated calls to a function that does not run for a long period of time. In this situation, we can avoid the use of threads (which sometimes have problems accessing QObjects/QWidgets from other threads). 4. What does it mean for an function to be thread-safe? [solution] A thread-safe function is one that can be called concurrently by multiple threads and is guaranteed to serialize access to shared data, perhaps through the use of a mutex or lock. 5. Which class can be used in non-GUI threads? QImage or QPixmap? [solution] QImage can be used in other threads. QPixmap is considered a \"gui\" class and should only be used in the main GUI thread. 6. What does it mean for a function to be reentrant? [solution] Multiple threads can call a reentrant function safely, and they do not need to access the same data, so they do not block each other during the calls. 7. How do you tell a non-GUI thread to enter into an event loop? [solution] QThread::exec() 8. Without using extra threads, how can you keep the GUI responsive while still performing a long-running loop? [solution] qApp->processEvents()","libVersion":"0.2.3","langs":""}