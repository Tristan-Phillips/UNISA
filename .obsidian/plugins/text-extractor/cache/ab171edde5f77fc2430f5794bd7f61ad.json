{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/Virtual Classes/VC08_Ch16_Design_Patterns.pdf","text":"COS3711 – Advanced Programming Virtual Class: COS3711 - 22 - ALL Chapter 16 – Design Patterns Lecturer: Dr C Pilkington Tutor: Ron Barnard Design Patterns Outcomes ◦ Understand, identify, and implement - ▪ Factory Method Pattern ▪ Abstract Factory Pattern ▪ Singleton Pattern ▪ Memento Pattern ▪ Facade Pattern ▪ Strategy Pattern ▪ Adapter / Wrapper Pattern ▪ (Serializer) Reference: Design Patterns – Elements of Re-usable Object-Oriented Software Gamma, Helm, Johnson & Vlissides (“Gang-of-four”) Recommended: Head First – Design Patterns. 2nd Ed. Freeman, Robson. Design Patterns Introduction Design Pattern – is a general repeatable solution to a commonly occurring problem in software design. They are high-level abstract templates that can be applied to particular kinds of design problems. • Creational – Make a system independent of how its objects are created, composed, and represented. ◦ Factory Method, Abstract Factory, Singleton. • Behavioural – Effective communication and assignment of responsibilities between objects. ◦ Memento, Strategy, Serializer. • Structural – Assembly of objects and classes into larger structures, while keeping the structures flexible and efficient. ◦ Facade, Adapter / Wrapper. Design Patterns Introduction A Design Pattern has four essential elements - • Pattern name – 'Handle' used to describe a design problem, its solutions, and consequences, in a word or two. • Problem – Describes when to apply the pattern – explains the problem and its context. • Solution – Describes the elements that make up the design, their relationships, responsibilities, and collaborations. Pattern is a 'template' that can be used in many different situations – NOT a concrete design or implementation. • Consequences – The results and trade-offs of applying the pattern – critical for evaluating design consequences. Design Patterns Factory Method Pattern Intent – Provides an interface for creating (instantiating) objects in a superclass, but allows sub-classes to actually create the objects. (Classic Factory Method). Applicability – • Provides a common interface for instantiating related objects; • Responsibility for creating objects transferred to separate factory method class (Single purpose – separates object creation from object use). Comment - • Makes extensive use of abstract base classes, inheritance, and polymorphism; • Variations – ◦ Abstract base class not always used; ◦ GoF - “parametized” Factory Method – simplified version; ◦ More complex implementations lead to Abstract Factory Pattern. ◦ Note: Comment in Ezust incorrect – Abstract Factory Pattern is NOT Factory Method with abstract base class. Design Patterns Factory Method Pattern • Product – Abstract base class for Products. • ConcreteProduct – Concrete Class that implements Products. • Creator (Optional) – Abstract base class – optional, not always used. • ConcreteCreator – Concrete class that implements the factoryMethod() ◦ returns – new ConcreteProduct. Design Patterns Factory Method Pattern - BreadFactory example // Code in client application - bake() BreadFactory bf; Bread *whiteBread; Bread *brownBread; whiteBread = bf.makeBread(\"wBread\"); brownBread = bf.makeBread(\"bBread\"); whiteBread->doSomething(); brownBread->doSomething(); // Factory Method code - makeBread(QString ) Bread * BreadFactory::makeBread(QString breadName) { if (breadName == \"wBread\") { return new WhiteBread; } else if (breadName == \"bBread\") { return new BrownBread; } else { return nullptr; } } Design Patterns Abstract Factory Pattern Intent – Provides an interface for defining factories that share abstract features, but differ in concrete details. Applicability – Used when there is a need to create families of related, or dependent objects – two hierarchies - • Hierarchy of Product Classes; • Hierarchy of Factory Classes. Design Patterns Singleton Pattern - Static Static (Class members) – declares members that are not bound to Class instances. • not associated with any object; • obey the class member access rules – private, protected, public. Static methods - • static keyword is only used with the declaration of a static member, not with definition - inside Class body will give error; • accessed using scope resolution outside the Class – myClass::staticMember; • can only access static data members. No this pointer. Static data member - static data member must be initialized outside the Class; Static local member - Initialized the first time control passes through the declaration, skipped on all further calls. Retains value between method / function calls. Static (General) – Memory is allocated when a program begins, and deallocated when the program ends - “static duration” - do not go out of scope. Design Patterns Singleton Pattern Intent – Ensure that a class has only a single instance, and provide a global point of access to it. Applicability – Use Singleton when there can / must only be one instance of a Class, and it must be accessible from a well known / easily accessible access point. Singleton - instance : Singleton * - Singleton() + getInstance() : Singleton * + doSomething() : void • Constructor – Singleton() - is private; • Data member - instance (static) - stores a pointer to the Singleton object (Optional); • Method – getInstance() (static) – returns a pointer to a new instance if one does not exist, or a pointer to the existing instance, if one does exist. Design Patterns Singleton Pattern - Code Singleton 1 // singleton.h class Singleton { public: static Singleton * getInstance(); private: Singleton(); static Singleton * instance; }; // main.cpp Singleton *singleton1 = Singleton::getInstance(); Singleton *singleton2 = Singleton::getInstance(); out << \"Singleton1 address: \" << singleton1 << Qt::endl; // singleton.cpp Singleton * Singleton::instance = 0; Singleton::Singleton() { qDebug() << \"New Singleton ! \" << Qt::endl; } Singleton * Singleton::getInstance() { if (!instance) { instance = new Singleton; } return instance; } Design Patterns Singleton Pattern - Code Singleton 2 // singleton.h class Singleton { public: static Singleton * getInstance(); private: Singleton(); }; // main.cpp Singleton *singleton1 = Singleton::getInstance(); Singleton *singleton2 = Singleton::getInstance(); out << \"Singleton1 address: \" << singleton1 << Qt::endl; // singleton.cpp Singleton::Singleton() { qDebug() << \"New Singleton ! \" << Qt::endl; } Singleton * Singleton::getInstance() { static Singleton *instance = 0; if (!instance) { instance = new Singleton; } return instance; } Design Patterns Memento Pattern Intent – Save and restore the previous state of an object, without breaking encapsulation. Applicability – Used when the state of an object needs to be saved, so that it can later be restored, without breaking encapsulation. (“Undo” or “Backup / Restore”). • Memento – an object that stores a 'snapshot' of the state of another object; • Memento can only be set / read by the Originator itself (Encapsulation); • Originator has to be involved in saving and restoring its state. • Ezust Chapter 16.2 – NOT Memento Pattern, describes Serializer Pattern. Design Patterns Memento Pattern • Originator – Object whose state is to be saved. ◦ Saves itself – Memento createMemento() returns new Memento(state) ◦ Restores itself – void setMemento(Memento m) • Caretaker – Object that stores / initiates Mementos – cannot access Memento; • Memento – Object that stores / re-stores state of the Originator object; ◦ Sets state of the Memento – void setState(State state); ◦ Retrieves state of the Memento – State getState(); ◦ All methods / properties are private; ◦ Declare Originator to be a friend of the Memento, so it can access Memento. Design Patterns Memento Pattern - Interaction • void Caretaker::saveState() ◦ Memento * Originator::createMemento() ▪ void Memento::setState(QStringList state) • void Caretaker::restoreState() ◦ void Originator::setMemento(Memento *m) ▪ QStringList Memento::getState() Design Patterns Memento Pattern - Code Originator – Header file Originator – source file class Originator { public: Originator(); void setMemento(Memento *m); Memento * createMemento(); private: // State values QString m_name; QString m_code; QString m_value1; QString m_value2; }; void Originator::setMemento(Memento *m) { QStringList state = m->getState(); m_name = state.at(0); m_code = state.at(1); m_value1 = state.at(2); m_value2 = state.at(3); } Memento * Originator::createMemento() { QStringList state; state << m_name << m_code << m_value1 << m_value2; Memento *memento = new Memento; memento->setState(state); return memento; } Design Patterns Memento Pattern - Code Memento – Header file Memento – source file class Memento { public: private: friend class Originator; Memento(); QStringList getState(); void setState(QStringList state); QStringList m_state; }; QStringList Memento::getState() { return m_state; } void Memento::setState(QStringList state) { m_state = state; } Design Patterns Memento Pattern - Code Caretaker – Header file Caretaker – source file class Caretaker { public: Caretaker(Originator *origin); void saveState(); void restoreState(); private: Memento *m_state; Originator *m_origin; }; Caretaker::Caretaker(Originator *origin) : m_origin(origin) { } void Caretaker::saveState() { m_state = m_origin->createMemento(); } void Caretaker::restoreState() { m_origin->setMemento(m_state); } Design Patterns Strategy Pattern Intent – Family of algorithms that needs to be made interchangeable, based on the context. Applicability – • Enables the selection of an algorithm at runtime. • Define a family of algorithms, encapsulate each one (Class). ◦ Abstract base class, inheritance for concrete Classes. • Make them interchangeable - Context keeps reference / pointer to Strategy objects. ◦ Composition, polymorphism. • Allows the algorithms used to vary independently from clients that use it. Design Patterns Strategy Pattern • Strategy (Abstract) – Declares common interface for all algorithms (Sub-classes). • Context – uses this interface to call the algorithm as defined by a ConcreteStrategy. ◦ Passes data to Strategy when instantiated / algorithm is called. ◦ Forwards requests from Client to Strategy. • ConcreteStrategy – implements algorithm using interface defined by Strategy. • Client – Instantiates and passes ConcreteStrategy object to Context. ◦ Interacts with Context. Design Patterns Strategy Pattern / Factory Method Strategy Pattern can be combined with the Factory Method - Note: Example in Video – Context Class is included in Client Class. Design Patterns Facade Pattern Intent – Hides the complexity of a system by providing a simplified interface for client access. Applicability – • Used to provide a simplified interface to a complicated set of systems; • Facade interacts with sub-systems, based on requests from Client/s; • Higher level interface that makes sub-system easier to use. Design Patterns Serializer Pattern Intent – Used to serialize / stream state of objects into / out of other objects. Applicability – Primarily used for communication; • Not intended for general input / output or save / restore; • Class to be serialized / de-serialized does not participate in the process; • Subject Class must be able to provide its state, and allow its state to be set. • Implements two Classes – ◦ classReader, with a read() method; ◦ classWriter, with a write() method; • Do NOT implement as a single class, with read / write methods; Design Patterns Adapter / Wrapper Pattern Intent – Converts the interface of an existing Class into another. Applicability – Re-use the functionality of a Class when the interface of the Class is not compatible with existing Classes. • Called a 'wrapper' because it can be seen as 'wrapping' around an existing Class to present a different interface to other Classes. • Adaptor lets classes work together that could not otherwise, due to incompatible interfaces. Design Patterns Serializer vs Memento Serializer Memento Mainly used for communication of object state Used to save / restore state of an object Breaks encapsulation Preserves encapsulation Serialization / de-serialization done by external Classes. State saved / restored by Class itself (Originator) Can use serialization / de-serialization to save / restore state. Design Patterns Singleton vs Mono-state Singleton Mono-state Enforces structure of singularity Enforces behaviour of singularity Can be created through inheritance Cannot be created through inheritance Cannot be inherited (Private constructor) Need to add static method & variable (Cannot override static methods) Can inherit from mono-state Class Derived Class is mono-state Not transparent – know it is Singleton Transparent – do not know it is mono-state The Principles, Patterns, and Practices of Agile Software Development - Robert C Martin (“Uncle Bob”) “Singleton and Mono-state” PDF - Robert C Martin Design Patterns Past papers • Oct / Nov 2020 - ◦ Q3.5 It could be argued that a model to manage all hospital beds should be a singleton. What would you consider to be a convincing argument in this scenario ? (2) ◦ Q3.6 The following code has been provided to ensure the singleton design pattern. Does this meet the requirements of the classic singleton design pattern (in which case you should explain why), or not (in which case you should rewrite it to make it implement the pattern) ? (4) ◦ class BedsSingleton { public: QStandardItemModel* getModel(); private: BedsSingleton(); static QStandardItemModel beds; }; Design Patterns Past papers ◦ Q3.8 (Given UML diagram) - The createMemento() function code is as follows - BedMemento* BedList::createMemento() { QMultiMap<QString, Bed*> memento; for (int i=0; i<list->size(); i++) { const QMetaObject* meta = list->at(i)->metaObject(); QString name = meta->className(); memento.insert(name, list->at(i)); } BedMemento* m = new BedMemento(); m->setState(memento); return m; } Using this code as a guideline, give the class declaration for the BedMemento class so that it follows the classic Memento design pattern. (8) To do - • Read TL105, Prescribed book: Chapter 16 (?), Do Exercise 8, Past Papers. • Refer to recommended books x2.","libVersion":"0.2.3","langs":""}