{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Tutorial Letters/202_2018_1_b-7 1.pdf","text":"BAR CODE Deﬁne Tomorrow. university of south africa Tutorial Letter 202/1/2018 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 School of Computing IMPORTANT INFORMATION This tutorial letter contains model solutions for assignment 02 COS3751/202/1/2018 ASSIGNMENT 02 Solution Total Marks: 100 UNIQUE ASSIGNMENT NUMBER: 868331 Study material: Chapters 5, 6, 7, 8. You may skip sections 5.5, 5.6, and 5.7. Question 1: 10 Marks (1.1) Clearly explain what a utility function is, and why it is used during adversarial searches. In adversarial searches, a utility function provides a numerical value for a ﬁnal state s for player p. It is used to identify winning and losing states for a player. (1.2) Is the ideal strategy only available if we have perfect information? Explain your answer. No. Agents can still get the ideal strategy when playing without all the information. This means the ideal strategy includes the notion of limited information. However, an agent that has perfect information will most likely outperform an agent that has limited/imperfect information for the same problem. (1.3) Explain how forward pruning works. Provide at least one approach to forward prun- ing in your explanation, as well as a problem that may be encountered with forward pruning. Forward pruning means that some nodes are pruned without even considering them. For example, beam search only considers a sample of the best moves at each ply, but this may lead to the best move being pruned away. (1.4) Does the order in which nodes are examined in minimax matter? Explain your answer. Only if we prune. Otherwise minimax is an exhaustive search (for the parameters such as depth – plys – it is conﬁgured for) and node orders do not matter. Question 2: 20 Marks Consider Figure 1 and answer the questions that follow. (The utility value of each leaf node is provided below the leaf node.) (2.1) Provide the minimax values for all the non-leaf nodes. A = 5, B = 5, C = 3, E = 8, G = 3 (2.2) Which move should MAX make? Explain your answer. B. The utility value for MAX for move B is higher than that of move C. 2 COS3751/202 A B D 5 E I 8 J -1 F 10 C G K -5 L 3 H 20 Figure 1: Minimax, alpha/beta (2.3) Write down the α/β values for all the nodes (except the leaf nodes) if alpha/beta prun- ing is applied to the tree. 3 A B D 5 E I 8 J -1 F 10 C G K -5 L 3 H 20 v ≥ β: J cut v ≤ α: H cut v = \b\b−∞ 5 α = \b\b−∞ 5 β = ∞ v =ˆ∞ 5 α = −∞ β =ˆ∞ 5 v =ˆ∞ 3 α = 5 β = ∞ v = \b\b−∞ 8 α = −∞ β = 5 v = \b\b−∞ˆˆ−5 3 α = \b\b−∞ˆˆ−5 3 β = ∞ (1) (2) (3) 5 (4) (5) (6) 8 (7) 8 (8) (9) 10 (10) 5 (11) (12) (13) (14) -5 (15) (16) 3 (17) (18) 3 The ﬁnal values are: A = (5, ∞), B = (−∞, 5), E = (−∞, 5), C = (5, ∞), G = (3, ∞) (2.4) Write down which nodes were cut and what type of cut was made in each case (alpha, or beta). J was beta-cut, and H was alpha-cut. Question 3: 20 Marks Consider the subtraction game: two players (A and B) take turns removing items from a heap (just one heap). Each player may remove either one, two, or three items from the heap. The heap starts off with 21 items, and player A moves ﬁrst. The objective of the game is to be the last player to remove items from the heap. That is, if it is your turn to move, and the heap is empty, you’ve lost the game 1. The initial state for the game is (A, 21) indicating that it is A’s turn to move and there are 21 items on the heap. In general then, a state is represented as (P, n) where P ∈ {A, B}, and 0 ≤ n ≤ 21. The evaluation function for non-terminal nodes is a simple threshold function deﬁned as: eval(S) = { −1 if S.n mod (k + 1) = 0, 1 otherwise 1Visit https://youtu.be/aonCsvi0LKc to see how the game is played. 4 COS3751/202 S.n refers to the number of items left in the heap in state S, and mod is the integer modulo function. k is the maximum number of items that can be removed from the heap at each turn, so k = 3. (3.1) Draw the entire game tree, starting from the initial state, down to depth two (the initial state is at depth 0), and provide the evaluation for each state at depth 2. (A,21) (B,20) (A,19) (A,18) (A,17) (B,19) (A,18) (A,17) (A,16) (B,18) (A,17) (A,16) (A,15) (3.2) Using the minimax algorithm, provide the backed-up values for states at depth 1 and 0. (Hint: Since you don’t have the entire game tree, and thus no terminal states, you cannot use a utility value to calculate the backed up values. However, you do have an evaluation function.) There are ﬁve different states on depth 2 (which is a max level): (A, 19), (A, 18), (A, 17), (A, 16), and (A, 15). eval((A, 19)) = 1, since (19 mod (3 + 1) = 19 mod 4 = 3, eval((A, 18)) = 1, eval((A, 17)) = 1, eval((A, 16)) = −1, eval((A, 15)) = 1. At depth 1 (a MIN level), (B, 20) ≡ MIN(eval((A, 19)), eval((A, 18)), eval((A, 17)) ≡ MIN(1, 1, 1) ≡ 1. (B, 19) ≡ MIN(eval((A, 18)), eval((A, 17)), eval((A, 16)) ≡ MIN(1, 1, −1) ≡ −1. (B, 18) ≡ MIN(eval((A, 17)), eval((A, 16)), eval((A, 15)) ≡ MIN(1, −1, 1) ≡ −1. Finally, at depth 0, (A, 21) ≡ MAX (1, −1, −1) ≡ 1. (3.3) Which node(s) would not have been evaluated at depth 2 if alpha/beta pruning was employed? Below (B,18): (A,15) (cut because α = 1, and v = −1 from (A,16). Thus (A,15) is cut. Question 4: 10 Marks Answer the following questions on Constraint Satisfaction Problems (CSPs). (4.1) Deﬁne the Least Constraining Value (LCV) heuristic. The LCV heuristic is used to choose values for variables in a constraint graph. It prefers values that rule out the fewest choices for neighbours (it tries not to limit the number of choices that remain for neighbours). 5 (4.2) Explain why establishing strong k-consistency is a problem. This means we must show that the graph is k-consistent, k − 1-consistent and so on. This can only be done in exponential time which makes large problems intractable. (4.3) Deﬁne the degree heuristic. This heuristic attempts to reduce the branching factor on future choices. (4.4) If no legal assignments for a variable remain during a solution to a CSP, does it mean that the algorithm will be able to ﬁnd a solution by simply backtracking? Explain your answer. No. It may very well be that there is no answer (there is no form of consistency for the problem given the constraints, resulting in no solution). (4.5) Explain what forward checking for a CSP is. It is a domain reduction technique which establishes arc consistency. (Or: It removes values from the domain of the neighbours of the variable for which the forward checking is being done that are inconsistent with its value.) Question 5: 30 Marks CSPs are especially useful when trying to solve scheduling problems. Consider the problem of determining how to assign aircraft in a ﬂeet to particular ﬂights. A ﬂight (or a leg) is simply a scheduled transference of passengers from a departing airport to a desti- nation airport (with no stops inbetween). In order to transfer passengers between the source and destination airport a ﬂight needs an aircraft. Additionally, aircraft have a minimum turn-around time of 30 minutes. That is, an aircraft cannot arrive, and then simply take of again. It has to taxi to the gate, passengers should debark, the aircraft should be cleaned, and the new passengers should embark. Only then can the aircraft taxi to the assigned runway and then take-off. The airline in question operates a small ﬂeet of short-haul aircraft, and all ﬂights are only for 9 or fewer passengers. Consider the following ﬂight schedule: Flight Departs Lands QQ144 9:15 10:45 QQ144 14:00 14:45 QQ169 12:15 13:15 QQ108 10:45 11:45 QQ256 09:30 10:15 QQ254 11:15 13:30 QQ099 11:15 13:30 QQ512 13:15 14:15 QQ056 11:15 11:45 QQ134 10:00 10:45 QQ134 14:00 14:45 6 COS3751/202 You can assume that departure happens from the same airport (you don’t have to worry about the location of the aircraft). The airline owns several Cessna 208 Grand Caravans (208B), which are: 1. XAX-143, 2. XAX-884, 3. XAX-547, 4. XAX-344, 5. XAX-254, 6. XAX-983, 7. XAX-124 (5.1) The ﬁrst step when representing a problem as a CSP is to deﬁne the variables. The variables are those elements in the problem that get assigned something else from the problem. Read the above problem description carefully to determine which ele- ments from the problem are variables. Now provide these variables for the problem. Remember to use the correct notation! Hint: In most cases the variables are those elements from the problem which will require the use of a limited item available. The variables are simply the ﬂights: X = {QQ144, QQ169, QQ108, QQ256, QQ254, QQ099, QQ512, QQ056, QQ134}. (5.2) Once the variables have been deﬁned, we proceed to deﬁning the domain for each variable. That is, the ‘value’ that each variable can take. Deﬁne the domain for each variable in the CSP. The domain for each variable will be the aircraft that can be assigned to ﬂights. DX = { XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124 } (5.3) The constraints determine the ‘restrictions’ placed on variables. Deﬁne the constraints for the variables in the CSP. 1. QQ144 ̸= QQ108 2. QQ144 ̸= QQ256 3. QQ144 ̸= QQ099 4. QQ144 ̸= QQ512 5. QQ144 ̸= QQ134 6. QQ169 ̸= QQ254 7. QQ169 ̸= QQ099 7 8. QQ169 ̸= QQ512 9. QQ108 ̸= QQ254 10. QQ108 ̸= QQ056 11. QQ108 ̸= QQ134 12. QQ256 ̸= QQ134 13. QQ254 ̸= QQ099 14. QQ254 ̸= QQ056 15. QQ099 ̸= QQ512 16. QQ099 ̸= QQ134 17. QQ512 ̸= QQ134 (5.4) Provide the constraint graph for this problem. QQ144 QQ169 QQ108 QQ256 QQ254 QQ099 QQ512 QQ056 QQ134 8 COS3751/202 (5.5) Provide the solution to the problem. Use the Minimum Remaining Values (MRV) heuristic, and at each step establish arc-consistency for the variables. Show how the solution is calculated in a step by step fashion. Provide the variables and their associated values as your ﬁnal answer! Using MRV we easily choose any of the variables, and we can easily assign any aircraft to them. Choose QQ144 = XAX-143. • DQQ056,QQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX- 983,XAX-124} • DQQ108,QQ512,QQ256,QQ134,QQ099 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX- 983, XAX-124} Using MRV we now select any of the variables that had their domain reduced from the previous step. Choose QQ256 = XAX-884. • DQQ056,QQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX- 983, XAX-124} • DQQ108,QQ512,QQ099 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX- 124} • DQQ134 = {XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ134 since it now has the least remaining values. Choose QQ134 = XAX-547. • DQQ056,QQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX- 983, XAX-124} • DQQ108,QQ512 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ099 = {XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ099 since it now has the least remaining values. Choose Q099 = XAX- 344. • DQQ056 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX- 124} • DQQ108 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ512 = {XAX-884, XAX-547, XAX-254, XAX-983, XAX-124} • DQQ254,QQ169 = {XAX-143, XAX-884, XAX-547, XAX-254, XAX-983, XAX-124} We choose QQ512 since it now has the least remaining values. Choose QQ512 = XAX-884. • DQQ056 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX- 124} • DQQ108 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} 9 • DQQ254 = {XAX-143, XAX-884, XAX-547, XAX-254, XAX-983, XAX-124} • DQQ169 = {XAX-143, XAX-547, XAX-254, XAX-983, XAX-124} We choose QQ169 since it now has the least remaining values. Choose QQ169 = XAX-143. • DQQ056 = {XAX-143, XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX- 124} • DQQ108 = {XAX-884, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ254 = {XAX-884, XAX-547, XAX-254, XAX-983, XAX-124} We choose QQ254 since it now has the least remaining values. Choose QQ254 = XAX-884. • DQQ056 = {XAX-143, XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} • DQQ108 = {XAX-547, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ108 since it now has the least remaining values. Choose QQ108 = XAX-547. • DQQ056 = {XAX-143, XAX-344, XAX-254, XAX-983, XAX-124} We choose QQ056 since it now has the least remaining values. Choose Q056 = XAX- 143. The problem is thus solved. QQ144 QQ169 QQ108 QQ256 QQ254 QQ099 QQ512 QQ056 QQ134 10 COS3751/202 Flight Aircraft QQ144 XAX-143 QQ169 XAX-143 QQ108 XAX-547 QQ256 XAX-884 QQ254 XAX-884 QQ099 XAX-344 QQ512 XAX-884 QQ056 XAX-143 QQ134 XAX-547 Question 6 This question was not marked. (6.1) Show that A ⇔ (B ∨ C) |= A. Proceed by ﬁrst converting A ⇔ (B ∨ C) to Conjunctive Normal Form (CNF), and then show that A ⇔ (B ∨ C) |= A using resolution. Unfortunately, there was a mistake in this question. In fact, the entailment does not hold, so it is impossible to prove it by resolution. But why? This is a case of resolution refutation, so we have to determine whether {A ⇔ (B ∨ C), ¬A} is unsatisﬁable. As stated in the question, the ﬁrst step is to convert all the formulas to CNF: 1. Eliminate iff: (A ⇒ (B ∨ C)) ∧ ((B ∨ C) ⇒ A) 2. Eliminate implication: (¬A ∨ B ∨ C) ∧ (¬(B ∨ C) ∨ A) 3. Move ¬ inwards: (¬A ∨ B ∨ C) ∧ ((¬B ∧ ¬C) ∨ A) 4. Distribute over ∧: (¬A ∨ B ∨ C) ∧ (¬B ∨ A) ∧ (¬C ∨ A) ¬A is already in CNF. Next, we number and write down each of the clauses: 1. ¬A ∨ B ∨ C 2. ¬B ∨ A 3. ¬C ∨ A 4. ¬A Now we apply the resolution rule to all pairs of clauses that have a pair of complemen- tary literals, to derive new clauses: 5. ¬B 2, 4 6. ¬C 3, 4 7. ¬A ∨ C 1, 5 8. ¬A 6, 7 11 Since there are no more pairs of clauses that can be resolved, and we haven’t reached □, we conclude that {A ⇔ (B ∨ C), ¬A} is satisﬁable. In other words, A ⇔ (B ∨ C) ̸|= A. But wait a minute, couldn’t we apply the resolution rule to clauses 1 and 2: 9. C 1, 2 and then combine this with clause 6 to reach □? Unfortunately not! The resolution rule only allows us to remove one pair of complementary literals at a time: A ∨ l1 ∨ ... ∨ lm, ¬A ∨ m1 ∨ ... ∨ mn l1 ∨ ... ∨ lm ∨ m1 ∨ ... ∨ mn So 9. B ∨ ¬B ∨ C 1, 2 or 9. ¬A ∨ A ∨ C 1, 2 As explained at the bottom of page 254, B ∨ ¬B ∨ C is equivalent to True ∨ C which can be discarded. The same goes for ¬A ∨ A ∨ C. So it is always a waste of time to apply the resolution rule to clauses that have two pairs of complementary literals. Question 7: 10 Marks Do exercise 8.9 a, c, e and f in the textbook. The translation is straighforward using the vocabulary provided. a. Occupation(Emily, Surgeon) ∨ Occupation(Emily, Lawyer ) This question illustrates the problem that ‘or’ in English usually means ‘one or the other, but not both’. To translate this correctly into FOL, we should write: (Occupation(Emily, Surgeon) ∨ Occupation(Emily, Lawyer )) ∧ ¬(Occupation(Emily, Surgeon) ∧ Occupation(Emily, Lawyer )) c. ∀p (Occupation(p, Surgeon) ⇒ Occupation(p, Doctor )) e. ∃p (Boss(p, Emily ) ∧ Occupation(p, Lawyer )) f. ∃p (Occupation(p, Lawyer ) ∧ ∀q (Customer (q, p) ⇒ Occupation(q, Doctor ))) {0} Copyright c⃝UNISA 2018 (v2018.1.1) 12","libVersion":"0.2.3","langs":""}