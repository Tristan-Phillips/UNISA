{"path":"Subjects/COS3721 - Operating Systems and Architecture/Unsorted/COS3721/Exam pack (2)/materials/15.VirtualMemory.pdf","text":"Virtual Memory and Address Translation 1 Review Program addresses are virtual addresses. Relative offset of program regions can not change during program execution. E.g., heap can not move further from code.gp Virtual addresses == physical address inconvenient. Program location is compiled into the program. A single offset register allows the OS to place a process’ virtual address space anywhere in physical memory. Virtual address space must be smaller than physical. Program is swapped out of old location and swapped into new. Segmentation creates external fragmentation and requires large 2 gg q g regions of contiguous physical memory. We look to fixed sized units, memory pages, to solve the problem. Virtual Memory Concept Key problem: How can one support programs that require more memory than is physically available? How can we support programs that do not use all of their memory at once? 2n-1 Hide physical size of memory from users Memory is a “large” virtual address space of 2n bytes Only portions of VAS are in physical memory at any one time (increase memory utilization). Issues Placement strategies Where to place programs in physical memory Program P’s VAS 3 Replacement strategies What to do when there exist more processes than can fit in memory Load control strategies Determining how many processes can be in memory at one time 0 Realizing Virtual Memory Paging Physical memory partitioned into equal sized page frames Page frames avoid external fragmentation. (fMAX-1,oMAX-1) gg (f,o) o Physical Memory A memory address is a pair (f, o) f — frame number (fmax frames) o — frame offset (omax bytes/frames) Physical address = omax×f + o 4(0,0) PA: fo f 1log2 omaxlog2 (fmax × omax) Physical Address Specifications Frame/Offset pair v. An absolute index Example: A 16-bit address space with (omax =) 512 byte page frames Addressing location (3, 6) = 1,542 (3,6) 1,542 0 19 PA: 16 (3,6) f o Physical Memory 1110 10000000000 36 10 1,542 5 (0,0) f 1,542 0 Questions The offset is the same in a virtual address and a physical address. AT A. True B. False If your level 1 data cache is equal to or smaller than 2number of page offset bits then address translation is not necessary for a data cache tag check. A. True BFalse 6 B. False Realizing Virtual Memory Paging A process’s virtual address space is partitioned into equal sized pages page = page frame 2n-1 = (pMAX-1,oMAX-1) page = page frame (p,o) o Virtual Address Space A virtual address is a pair (p, o) p — page number (pmax pages) o — page offset (omax bytes/pages) Virtual address = omax×p + o 7(0,0)po p VA: 1log2 oMAXlog2 (pmax×omax) Paging Mapping virtual addresses to physical addresses Pages map to frames Pages are contiguous in a VAS... But pages are arbitrarily located ih i l dVirtual in physical memory, and Not all pages mapped at all times Virtual Address Space (p2,o2) Physical Memory (f1,o1) 8 (p1,o1) (f2,o2) Frames and pages Only mapping virtual pages that are in use does what? A. Increases memory utilization. A. Increases memory utilization. B. Increases performance for user applications. C. Allows an OS to run more programs concurrently. D. Gives the OS freedom to move virtual pages in the virtual address space. Address translation is A. Frequent 9 B. Infrequent Changing address mappings is A. Frequent B. Infrequent Paging Virtual address translation A page table maps virtual pages to physical frames (f,o)Program P CPU P’s Virtual Address Space Physical Memory 120 910 po 116 910 fo Virtual Add 10Page Table (p,o) p Physical Addresses Addresses f Virtual Address Translation Details Page table structure Contents: Flags — dirty bit, resident bit, clock/reference bit Frame number 1 table per process Part of process’s state 120 910 po 116 910 fo Virtual CPU 11 1 0 Page Table p Physical Addresses Addresses f0PTBR + Virtual Address Translation Details Example A system with 16-bit addresses 32 KB of physical memory 1024 byte pages (4,1023) (4,0) CPU Physical Memory 15 po 14 910 fo Physical Addresses Virtual Add P’s Virtual Address Space (3,1023) (4,0) 0010 9 12 1 1 0 0 1 0 0 Page Table Addresses 0 0 0 0 0 0 0 (0,0) 1 0 Virtual Address Translation Performance Issues Problem — VM reference requires 2 memory references! One access to get the page table entry One access to get the data Page table can be very large; a part of the page table can be on disk. For a machine with 64-bit addresses and 1024 byte pages, what is the size of a page table? What to do? Most computing problems are solved by some form of… 13 Caching Indirection Virtual Address Translation Using TLBs to Speedup Address Translation Cache recently accessed page-to-frame translations in a TLB For TLB hit, physical page number obtained in 1 cycle For TLB miss, translation is updated in TLB Has high hit ratio (why?) f 120 910 po 116 910 f o Physical Addresses Virtual Addresses CPU Key Value ? 14Page Table TLB f Key Value p p f X Dealing With Large Page Tables Multi-level paging Add additional levels of indirection to the page table by sub-dividing page number into k parts Create a “tree” of page tables TLB still used, just not shown Second-Level Page Tables The architecture determines the number of levels of page table p2 o Virtual Address p3 Page Tables p1 p2 15 Third-Level Page TablesFirst-Level Page Table p1 p3 Dealing With Large Page Tables Multi-level paging Example: Two-level paging CPU Memory 120 1016 p1 o 116 10 fo Physical Addresses Virtual Addresses CPU p2 Memory 16 Second-Level Page Table First-Level Page Table page table p2 f p1 PTBR ++ The Problem of Large Address Spaces With large address spaces (64-bits) forward mapped page tables become cumbersome. E.g. 5 levels of tables.g Instead of making tables proportional to size of virtual address space, make them proportional to the size of physical address space. Virtual address space is growing faster than physical. Use one entry for each physical page with a hash table 17 Use one entry for each physical page with a hash table Size of translation table occupies a very small fraction of physical memory Size of translation table is independent of VM size Virtual Address Translation Using Page Registers (aka Inverted Page Tables) Each frame is associated with a register containing Residence bit: whether or not the frame is occupied Occupier: page number of the page occupying frame Occupier: page number of the page occupying frame Protection bits Page registers: an example Physical memory size: 16 MB Page size: 4096 bytes Number of frames: 4096 Space used for page registers (assuming 8 bytes/register): 32 18 Space used for page registers (assuming 8 bytes/register): 32 Kbytes Percentage overhead introduced by page registers: 0.2% Size of virtual memory: irrelevant Page Registers How does a virtual address become a physical address? CPU generates virtual addresses, where is the physical page? Hh th i t l dd Hash the virtual address Must deal with conflicts TLB caches recent translations, so page lookup can take several steps Hash the address Check the tag of the entry Possibly rehash/traverse list of conflicting entries 19 Possibly rehash/traverse list of conflicting entries TLB is limited in size Difficult to make large and accessible in a single cycle. They consume a lot of power (27% of on-chip for StrongARM) Dealing With Large Inverted Page Tables Using Hash Tables Hash page numbers to find corresponding frame number Page frame number is not explicitly stored (1 frame per entry) Protection, dirty, used, resident bits also in entry 120 9 po 116 9 fo Physical Addresses Virtual Address CPU Hash Memory grunning PID =?=? =?=? tag check 20 h(PID, p) PTBR PID Inverted Page Table 10page 0 fmax–1 fmax–2+ 1 Searching Inverted Page Tables Using Hash Tables Page registers are placed in an array Page i is placed in slot f(i) where f is an agreed-upon hash function To lookup page i, perform the following: Compute f(i) and use it as an index into the table of page registers 21 Extract the corresponding page register Check if the register tag contains i, if so, we have a hit Otherwise, we have a miss Searching the Inverted Page Table Using Hash Tables (Cont’d.) Minor complication Since the number of pages is usually larger than the number of slots in a hash table, two or more items may hash to the same ltilocation Two different entries that map to same location are said to collide Many standard techniques for dealing with collisions Use a linked list of items that hash to a particular table entry Rehash index until the key is found or an empty table entry is 22 Rehash index until the key is found or an empty table entry is reached (open hashing) Questions Why use inverted page tables? A. Forward mapped page tables are too slow. BF d d t bl d ’t l t l i t l B. Forward mapped page tables don’t scale to larger virtual address spaces. C. Inverted pages tables have a simpler lookup algorithm, so the hardware that implements them is simpler. D. Inverted page tables allow a virtual page to be anywhere in physical memory. 23 Virtual Memory (Paging) The bigger picture A process’s VAS is its context Contains its code, data, and stack Code pages are stored in a user’s file on disk Code Data Stack Code pages are stored in a user s file on disk Some are currently residing in memory; most are not Data and stack pages are also stored in a file Although this file is typically not visible to users File only exists while a program is executing OS determines which portions of a process’s VAS di t ti File System (Disk) 24 are mapped in memory at any one time OS/MMU Physical Memory Virtual Memory Page fault handling References to non-mapped pages generate a page fault CPU Physical Memory P CPU Page Table 0 OS resumes/initiates some other process Read of page completes Page fault handling steps: Processor runs the interrupt handler OS blocks the running process OS starts read of the unmapped page 25 Program P’s VAS Disk OS maps the missing page into memory OS restart the faulting process Virtual Memory Performance Page fault handling analysis To understand the overhead of paging, compute the effective memory access time (EAT) EAT = memory access time × probability of a page hit + page fault service time × probability of a page fault Example: Memory access time: 60 ns Disk access time: 25 ms Let p = the probability of a page fault EAT = 60(1–p) + 25,000,000p 26 ( p) ,, p To realize an EAT within 5% of minimum, what is the largest value of p we can tolerate? Vista reading from the pagefile 27 Vista writing to the pagefile 28 Virtual Memory Summary Physical and virtual memory partitioned into equal size units Size of VAS unrelated to size of physical memory Virtual pages are mapped to physical frames Simple placement strategy There is no external fragmentation 29 g Key to good performance is minimizing page faults Segmentation vs. Paging Segmentation has what advantages over paging? A. Fine-grained protection. BE i t t f f t t /f th di k B. Easier to manage transfer of segments to/from the disk. C. Requires less hardware support D. No external fragmentation Paging has what advantages over segmentation? A. Fine-grained protection. B. Easier to manage transfer of pages to/from the disk. C Requires less hardware support 30 C. Requires less hardware support. D. No external fragmentation.","libVersion":"0.2.3","langs":""}