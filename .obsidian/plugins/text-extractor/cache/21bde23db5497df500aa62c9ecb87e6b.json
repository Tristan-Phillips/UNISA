{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Additional Resources/ConcurrencyinQt-Ch17-01.pdf","text":"QThreadand QtConcurrentCOS3711 –Concurrency in Qt–Chapter 17QtQThread•The QThreadclass provides platform-independent threads.•Qtsupports multi-threading and encapsulates threads using QThreadclass.•Most QObjectsare thread safe and re-entrant, and can communicate across threads.•Qtcan only have one GUI thread (QApplication)•Any widgets inherited from QWidgetare not thread safe•QThreadsbegin executing inrun() method. •By default, run() starts the event loop by callingexec() and runs a Qtevent loop inside the thread.QtQThread•What a thread has: Instead of starting inmain()QThreadsbegin executingin run(). By default,run() starts the event loop by callingexecIts own stack pointer, instruction(program counter), processor registers and execution stateIt access to shared resources (shared memory, wait conditions, mutually exclusive data blocks and semaphores) in app’s address spaceQtQThreadExecution ends when you return fromrun() methodBy default,by calling the exec(), run() starts the event loop QtQThread•QThreadwill notify you via a signal when the thread isstarted(),finished(), andterminated(), •UseisFinished() andisRunning() to query the state of the thread,•Usewait() to block until the thread has finished exec.QtQThreadQThread•Another way to make code run in a separate thread, is to subclass QThreadand re-implementrun().•QMutexprovides access serialization between threads. The purpose of QMutexis to protect an object, data structure or section of code so that only one thread can access it at a time (similar to the Javasynchronizedkeyword). It is usually best to use a mutexwith aQMutexLockersince this makes it easy to ensure that locking/unlocking are performed consistently.•QSemaphoreis a generalization of a mutex. While a mutexcan only be locked once, it's possible to acquire a semaphore multiple times. Semaphores are typically used to protect a certain number of identical resources.QtConcurrent•QtConcurrentnamespace provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives.•One important class in this namespace isQThreadPool, a class that manages a pool of threads.•Every Qtapplication has aQThreadPool::globalInstance()with a suggested maximum thread count that defaults, on most systems, to the number of cores.•UsingQtConcurrent'sfunctional map/filter/reduce algorithms, which apply functions in parallel to each item in a container, you can write a program that automatically takes advantage of the system's multiple cores by distributing the processing across the threads managed by the thread pool.","libVersion":"0.2.3","langs":""}