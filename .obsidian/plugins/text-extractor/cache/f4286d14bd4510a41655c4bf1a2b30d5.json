{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/Past Exams/Exam solutions May June 2011.pdf","text":"Exam solutions: May/June 2011 Question one 1.1) Compose objects into tree structures to represent part-whole hierarchies. It is intended to facilitate building complex (composite) objects from simpler (component) parts representing tree-like structures. 1.2) Parents and children can be treated uniformly and operation() on parent (treasure chest) invokes operation() on all its children (lamp and magic mat) and operation() on a child invokes its operation(). 1.3) Leaf classes: lamp and magic mat 1.4) Composite classes: treasure chest 1.5) Client uses Reward, both lamp MagicMat, and TreasureChest inherits from Reward. Aggregation relationship between Reward and TreasureChest 1.6) calculatePoints(); Question two 2.1) Serializer pattern. 2.2) It is designed to input or output the state of an object of some class (whether to and from the console, or to and from the file), since it is not recommended to include this code in the class definition. 2.3) Class1 is used to save and restore, Class1Reader restores the state of Class1 objects , and Class1Writer saves the state of Class1 objects. 2.4) The client program uses an instance of Class1. If it wants to input the state of this instance (from a file or from a console) it declares an instance of Class1Reader and calls its read() member function with the object as argument. If it wants to output this instance of Class1, it declares an instance of Class1Writer and calls its write() method with object as argument. 2.5) Class1Writer uses Class1 data members and writes that information to a file. Class1Reader uses Class1 data members to read information from a file. But Class1Reader nor Class1Writer is allowed to access the data members of Class1 object directly, so these are accessed via the public member functions. 2.6) Design patterns often consist of introducing classes that specify the places where changes need to be made. If we need to reuse the above program, all we need to do is to implement a class (e.g. Class1Writer) that derives from some base class (e.g. Class1). Extensibility is a measure of how easy it is to add enhancements to an application. The serializer pattern provides one of the standard ways of making code extensible by providing a class (Class1) which can easily be sub-classed allowing a developer to add any functionality or data that is needed. 2.7) class EarningsWriter { public: EarningsWriter(); bool write (Earnings &e, QOutputStream &q); }; bool write(Earnings &e, QTextStream &q) { QFile earnFile(\"earningsFile.dat\"); earnFile.open(QIODevice::WriteOnly); q(&earnFile); q << getSalary(); earnFile.close(); return true; } 2.8) #include <QTextStream> QTextStream cout(&earnFile); int main() { Earnings e(\"earnings.dat\"); EarningsWriter e1; e1.write(e, cout); } Question Three 3.1) a) QLineEdit b) QList c) QPushButton 3.2) a) Signals and slots are used for communication between objects. A signal is a special member function declared in a class declaration, it can have a parameter list but no function body and it cannot be called but can be emitted by an instance of the class. A slot is a void member function that can be connected to a signal. A slot can also be called as a normal member function. b) A slot can be connected to a signal, and then when the signal is emitted, the slot is called. c) Yes, they can work across objects of different classes. 3.3) // ClickCounter.h #include <QPushButton> #include <QMessageBox> #include <QGridLayout> #include <QString> class ClickCounter : public QMainWindow { Q_OBJECT public: ClickCounter(); public slots: void clickMe(); private: QPushButton *pb; QString message; }; // ClickCounter.cpp ClickCounter::ClickCounter() { // initializes and places widgets using a layout setWindowTitle(\"ClickCounting\"); QGridLayout* layout = new QGridLayout; // initialize pb pb = new QPushButton(\"click me\"); // align pb centrally this->setCentralWidget(pb); // initialize message message = new QString; //add button to layout layout->addWidget(pb); setLayout(layout); // connect signals and slots connect(pb, SIGNAL(clicked()), this, SLOT(clickMe())); } void ClickCounter::clickMe() { int n = 0; do{ for (int i = 0; i <= n, i++) n += n; message = QMessageBox::information(0, \"Click Information\", \"You are clicking away!\", \"OK\"); }while (n % 5 == 0); return 0; } Question Four 4.1) A film entity in a video store. 4.2) Film f (“The Green Mile”,12.0); 4.3) We do not need a destructor for this class since there are no new objects created that will need to be deleted (destructed). We don’t have any children belonging to any parents that will need to be deleted once parents are destroyed. The default destructor is sufficient for the class given. 4.4) By changing data members of the Film class from protected to private will mean that these data members (i.e. title, dailyRate) will only be accessible to the member functions of the Film class and not to any of the derived classes. 4.5) calculateRental() is a constant function, and therefore cannot be changed or updated. 4.7) class Video : public Film { public: Video(QString vt, int disc); double calculateRental(int num)const; private: QString videoType; int discount; }; 4.8) class Video : public Film { public: Video(QString ti, double dr, QString vt, int disc) : Film(ti, dr), videoType(vt), discount(disc) { } } 4.9) class Video : public Film { public: Video(QString ti, double dr, QString vt, int disc); double calculateRental(int num) const { double results = (Film::calculateRental()) - disc; return results; } } Question Five 5.1) Books academicBooks nonAcademicBooks 5.2) QList to represent a list of institutions. QString to represent the title of the book. 5.3) Books academicBooks nonAcademicBooks QList QString","libVersion":"0.2.3","langs":""}