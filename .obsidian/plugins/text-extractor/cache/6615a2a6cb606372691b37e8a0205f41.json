{"path":"Subjects/COS3721 - Operating Systems and Architecture/Unsorted/COS 3721/Assignments/COS3721_TL_202_2_2018_b-.pdf","text":"COS3721/202/2/2018 Tutorial Letter 202/2/2018 Solutions to assignment no.2 Operating Systems And Architecture COS3721 Semesters 2 School of Computing This tutorial letter contains important information about your module. BARCODE Assignment 2 – Semester 2 Due Date: 27 September 2018 Submission Procedure: Written/Typed. Submission online via myUnisa in a PDF format; Chapters in SGG: Chapters 7 – 11 and 14 – 16 Marking scheme Question 1[14 marks] 1.1.a (8), [1.1.b or 1.1.c](7) and 1.2 (not marked) Question 2[05 marks] 2.1(not marked) and 2.2(5) Question 3[12 marks] 3.1(9) and 3.2(3) Question 4[04 marks] 4.1(4) or 4.2(4) Question 5[08 marks] 5.1(5) and 5.2(3) Question 6[07 marks] 6.1(4) and 6.2(3) Question 1 - Based on Chapter 7 of SGG 1.1 Consider the following snapshot of s system: Answer the following questions using the banker’s algorithm: a. Illustrate that the system is in a safe state by demonstrating an order in which the processes may complete. COS3721/202/2/2018 Answer: 1. Step 1: Work = (3, 3, 2, 1) : resource availableg87iuityddyudu Finish = (f, f, f, f, f): none of the processes is completed. 2. Step 2: We search the array need for the process that needs less resources than those available. Only process P0 needs less resources than those available and can therefore be completed. 3. Step 3: assuming process P0 is completed, the resource allocated to it are released and added to the available resources: Work = Work + (2, 0, 0, 1) = (3, 3, 2, 1) + (2, 0, 0, 1) = (5, 3, 2, 2) Finish = (t, f, f, f, f) 4. Step 2: We search the array need again for the processes that can be completed. P3 is the only process found. 5. Step 3: assuming P3 is completed; the resources allocated to it are released and added to Work. Work = Work + (1, 3, 1, 2) = (5, 3, 2, 2) + (1, 3, 1, 2) = (6, 6, 3, 4) Finish = (t, f, f, t, f) 6. Step 2: Search for the next process(es) that can be completed. P1, P2 and P4 can be completed. We select P1 however, any of the three processes could equally be considered. 7. Step 3: assume P1 is completed then, Work = Work + (3, 1, 2, 1) = (6, 6, 3, 4) + (3, 1, 2, 1) = (9, 7, 5, 5) Finish = (t, t, f, t, f) 8. Step 2: Search for the next process that can be completed. The two remaining processes can each be completed. We first select P2, 9. Step 3: assume p2 is completed, Work = Work + (2, 1, 0, 3) = (9, 7, 5, 5) + (2, 1, 0, 3) = (11, 8, 5, 8) Finish = (t, t, t, t, f) 10. Step 2: the only remaining process is P4 which can be completed. 11. Step 3: When Work = Work + (1, 4, 3, 2) = (11, 8, 5, 8) + (1, 4, 3, 2) = (12, 12, 8, 10) Finish = (t, t, t, t, t) Therefore, a safe sequence is: <P0, P3, P1, P2, P4> b. If a request from process P1 arrives for (1, 1, 0, 0), can the request be granted immediately? Answer: Three steps are required to address this question. (a) Stop if the requested resources are greater than what the process needs, (b) Stop if the requested resources are not available ( the process must wait until the requested resources become available) (c) Assume the requested resources are allocated, update the state of the system accordingly and check (Banker’s algorithm) if the updated state is safe. Application of the above stapes: 1- Compare the requested resources and the need of P1: (1, 1, 0, 0) ≤ (2, 1, 3, 1). 2- Compare the requested resources and the resources available: (1, 1, 0, 0) ≤ (3, 3, 2, 1). 3- If the requested resources were allocated to P1, the new state would be: Allocation Max Need Available A B C D A B C D A B C D A B C D Po 2 0 0 1 4 2 1 2 2 2 1 1 2 2 2 1 P1 4 2 2 1 5 2 5 2 1 0 3 1 P2 2 1 0 3 2 3 1 6 0 2 1 3 P3 1 3 1 2 1 4 2 4 0 1 1 2 P4 1 4 3 2 3 6 6 5 2 2 3 3 To obtain the table, we have done the followings: (d) Re-calculate the allocation of P1 by adding the requested resources to the already allocated resources. (e) Re-calculate the need of P1 by subtracting the requested resources from the existing need. (f) Re-calculate the resource available by subtracting the requested resources. COS3721/202/2/2018 At this stage, we apply the banker’s algorithm, as in (a) to check if the system is in a safe state. 1. Step 1: Work = (2, 2, 2,1) : resource available Finish = (f, f, f, f, f): none of the processes is completed. 2. Step 2: We search the array need for the process that needs less resources than those available. Only process P0 needs less resources than those available and can therefore be completed. 3. Step 3: assuming process P0 is completed, the resource allocated to it are released and added to the available resources: Work = Work + (2, 0, 0, 1) = (2, 2, 2, 1) + (2, 0, 0, 1) = (4, 2, 2, 2) Finish = (t, f, f, f, f) 4. Step 2: We search the array need for the process that needs less resources than those available. P3 can be completed. 5. Step 3: assuming process P3 is completed, the resource allocated to it are released and added to the available resources: Work = Work + (1, 3, 1, 2) = (4, 2, 2, 2) + (1, 3, 1, 2) = (5, 5, 3, 4) Finish = (t, f, f, t, f) 6. Step 2: We search the array need for the process that needs less resources than those available. P1, P2, and P4 can be completed. Note: Since any of these processes can be selected, by considering different options and doing the calculations accordingly, each of the followings safe sequences may be reached: <P0, P3, P1, P2, P4>, <P0, P3, P1, P4, P2>, <P0, P3, P2, P1, P4>, <P0, P3, P2, P4, P1>, <P0, P3, P4, P1, P2>, <P0, P3, P4, P2, P1> Conclusion: the requested resources can be safely granted immediately. c. If a request from process P4 arrives for (0, 0, 2, 0), can the request be granted Immediately? Answer: Please repeat the same steps presented in ( c ) above to check if the request from P4 can be safely granted immediately. 1.2 What is the optimistic assumption made in the deadlock-detection algorithm? How can this assumption be violated? Answer: The optimistic assumption is that there will not be any form of circular wait in terms of resources allocated and processes making requests for them. This assumption could be violated if a circular wait does indeed occur in practice. Question 2 - Based on Chapter 8 of SGG 2.1 Although Android does not support swapping on its boot disk, it is possible to set up a swap space using a separate SD nonvolatile memory card. W hy would Android disallow swapping on its boot disk yet allow it on a secondary disk? Answer (not marked) Primarily because Android does not wish for its boot disk to be used as swap space; the boot disk has limited storage capacity. However, Android does support swapping, it is just that users must provide their own separate SD card for swap space. 2.2 Assuming a 1-KB page size, what are the page numbers and offsets for the following address references (provided as decimal numbers): a. 3085 b. 42095 c. 215201 d. 650000 e. 2000001 Answer: a. page = 1; offset = 391 b. page = 18; offset = 934 c. page = 29; offset = 304 d. page = 0; offset = 256 e. page = 1; offset = 1 COS3721/202/2/2018 Question 3 - Based on Chapter 9 of SGG 3.1 Consider the following page reference string: 7, 2, 3, 1, 2, 5, 3, 4, 6, 7, 7, 1, 0, 5, 4, 6, 2, 3, 0, 1. Assuming demand paging with three frames, how many page faults would occur for the following replacement algorithms? Answer: • LRU replacement 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 Fault y y y y n y y y y y n y y y y y y y y y F1 7 7 7 1 1 1 3 3 3 7 7 7 5 5 5 2 2 2 1 F2 - 2 2 2 2 2 2 4 4 4 1 1 1 4 4 4 3 3 3 F3 - - 3 3 3 5 5 5 6 6 6 0 0 0 6 6 6 0 0 Page fault rate: 18/20 • FIFO replacement 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 Fault y y y y n y n y y y n y y y y y y y y y F1 7 7 7 1 1 1 6 6 6 0 0 0 6 6 6 0 0 F2 - 2 2 2 5 5 5 7 7 7 5 5 5 2 2 2 1 F3 - - 3 3 3 4 4 4 1 1 1 4 4 4 3 3 3 Page fault rate: 17/20 • Optimal replacement 7 2 3 1 2 5 3 4 6 7 7 1 0 5 4 6 2 3 0 1 Fault y y y y n y n y y y n n y n y y y y n n F1 7 7 7 1 1 1 1 1 1 1 1 1 1 F2 - 2 2 2 5 5 5 5 5 4 6 2 3 F3 - - 3 3 3 4 6 7 0 0 0 0 0 Page fault rate: 13/20 3.2 When a page fault occurs, the process requesting the page must block while waiting for the page to be brought from disk into physical memory. Assume that there exists a process with five user-level threads and that the mapping of user threads to kernel threads is one to one. If one user thread incurs a page fault while accessing its stack, would the other user threads belonging to the same process also be affected by the page fault—that is, would they also have to wait for the faulting page to be brought into memory? Explain. Answer: Yes, because there is only one kernel thread for all user threads, that kernel thread blocks while waiting for the page fault to be resolved. Since there are no other kernel threads for available user threads, all other user threads in the process are thus affected by the page fault. Question 4 - Based on Chapter 10 of SGG 4.1 Why is it important to balance file-system I/O among the disks and controllers on a system in a multitasking environment? Answer: A system can perform only at the speed of its slowest bottleneck. Disks or disk controllers are frequently the bottleneck in modern systems as their individual performance cannot keep up with that of the CPU and system bus. By balancing I/O among disks and controllers, neither an individual disk nor a controller is overwhelmed, so that bottleneck is avoided. 4.2 What are the tradeoffs involved in rereading code pages from the file system versus using swap space to store them? Answer: If code pages are stored in swap space, they can be transferred more quickly to main memory (because swap space allocation is tuned for faster performance than general file system allocation). Using swap space can require startup time if the pages are copied there at process invocation rather than just being paged out to swap space on demand. Also, more swap space must be allocated if it is used for both code and data pages. Question 5 - Based on Chapter 11 of SGG 5.1 The open-file table is used to maintain information about files that are currently open. Should the operating system maintain a separate table for each user or maintain just one table that contains references to files that are currently being accessed by all users? If the same file is being accessed by two different programs or users, should there be separate entries in the open-file table? Explain. Answer: By keeping a central open-file table, the operating system can performthe following operation thatwould be infeasible otherwise. Consider a file that is currently being accessed by one ormore processes. If the file is deleted, then it should not be removed fromthe disk until all processes accessing the file have closed it. This check can be performed only if there is centralized accounting of number of processes accessing the file. On the other hand, if two processes are accessing the file, then two separate states need to be maintained to keep track of the current location of which parts of the file are being accessed by the two processes. This requires the operating system to maintain separate entries for the two processes. COS3721/202/2/2018 5.2 Provide examples of applications that typically access files according to the following methods: • Sequential • Random Answer: • Applications that access files sequentially include word processors, music players, video players, and web servers. • Applications that access files randomly include databases, video and audio editors. Question 6 - Based on Chapter 14 of SGG 6.1 What hardware features does a computer system need for efficient capability manipulation? Can these features be used for memory protection? Answer: A hardware feature is needed allowing a capability object to be identified as either a capability of accessible object. Typically, several bits are necessary to distinguish between different types of capability objects. For example, 4 bits could be used to uniquely identify 24 or 16 different types of capability objects. These could not be used for routine memory protection as they offer little else for protection apart from a binary value indicating whether they are a capability object or not. Memory protection requires full support from virtual memory features discussed in Chapter 9. 6.2 Discuss the strengths and weaknesses of implementing an access matrix using access lists that are associated with objects. Answer: Capabilities associated with domains provide substantial flexibility and faster access to objects. When a domain presents a capability, the system just needs to check the authenticity of the capability and that could be performed efficiently. Capabilities could also be passed around from one domain to another domain with great ease, allowing a system with a great amount of flexibility. However, the flexibility comes at the cost of a lack of control: revoking capabilities and restricting the flow of capabilities is a difficult task. 8.8 The examination Please note that your exam will be similar to most of the previous years’ examinations in terms of the structure, format, and level of complexity. You will not be allowed to use the prescribed textbook and a calculator. We tried to cover the syllabus as much as we could. A student who covered the syllabus during the semester, studied all the important concepts and algorithms in the textbook, and did all the assignments should normally be able to pass the coming exam. The theory, design concepts, algorithms and applications are kept to the a similar level of complexity as in the previous exam papers, assignments and exercises in the textbook. 10 SOURCES CONSULTED SILBERSCHATZ A., GALVIN P. & GAGNE G. Operating Systems Concepts, 9th Edition, John Wiley & Sons Inc., 2014.ISBN 978-11180-9375-7. I wish you all the best for the coming exam. COS3721 teaching team ©UNISA 2018","libVersion":"0.2.3","langs":""}