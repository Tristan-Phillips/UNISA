{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/SORT/Prev Sem/COS3711/Drive/COS3711/Exam Papers/2014 May.pdf","text":"2014 May/June Exam Question 01 1.1 The code should have at least two separate classes one to solely display the output and one to hold the data. 1.2 Weighttracker.h #include <QDate> class weighttracker { public: //weighttracker(); void update(QDate d, float w); void setDate(QDate d); void setWeight(float w); QDate getDate(); float getWeight(); private: QDate date; float weight; }; Display.h #include <QDate> #include \"weighttracker.h\" class display { public: display(); void Display(weighttracker* w); }; Weighttracker.cpp void weighttracker::update(QDate d, float w){ date =d; weight =w; } void weighttracker::setDate(QDate d){ date = d; } void weighttracker::setWeight(float w){ weight = w; } QDate weighttracker::getDate(){ return date; } float weighttracker::getWeight(){ return weight; } Display.cpp display::display() { } void display::Display(weighttracker *w){ QTextStream out(stdout); out<< w->getDate().toString()<<\":\"<<w->getWeight()<<\"kg\"<<endl; } Main.cpp int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); QTextStream out(stdout); weighttracker* w= new weighttracker(); w->update(QDate(2012,12,25),74.5); display *d=new display(); d->Display(w); w->update(QDate::currentDate(), 78.9); d->Display(w); out<<endl<<\"End\"<<endl; return a.exec(); } 1.3 #include <QDate> #include <QObject> class weighttracker:public QObject { Q_OBJECT Q_PROPERTY(QDate date READ getDate WRITE setDate) Q_PROPERTY(float weight READ getWeight WRITE setWeight) public: explicit weighttracker(QObject *parent = 0); void update(QDate d, float w); void setDate(QDate d); void setWeight(float w); QDate getDate(); float getWeight(); private: QDate date; float weight; }; 1.4 Dynamic void display::displayProperties(weighttracker *w){ QString result; QString prop = w->getDate().toString(); QString val = QString::number( w->getWeight()); w->setProperty(prop.toLatin1(), val); foreach(QByteArray propname,w->dynamicPropertyNames()){ QString name = QString::fromLocal8Bit(propname); QString value = w->property(propname).toString(); result += QString(name + \": \" + value + \"; \"); qDebug()<<result; } } Fixed void display::displayproperties(weighttracker* w){ const QMetaObject* meta = w->metaObject(); QString result; for (int count=1; count<meta->propertyCount(); count++) { const QMetaProperty prop = meta->property(count); QString name = prop.name(); QVariant value = prop.read(w); QString val = value.toString(); result += QString(name + \": \" + val + \"; \"); qDebug()<<result; } } 1.5 A dynamic property is a property that is assigned at run time to a QObject and it makes use of the set property function. Whereas the fixed properties we have been using make use of the QPRORPERTY () macro to assign properties accessible through the QMetaObject system. 1.6 w->setProperty(“comment”, “improving”); Question 02 2.1) 13. Tableview->setModel(model); 14. tableview->setSortingEnabled(true); 20. QStandardItem *moduleItem = new QStandardItem(module); 21. QStandardItem *markItem= new QStandardItem(mark); 23. row << moduleItem<< markItem; 24. model->appendRow(row); 2.2) QTreeView 2.3) The purpose of the setItemDelegate is that it sets the delegate for the colmn view and model thus giving complete control of the editing and display of items in the column. 2.4) The major benefit of using is that the framework is reusable. Question 03 3.1 The character string that will be accepted by the given regexp is an character string that starts with a single letter of the alphabet and is followed by 1 or more digits. 3.2 The digit following the letter of the alphabet will then be either 0 or more. 3.3 “^[a-zA-Z0-9_]{5,7}[a-z0-9]{1,1}$” Question 04 4.1 The statement declares s and assigns a pointer of type shape implying that the new shape is derived from the class shape, which is inaccurate. 4.2 The second statement is also inaccurate as circle is derived from Shape not Shape2, thus the statement should be Shape* s = new Circle(); 4.3 #include <QString> #include “Shape.h” class shapeFactory{ public: Shape* getShape(QString shape) const; }; #include “shapeFactory.h” #include “Circle.h” #include “Square.h” #include “Ellipse.h” #include “Retangle.h” Shape* shapeFactory::getShape(QString shape){ If (shape == “Circle”) return new Circle(); else if (shape == “Square”) return new Square(); else if (shape == “Ellipse”) return new Ellipse(); else if (shape == “rectangle”) return new Rectangle(); else return NULL; } 4.4 shape *myShape;//datamember of client class AbstractShapeFactory * factory = new shapeFactory(); myShape = factory->getShape( “Circle”); myShape = factory ->getShape( “Square”); … 4.5 The purpose of the factory method is to provide a common interface for creating related objects, where the responsibility of creating these objects is transferred to a separate factory method. 4.6 Abstract factory pattern 4.7 class for keeping a list of shapes such that the rollback function of the memento pattern may be possible. 4.8 5.1 <exam> <code>cos3711</code> <marks> 100 </marks> </exam> 5.2 Counter*c; QThread*t; If (c≠0) t->startCounting(); 5.3 5.4.1 QUdpSocket class can be used when reliability is not important, 5.4.2 the writeDatagram() function is used to send the datagram to the host address and returns a number of bytes sent on success. 5.4.3 readyRead()function is a signal emitted once everytime new data is available for reading from the device. 5.4.4 QT += network Shape Memento Circle Square Ellipse Rectangle","libVersion":"0.2.3","langs":""}