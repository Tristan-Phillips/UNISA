{"path":"Subjects/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/some slides/Chapter3-searching-uninformed.pdf","text":"1 Solving Problems by Searching (Blindly) R&N h 1 R&N: Chap. 3 (many of these slides borrowed from Stanford’s AI Class) Problem Solving Agents • Decide what to do by finding a sequence of actions that lead to desirable states. Example: Romania • On holiday in Romania; currently in Arad. • Flight leaves tomorrow from Bucharest 2 Problem Solving Agent • Formulate goal: – be in Bucharest (in time for flight the next day) – Goal formulation is the decision of what you are going to search for - helps us simplify our methods for finding a solutionmethods for finding a solution • Formulate problem: decide what actions, states to consider given a goal – states: map with agent in a particular city (location) – actions: drive between cities (if there is a road)3 Finding a solution… • Take a road from where I am and see if it takes me to Bucharest… • Three roads leave Arad, but none go to BucharestBucharest… 4 Example: Romania 5 Single-state problem formulation A problem is defined by three (four) items: 1. initial state e.g., \"at Arad\" 2. actions or successor function S(x) = set of precondition- action pairs where the action returns a state – e.g., S(at Arad) = {<at Arad  (at Zerind>, … } 3 goal test can be 6 3. goal test, can be – explicit, e.g., x = \"at Bucharest\" – implicit, e.g., Checkmate(x) 4. path cost (additive) – e.g., sum of distances, number of actions executed, etc. – c(x,a,y) is the step cost, assumed to be ≥ 0 •A solution is a sequence of actions leading from the initial state to a goal state 2 State Space  Each state is an abstract representation of a collection of possible worlds sharing some crucial properties and differing on non-important details only E.g.: In assembly planning, a state does not define exactly the absolute position of each part 7 define exactly the absolute position of each part  The state space is discrete. It may be finite, or infinite and is implicit in the problem formulation. Successor Function  It implicitly represents all the actions that are feasible in each state 8 Successor Function  It implicitly represents all the actions that are feasible in each state  Only the results of the actions (the successor states) and their costs are 9 returned by the function  The successor function is a “black box”: its content is unknown E.g., in assembly planning, the function does not say if it only allows two sub-assemblies to be merged or if it makes assumptions about subassembly stability Path Cost  An arc cost is a positive number measuring the “cost” of performing the action corresponding to the arc, e.g.: • 1 in the 8-puzzle example 10 • expected time to merge two sub-assemblies  We will assume that for any given problem the cost c of an arc always verifies: c ≥ ε  0, where ε is a constant [This condition guarantees that, if path becomes arbitrarily long, its cost also becomes arbitrarily large]  It may be explicitly described:  or partially described: Goal State 12 3 456 78 1 5 8 aa aa aa (“a” stands for “any”) 11  or defined by a condition, e.g., the sum of every row, of every column, and of every diagonals equals 30 11 14 5 13 6 3 8 4 10 9 7 122115 8 aa (y ) Example: Romania • On holiday in Romania; currently in Arad. • Flight leaves tomorrow from Bucharest • Formulate goal: – be in Bucharest 12 • Formulate problem: – states: being in various cities – initial state: being in Arad – actions: drive between cities • Find solution: – sequence of cities, e.g., Arad, Sibiu, Fagaras, Bucharest 3 Example: Romania 13 Vacuum world state space graph 14 • states? • Initial state? • actions? • goal test? • path cost? Vacuum world state space graph 15 • states? integer dirt and robot location • Initial state? Dirt in both locations and the vacuum cleaner in one of them • actions? Left, Right, Suck • goal test? no dirt at all locations • path cost? 1 per action Example: The 8-puzzle 16 • states? • Initial state? • actions? • goal test? • path cost? Example: The 8-puzzle 17 • states? locations of tiles • Initial state? puzzle in the configuration above • actions? move blank left, right, up, down • goal test? = goal state (given) • path cost? 1 per move [Note: optimal solution of n-Puzzle family is NP-hard] GO TO SLIDES • DO WATERJUG PROBLEM • Problem Formulation; Search algorithms 18 4 Assumptions in Basic Search  The world is static  The world is discretizable  The world is observable 19  The actions are deterministic But many of these assumptions can be removed, and search still remains an important problem-solving tool Searching the state • So far we have talked about how a problem can be looked at so as to form search problems. • How do we actually do the search? 20 • How do we actually do the search? • (Do search-algorithm slides…) Simple Problem-Solving-Agent Agent Algorithm 1. s0  sense/read state 2 GOAL?  select/read goal test 21 2. GOAL?  select/read goal test 3. SUCCESSORS  read successor function 4. solution  search(s0, G, Succ) 5. perform(solution) Searching the State Space 22 Search tree Note that some states are visited multiple times Basic Search Concepts  Search tree  Search node  Node expansion 23  Fringe of search tree  Search strategy: At each stage it determines which node to expand Search Nodes  States 1 2 34 56 7 8 24 1 2 34 56 7 8 1 2 34 56 78 1 3 56 8 1 3 4 56 7 82 47 2 1 2 34 56 7 8 5 Search Nodes  States 1 2 34 56 7 8 25 1 2 34 56 7 8 1 2 34 56 78 1 3 56 8 1 3 4 56 7 82 47 2 1 2 34 56 7 8 If states are allowed to be revisited, the search tree may be infinite even when the state space is finite If states are allowed to be revisited, the search tree may be infinite even when the state space is finite Data Structure of a Node PARENT-NODE (recall Ariadne thread) 1 2 34 56 7 8 STATE BOOKKEEPING CHILDREN 26 Depth of a node N = length of path from root to N (Depth of the root = 0) 5Path-Cost 5Depth RightAction Expanded yes... CHILDREN Node expansion The expansion of a node N of the search tree consists of: 1) Evaluating the successor function on STATE(N) 27 STATE(N) 2) Generating a child of N for each state returned by the function Fringe and Search Strategy  The fringe is the set of all search nodes that haven’t been expanded yet 28 Is it identical to the set of 28 1 34 56 7 1 2 34 56 7 8 1 2 34 56 78 1 3 56 8 1 3 4 56 7 82 47 2 1 2 34 5 6 7 8 to the set of leaves? Fringe and Search Strategy  The fringe is the set of all search nodes that haven’t been expanded yet  It is implemented as a priority queue FRINGE 29 FRINGE • INSERT(node,FRINGE) • REMOVE(FRINGE)  The ordering of the nodes in FRINGE defines the search strategy Search Algorithm 1. If GOAL?(initial-state) then return initial-state 2. INSERT(initial-node,FRINGE) 3. Repeat: a. If empty(FRINGE) then return failure b n  REMOVE(FRINGE) 30 b. n  REMOVE(FRINGE) c. s  STATE(n) d. If GOAL?(s’) then return path or goal state e. For every state s’ in SUCCESSORS(s) i. Create a new node n’ as a child of n ii. INSERT(n’,FRINGE) 6 Performance Measures  Completeness A search algorithm is complete if it finds a solution whenever one exists [What about the case when no solution exists?]  Optimality 31  Optimality A search algorithm is optimal if it returns a minimum-cost path whenever a solution exists [Other optimality measures are possible]  Complexity It measures the time and amount of memory required by the algorithm Important Parameters 1) Maximum number of successors of any state  branching factor b of the search tree 32 2) Minimal length of a path between the initial and a goal state  depth d of the shallowest goal node in the search tree Important Remark  Some search problems, such as the (n2-1)- puzzle, are NP-hard  One can’t expect to solve all instances of such problems in less than exponential 33 such problems in less than exponential time  One may still strive to solve each instance as efficiently as possible Blind Strategies  Breadth-first • Bidirectional  Depth-first Arc cost = 1 34 Depth first • Depth-limited • Iterative deepening  Uniform-Cost (variant of breadth-first) Arc cost = c(action) 0 Breadth-First Strategy New nodes are inserted at the end of FRINGE 1 35 23 45 6 7 FRINGE = (1) Breadth-First Strategy New nodes are inserted at the end of FRINGE 1 36 FRINGE = (2, 3)23 45 6 7 7 Breadth-First Strategy New nodes are inserted at the end of FRINGE 1 37 FRINGE = (3, 4, 5)23 45 6 7 Breadth-First Strategy New nodes are inserted at the end of FRINGE 1 38 FRINGE = (4, 5, 6, 7)23 45 6 7 Evaluation  b: branching factor  d: depth of shallowest goal node  Breadth-first search is: Complete 39 • Complete • Optimal if step cost is 1  Number of nodes generated: 1 + b + b2 + … + bd = (bd+1-1)/(b-1) = O(bd)   Time and space complexity is O(bd) Big O Notation g(n) = O(f(n)) if there exist two positive constants a and N such that: f ll N ( )  f( ) 40 for all n > N: g(n)  af(n) Time and Memory Requirements d # Nodes Time Memory 2 111 .01 msec 11 Kbytes 4 11,111 1 msec 1 Mbyte 6 106 1 s 100 Mb 41 6 ~106 1 sec 100 Mb 8 ~108 100 sec 10 Gbytes 10 ~1010 2.8 hours 1 Tbyte 12 ~1012 11.6 days 100 Tbytes 14 ~1014 3.2 years 10,000 Tbytes Assumptions: b = 10; 1,000,000 nodes/sec; 100bytes/node Time and Memory Requirements d # Nodes Time Memory 2 111 .01 msec 11 Kbytes 4 11,111 1 msec 1 Mbyte 6 106 1 s 100 Mb 42 6 ~106 1 sec 100 Mb 8 ~108 100 sec 10 Gbytes 10 ~1010 2.8 hours 1 Tbyte 12 ~1012 11.6 days 100 Tbytes 14 ~1014 3.2 years 10,000 Tbytes Assumptions: b = 10; 1,000,000 nodes/sec; 100bytes/node 8 Remark If a problem has no solution, breadth-first may run for ever (if the state space is infinite or states can be revisited arbitrary many times) 43214321 43 12 14 11 15 10 13 9 5 6 7 8 4321 12 15 11 14 10 13 9 5 6 7 8 4321 ? Bidirectional Strategy 2 fringe queues: FRINGE1 and FRINGE2 s 44 Time and space complexity is O(bd/2)  O(bd) if both trees have the same branching factor b Question: What happens if the branching factor is different in each direction? Bidirectional Search • Search forward from the start state and backward from the goal state simultaneously and stop when the two searches meet in the middle 45 searches meet in the middle. • If branching factor=b, and solution at depth d, then O(2bd/2) steps. • B=10, d=6 then BFS needs 1,111,111 nodes and bidirectional needs only 2,222. Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 46 2 3 45 FRINGE = (1) Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 47 2 3 45 FRINGE = (2, 3) Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 48 2 3 45 FRINGE = (4, 5, 3) 9 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 49 2 3 45 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 50 2 3 45 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 51 2 3 45 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 52 2 3 45 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 53 2 3 45 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 54 2 3 45 10 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 55 2 3 45 Depth-First Strategy New nodes are inserted at the front of FRINGE 1 2 3 56 2 3 45 Evaluation  b: branching factor  d: depth of shallowest goal node  m: maximal depth of a leaf node  Depth-first search is:  Complete only for finite search tree 57  Complete only for finite search tree  Not optimal  Number of nodes generated: 1 + b + b2 + … + bm = O(bm)  Time complexity is O(bm)  Space complexity is O(bm) [or O(m)] [Reminder: Breadth-first requires O(bd) time and space] Depth-Limited Search  Depth-first with depth cutoff k (depth below which nodes are not expanded) Th bl 58  Three possible outcomes: • Solution • Failure (no solution) • Cutoff (no solution within cutoff) Iterative Deepening Search Provides the best of both breadth-first and depth-first search Main idea: Totally horrifying ! 59 IDS For k = 0, 1, 2, … do: Perform depth-first search with depth cutoff k Iterative Deepening 60 11 Iterative Deepening 61 Iterative Deepening 62 Iterative deepening search 63 Iterative deepening search l =0 64 Iterative deepening search l =1 65 Iterative deepening search l =2 66 12 Iterative deepening search l =3 67 Iterative deepening search • Number of nodes generated in a depth-limited search to depth d with branching factor b: NDLS = b0 + b1 + b2 + … + bd-2 + bd-1 + bd • Number of nodes generated in an iterative deepening search to depth d with branching factor b: 68 search to depth d with branching factor b: NIDS = (d+1)b0 + d b^1 + (d-1)b^2 + … + 3bd-2 +2bd-1 + 1bd •For b = 10, d = 5, –NDLS = 1 + 10 + 100 + 1,000 + 10,000 + 100,000 = 111,111 –NIDS = 6 + 50 + 400 + 3,000 + 20,000 + 100,000 = 123,456 • Overhead = (123,456 - 111,111)/111,111 = 11% Properties of iterative deepening search Complete? Yes Time? (d+1)b0 + d b1 + (d-1)b2 + … + bd = O(bd) 69 O(bd) Space? O(bd) Optimal? Yes, if step cost = 1 Performance  Iterative deepening search is: • Complete • Optimal if step cost =1 70  Time complexity is: (d+1)(1) + db + (d-1)b2 + … + (1) bd = O(bd)  Space complexity is: O(bd) or O(d) Calculation db + (d-1)b2 + … + (1) bd =bd +2bd-1 +3bd-2 +… + db = (1 + 2b-1 + 3b-2 + … + db-d)bd ( ) 71  (i=1,…, ib(1-i))bd = bd (b/(b-1))2 d = 5 and b = 2 BF ID 11 x 6 = 6 Number of Generated Nodes (Breadth-First & Iterative Deepening) 72 22 x 5 = 10 44 x 4 = 16 88 x 3 = 24 16 16 x 2 = 32 32 32 x 1 = 32 63 120 120/63 ~ 2 13 Number of Generated Nodes (Breadth-First & Iterative Deepening) d = 5 and b = 10 BF ID 16 73 10 50 100 400 1,000 3,000 10,000 20,000 100,000 100,000 111,111 123,456 123,456/111,111 ~ 1.111 Comparison of Strategies  Breadth-first is complete and optimal, but has high space complexity  Depth-first is space efficient, but is neither complete nor optimal 74 neither complete, nor optimal  Iterative deepening is complete and optimal, with the same space complexity as depth-first and almost the same time complexity as breadth-first Summary of algorithms 75 Avoiding Revisited States  Let’s not worry about it yet… but generally we will have to be careful to avoid states we have already seen… 76 Uniform-Cost Search  Each arc has some cost c  > 0  The cost of the path to each fringe node N is g(N) =  costs of arcs  The goal is to generate a solution path of minimal cost  The queue FRINGE is sorted in increasing cost 77 Need to modify search algorithm S 0 1 A 5 B 15 C SG A B C 5 1 15 10 5 5 G 11 G10","libVersion":"0.2.3","langs":""}