{"path":"UNISA/98906 - BSc Science in Computing/COS3721 - Operating Systems and Architecture/Unsorted/COS3721/Exam pack (2)/Past Exams/Cos3721_October November 2017 MEMO .pdf","text":"COS3721 October November 2017 Operating Systems and Architecture SOLUTIONS 1.1.1 explain what is meant by layered approach The layered operating system is an operating system that groups related functionality together, and separates it from the unrelated. It was developed in the early 1960s and was expected to lead to a cleaner design and more clearly defined interaction between the layers. 1.1.2 What is the main advantage of the layered approach to system design? What are the disadvantages of using the layered approach? Answer: As in all cases of modular design, designing an operating system in a modular way has several advantages. The system is easier to debug and modify because changes affect only limited sections of the system rather than touching all sections of the operating system. Information is kept only where it is needed and is accessible only within a defined and restricted area, so any bugs affecting that data must be limited to a specific module or layer. 1.1.3 It is sometimes difficult to achieve a layered approach if two components of the operating system are dependent on each other .identify a scenario in which is unclear how layer two system components that require tight coupling of their functionalities The virtual memory subsystem and the storage subsystem are typically tightly coupled and requires careful design in a layered system due to the following interactions. Many systems allow files to be mapped into the virtual memory space of an executing process. On the other hand, the virtual memory subsystem typically uses the storage system to provide the backing store for pages that do not currently reside in memory. Also, updates to the file system are sometimes buffered in physical memory before it is flushed to disk, thereby requiring careful coordination of the usage of memory between the virtual memory subsystem and the file system. 1.1.3 State the order of the layers for the following parts of a layered operating system .assume that the hardware is at the lowest level and the user is at the highest level (a) Paged memory management (b) CPU scheduling (c) I/O drivers (d) Java Compiler (e) Command line interpreter Answer: There are two possible orderings and we indicate these as follows (we assume the user is at the highest level, namely, 6 and the hardware is at the lowest level, namely, 0): Justification of Ordering 1: The User interacts directly with the system by issuing commands. These commands are interpreted by the Command line interpreter. The command interpreter responds to these commands by invoking for instance the Java Compiler. The compiler relies on the Paged memory manager to page the user program into memory for subsequent compilation. The paging system relies on the I/O drivers to swap these pages in and out of memory. The I/O drivers rely on the CPU schedulers to obtain access to the CPU. The CPU interacts with the hardware (registers, etc.). Ordering 2 above can be justified in the same vein. Level # Ordering 1 Ordering 2 4 Command line interpreter Command line interpreter 3 Java compiler Java compiler 2 Paged memory management I/O drivers 1 I/O drivers Paged memory management 0 CPU scheduling CPU scheduling 1.2 direct memory access is used for high speed IO devices in order to avoid increasing the CPU execution load 1.2.1 how does the cpu interface with the device to coordinate the transfer 1.2.2 Answer: . To initiate a DMA transfer, the CPU first sets up the DMA registers, which contain a pointer to the source of a transfer, a pointer to the destination of the transfer, and a counter of the number of bytes to be transferred. Then the DMA controller proceeds to place addresses on the bus to perform transfers, while the CPU is available to accomplish other work 1.2.3 how does the cup know when the memory operations are complete Once the entire transfer is finished, the DMA controller interrupts the CPU. The cpu is allowed to execute other programs while the DMA controller is transferring 1.2.3 .Describe any forms of interference that this process may cause with the execution of the user programs Both the CPU and the DMA controller are bus masters. A problem would be created if both the CPU and the DMA controller want to access the memory at the same time. Accordingly, the CPU should be momentarily prevented from accessing main memory when the DMA controller seizes the memory bus. However, if the CPU is still allowed to access data in its primary and secondary caches, a coherency issue may be created if both the CPU and the DMA controller update the same memory locations 1.3 what is the purpose of interrupts interrupt is a hardware generated change of flow within the system. Aninterrupt handler issummonedtodealwith the cause of the interrupt; control is then returned to the interrupted context and instruction.Atrapis a software- generated interrupt. An interrupt can be used to signal thecompletion of an I/O to obviate the need for device polling 1.4 describe two general methods used to pass parameters to the operating system during system calls Ans: The simplest approach is to pass the parameters in registers. In some cases, there may be more parameters than registers. In these cases, the parameters are generally stored in a block, or table, of memory, and the address of the block is passed as a parameter in a register. Parameters can also be placed, or pushed, onto the stack by the program and popped off the stack by the operating system. 1.5 how do clustered systems differ from multi-processor systems Answer: Clustered systems are typically constructed by combining multiple computers into a single system to perform a computational task distributed across the cluster. Multiprocessor systems on the other hand could be a single physical entity comprising of multiple CPUs. A clustered system is less tightly coupled than a multiprocessor system. Clustered systems communicate using messages, while processors in a multiprocessor system could communicate using shared memory. e consistently updated. When one of the machines fail, the other could then take-over the functionality of the failed machine. 1.6 what is required for two machines belonging to a cluster to cooperate to provide a highly available service In order for two machines to provide a highly available service, the state on the two machines should be replicated and should be consistently updated. When one of the machines fail, the other could then take-over the functionality of the failed machine 2.1 Explain the difference between demand paging system and a paging system with swapping Demand paging system is quite similar to a paging system with swapping. Paging is dividing the logic memory into equal-sized blocks that are capable of storing the same amount of data these blocks are called pages. In demand-paging the page is loaded in the memory only when it is needed and required by the process to execute the program. On the other hand, the paging with swapping is to access data being stores in the hard disk and to bring it into the RAM so that it can be used by the application program. Swapping is only necessary when the data is not already in RAM. Before the demand-paging and paging with swapping could be working simultaneously in order to ensure proper execution of the program. 2.2 explain the sequence of events that happens when a page fault occurs Ans: When the operating system cannot load the desired page into memory, a page-fault occurs. First, the memory reference is checked for validity. In the case of an invalid request, the program will be terminated. If the request was valid, a free frame is located. A disk operation is then scheduled to read the page into the frame just found, update the page table, restart the instruction that was interrupted because of the page fault, and use the page accordingly 2.3 A certain computer provides its users with a virtual-memory space of 232 bytes. The computer has 218 bytes of physical memory. The virtual memory is implemented by paging, and the page size is 4096 bytes. A user process generates the virtual address 11123456. Explain how the system establishes the corresponding physical location. Distinguish Between software and hardware operations. Answer: The virtual address in binary form is 0001 0001 0001 0010 0011 0100 0101 0110 Since the page size is 2^12, the page table size is 2^20. Therefore the low Order 12 bits 0100 0101 0110 are used as the displacement into the page, While the remaining 20 bits 0001 0001 0001 0010 0011 are used as the Displacement in the page table. The offset bits are then Concatenated to the resulting physical page number (from the page table), to form the final address. 2.4 consider the reduced page reference string 2, 1, 7 ,5 ,.1, 7 , 0, 2 , 6 assuming demand paging with three frames, how many page faults would occur for the following replacement algorithms LRU replacement FIFO replacement Optimal replacement Number of frames FIFO replacement LRU replacement Optimal replacement 1 2 3 3.1 Consider a system consisting of four resources of the same type that are shared by three processes each of which needs at most two resources .show that the system is deadlock free Yes, this system is deadlock-free. Proof by contradiction. Suppose the system is deadlocked. This implies that each process is holding one resource and is waiting for one more. Since there are three processes and four resources, one process must be able to obtain two resources. This process requires no more resources and, therefore it will return its resources when done. 3.2 consider the four process in table 1 .each process arrives at the ready queue at the time indicated .the required burst time is given in milliseconds .the priority for each process is provided for when necessary processs Arrival time Burst time Priority P1 0 8 3 P2 1 4 1 P3 2 9 4 P4 3 5 5 3.2.1 Draw two Gantt charts one for the SJF with pre-emption and the other for priority scheduling without pre-emption 3.2.2 Calculate the turnaround time and waiting time for each process under each of the scheduling algorithms in 3.21 above show all your working Answer: The concepts of Turnaround time and waiting time are explained in SGG, 8th edition, on page 187. Practical formulae, generated from the explanation given in the textbook were included in the tutorial letter 102 available for download on the myUnisa website. Those formulas are: Turnaround time = Time of completion - Time of submission ∑ Waiting time = Turnaround time − ∑ CPU burst time Applying these formulae yields the following results, presented in a tabular form: 4 consider the following snapshot of a system Allocation Max Available ABCD ABCD ABCD P0 2001 4212 3321 P1 3121 5252 P2 2103 2316 P3 1312 1424 P4 1432 3665 4.1 illustrate that the system is in safe state by demonstrating an order in which the processes may complete . The system is in a safe state? Yes. With Available being equal to (3,1,2, 1), either process P0 or P3 could run. Once process P3 runs, it releases its resources, which allow all other existing processes to run 4.2 if a request from process p4 arrives for (0,0,2,0) can the request be granted immediately? Show your working Answer: (1) We need to check if the requested resources are less or equal to the need of the process. (2) We compare the requested resources with the need of P4: (0, 0, 2, 0) vs (2, 2, 3, 3) 0≤ 2 ∧ 0 ≤ 2 ∧ 2 ≤ 2 ∧ 0 ≤ 3 √ (2) We need to ensure that the requested resources are available. (0, 0, 2, 0) vs (3, 3, 2, 1) 0 ≤ 3 ∧ 0 ≤ 3 ∧ 2 ≤ 2 ∧ 0 ≤ 1√ (3) We need to ensure that the requested resources are available. We now allocate the requested resources to P0 and apply the Banker’s Safety Algorithm to check if the system remains safe. New allocation: Allocation0 = (1, 4, 3, 2) + (0, 0, 2, 0) = (1,4 ,5 ,2) New need: Need0 = (2, 2 ,3 ,3) – (0,0,2,0) = (2,2,1,3) Resources available: (3,3,2 ,1) - (0,0,2,0) = (3,3,0,1) Allocation Max Need Available ABCD ABCD ABCD ABCD P0 2001 4212 2211 2213 P1 3121 5252 2131 P2 2103 2316 213 P3 1312 1424 112 P4 1452 3665 2213 Step 1: Available = (2, 2, 1 ,3) Finish = (f, f, f, f) Step 2: search the need vector for any process that needs fewer resources than those available. Check if the need <= available P0 . 2211 <= 2213 true Work = work + allocation 2213 + 2001 = 4214 P1. 2131 <= 4214 true 4214 + 3121 = 7335 P2 . 213 < = 7 335 true And so on …….. So the system is in safe state with the sequence p0,p1,p2,p3,p4","libVersion":"0.2.3","langs":""}