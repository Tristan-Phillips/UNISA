{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Assignments/COS3711-2015_semester_1_assignment_2_sample_solutions/COS3711_2015_1_202.pdf","text":"COS3711/202/1/2015 Tutorial letter 202/1/2015 Advanced Programming COS3711 Semester 1 School of Computing Discussion of solutions to Assignment 2 2 CONTENTS Page 1 INTRODUCTION .......................................................................................................................... 3 2 TUTORIAL MATTER .................................................................................................................... 3 3 MARKING OF ASSIGNMENT 2 ................................................................................................... 3 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 2 ................................................................... 3 4.1 Question 1 .................................................................................................................................... 3 4.2 Question 2 .................................................................................................................................... 4 4.3 Question 3 .................................................................................................................................... 6 4.4 Question 4 .................................................................................................................................... 6 4.5 Question 5 .................................................................................................................................... 7 4.6 Question 6 .................................................................................................................................... 8 4.7 Question 7 .................................................................................................................................... 9 4.8 Question 8 .................................................................................................................................... 9 4.9 Question 9 .................................................................................................................................. 10 5 MARKING RUBRIC .................................................................................................................... 11 Please note / important notes: Afrikaanse studente: Die studiemateriaal vir hierdie module is slegs in Engels beskikbaar. As daar enigiets onduidelik is daarin is u welkom om die dosente vir COS3711 te kontak. COS3711/202 3 1 INTRODUCTION In order to reduce the turnaround time of the printing and to reduce the usage of paper, this discussion, and the solutions, are made available electronically. The solution to assignment 2 is placed under Additional Resources of COS3711 on myUnisa. A separate folder is created for each question, in which you will find all the relevant files for its solution. Please note that the solutions provided on myUnisa are only suggested solutions and they are not the best or only solutions. This tutorial letter contains a short discussion of the solution to Assignment 2 of COS3711 made available on myUnisa. Hence, this tutorial letter should be used in conjunction with the solutions uploaded on myUnisa. The marking rubric used for marking of Assignment 2 is also included in this tutorial letter. It is impossible to follow a marking rubric strictly for a programming assignment. Hence the given marking rubric should be used only as a rough guideline. 2 TUTORIAL MATTER The following are important documents that you need to consult. Please download them from myUnisa if you do not already have them. COS3711/101/2015 First tutorial letter COS3711/MO001/2015 The contents of the myUnisa site for COS3711 COS3711/102/2015 Practical study guide COS3711/103/2015 Networking and the Web – Additional notes COS3711/201/2015 Discussion of solutions to Assignment 1 3 MARKING OF ASSIGNMENT 2 Assignments that contained solutions copied from another student’s assignment are penalized heavily. 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 2 4.1 Question 1 The aim of this question is to implement a set of classes based on an initial design given in a UML class diagram and to make these classes work together to satisfy the given requirements. The question does not spell out each and every implementation detail, as at this level of study you are expected to design the solution on your own to a large extent. The given solution uses seven classes. The details of these classes are given below: • Asset, Saving, Bond and Stock follow the specifications in the question. These four classes inherit from QObject and include the Q_OBJECT macro so that we can obtain their class names via QMetaObject. We have also added copy constructors in these classes. The copy constructors are not used in this question but they are used in questions 3 and 4. • Apart from the functions given in the UML class diagram of AssetList, two more functions are implemented. A private findAsset() function to check whether an Asset is already in 4 its data member assetList. findAsset() is invoked in addAsset() to ensure that no two assets with the same description are included in assetList. The static public function getType()accepts an Asset* and returns the type of the object pointed to by the Asset pointer. getType() uses QMetaObject to access the type of an asset. getType() is invoked in the toString() function of AssetList. • AssetHandler is a class that coordinates the interaction between the GUI class (MainWindow) and the data classes. AssetHandler has a data member of type AssetList. When the GUI class requests AssetHandler to perform certain tasks like add an asset to the list, get the string equivalent of asset list and get the value of assets, it simply delegates the task to its data member assetlist. • MainWindow is the GUI class, which manages various input and output widgets on the user interface. It has an instance of AssetHandler, which it delegates the task of creating assets and maintaining a list of assets. To get the application to run, all that is required is that an instance of the GUI, MainWindow, be created in main(), and its window shown. Shown below is a sample output generated by the application: 4.2 Question 2 The aim of this question is to use QXmlStreamWriter to generate XML. To satisfy the requirements of this question, the solution in question 1 is extended to include the AssetListWriter class. AssetListWriter converts an AssetList into an XML format and writes it to a given file. It uses the string returned by toString() of AssetList to generate the XML format of an asset list. Note that the code in writeToFile() only works for the string format returned by toString() of AssetList in the given implementation. COS3711/202 5 AssetHandler has a data member of type AssetListWriter to achieve the task of writing its AssetList data member to the specified file. MainWindow also has a new slot to initiate the task of writing the list of assets to the file. A push button is added to the GUI to allow the user to save a list of assets to a file, where a QFileDialog is used to facilitate the selection of the file. Given below is a sample output of the application after a few assets have been added: Clicking on Save to File and choosing a file (in this case assetlist.xml), the following is produced in assetlist.xml: 6 4.3 Question 3 The aim of this question is use DOM for XML parsing. We extended the solution to question 2 by adding an AssetListReader to read the XML file generated by the solution in question 2. AssetListReader is a subclass of DomWalker and it parses an XML file to create a QList of Asset* that point to Asset heap objects. Since AssetListReader creates and saves Asset objects in its data member listAssets, it is also given the responsibility of deleting the Asset objects in its destructor. Note that you can parse XML without using DomWalker. AssetHandler is also expanded to include an AssetListReader object as its data member, with two functions to initiate parsing of the XML file and to obtain the list of assets from AssetListReader so that assets can be added to the AssetList maintained by AssetHandler. Note that AssetHandler makes copies of Asset objects before it is added to its AssetList data member. This is to avoid memory corruption from double deletion of the same pointers in both AssetList and AssetListReader, when an Asset object is in both the QList of Assets maintained by these two classes. A push button is added to the GUI to allow the user to read an XML file, where a QFileDialog is used to facilitate the selection of the XML file. As stated in the question, the application always maintains a unique list of assets and informs the user that an asset cannot be added if an asset with the same description already exists in the asset list. Given below is a sample output of the application after clicking on Read from File and choosing a file named assetlist.xml (created in question 2): 4.4 Question 4 The aim of this question is to understand and apply the Factory method and the Singleton design patterns. COS3711/202 7 We extended the solution to question 3 by adding a new class named AssetFactory. In this solution, AssetFactory creates assets in two ways; one by providing the type and all the values required by the constructors of concrete Asset subclasses and secondly by providing a pointer to an Asset object itself so that a copy of the Asset object can be created and returned. AssetFactory is a singleton, where access to the only object is managed via the getInstance() function. We have also included a function deleteInstance() in AssetFactory to facilitate the deletion of the only instance. The classes that use AssetFactory are AssetHandler and AssetReader. These two classes are appropriately modified to utilise the singleton AssetFactory. In this solution, AssetHandler is given the responsibility of deleting the only instance of AssetFactory in its destructor. MainWindow remains unchanged and the sample output from Question 3 applies here too. 4.5 Question 5 The aim of the question is to understand and apply the Memento design pattern. The given solution is structured as follows: • RandomNumberGenerator is the class that generates a list of random numbers. It has a data member seed to represent the seed for the random generator, which is managed by the class itself. Mementos of this class can be generated and restored. Every time the user requests a sequence of random numbers, it creates a new value for the seed based on the current time except when a memento was used to restore the state of a RandomNumberGenerator object. • RandomNumberGeneratorMemento represents the Memento class in the classic Memento pattern. Since the seed is the only aspect we need to safe keep, the only data member of RandomNumberGeneratorMemento represents the seed of RandomNumberGenerator. • RandomNumberCaretaker is the class that corresponds to Caretaker in the classic Memento pattern. It simply manages RandomNumberGeneratorMementos by keeping them in a QList. • MainWindow, the GUI class, allows the user to request a sequence of numbers. RandomNumberGenerator is set to produce 6 numbers from 1 to 6 with every request. Every time the user requests a list of numbers, a RandomNumberGeneratorMemento is created by MainWindow and stored in a RandomNumberCaretaker object. This class uses QStringListModel to store the list of random numbers generated each time and displays it using QListView. When the user selects an item from the QListView, the appropriate memento is retrieved from the caretaker, which is then used to set the state of a RandomGenerator object and gets the RandomGenerator object to regenerate the set of random numbers for the seed saved. A dice is represented graphically using an image. Although the solution adheres to the classic memento pattern, the design of the user interface is not satisfactory. Ideally one should be able to allow the user to choose the number of rolls and the user interface should be adaptable to display the specified number of dice. 8 Given below is a sample output of the application after clicking on the button (Roll Dice Six Times) seven times and then selecting the fifth roll: 4.6 Question 6 The aim of the question is to implement threading using Qt. The solution makes use of a class named RandomWalk, which is capable of running in a QThread as opposed to being a subclass of QThread, which performs random walking for 10 steps with a 1-second pause between each step. MainWindow, the GUI class, allows the user to enter initial coordinates and initiate random walking. This class creates an instance of RandomWalk and an instance of QThread, and executes the randomWalk() function of the RandomWalk object in the QThread object. Signals and slots are used for communication between the QThread and RandomWalk objects as well as between RandomWalk and MainWindow objects. Qt’s model class QStringListModel and the view class QListView are used to store and display the coordinates reached during the random walk. This solution only meets the requirements in the question and several improvements are possible. The number of steps and time interval between steps are hard coded and a better approach would be to allow the user to enter these values. It is also preferable to have a stop button on the user interface, which stops the random walk and perform necessary memory clean up, if required. Random walk is an interesting concept and it is studied extensively to model real-world processes. If you are interested to know further about random walk modelling and its applications, look at the Wikipedia page http://en.wikipedia.org/wiki/Random_walk. Given below is a sample output of the application: COS3711/202 9 4.7 Question 7 Refer to pages 31 and 32 of MO001 for a brief introduction to the Façade design pattern as explained by Gamma et al. Note that, unlike other design patterns you have come across, this design pattern does not have a UML class diagram. A Façade can make use of other design patterns as well. An example of a Façade is an Integrated Development Environment (IDE) used in software development. An IDE coordinates and hides complexities of using many subsystems such as compilers, linkers and debuggers to support the development of programming solutions. 4.8 Question 8 The aim of this question is to implement network programming using TCP/IP. As specified in the question, two separate applications are created to represent a voting station and a voting central office. The voting station application uses a QTcpSocket to connect to a local host and if the connection is successful, it sends voter numbers to the local host. Voting station asks the user regularly for voter numbers. The voting central office uses a QTcpServer to create QTcpSockets to bind to a port on local host and to listen for incoming data. If there is incoming data, it is displayed on the central office side. The solution can be improved by providing more informative messages on the user interfaces to indicate status of connection. To test this, you need to open both voting central office and voting station in Qt Creator. Then run the voting central office application first and then followed by voting station. Follow the requests on the voting station interface, which should be displayed in the voting central office interface. Your computer’s firewall may need to be disabled to get the application running. Given below is a sample output of both voting station and central office applications: 10 4.9 Question 9 The aim of the question is to implement a plugin to allow a Qt application to run in a web browser. The solution has a class named BmiViewer that has the input and output widgets to allow users to calculate BMI (body mass index). This class uses MiscConverter to perform conversions of various input parameters. There is a PluginFactory that creates an instance of BmiViewer when the attribute of type in object element in html is application/bmi. In MainWindow, an html file is displayed in a QWebView with plugins enabled and the plugin factory is set to PluginFactory. Given below is a sample output of the application: COS3711/202 11 5 MARKING RUBRIC Question 1 [20] Maximum Asset, Bond, Saving, Stock (inherits QObject, includes Q_OBJECT) 8 AssetList (uses QMetaObject) 2 User interface (input and output widgets) 2 Creation of Asset objects and use of AssetList 2 Displays asset list and value of assets (total and by type) 2 General design 2 Program builds and produces output 2 TOTAL 20 Question 2 [16] Maximum AssetListWriter (uses QXmlStreamWriter) 8 User interface (option to write to a file, uses QFileDialog) 3 Program builds and produces output 5 TOTAL 16 Question 3 [16] Maximum AssetListReader (uses DOM) 8 User interface(option to read from a file, uses QFileDialog) 2 Allows the XML file to be read any time, adds the assets to the current AssetList of the application, no duplicates allowed (warns user) 3 Program builds and produces output 3 TOTAL 16 Question 4 [16] Maximum AssetFactory (Factory method design pattern) 5 AssetFactory (Singleton design pattern) 5 Use of AssetFactory to create Assets 2 Program builds and produces output 4 TOTAL 16 Question 5 [16] Maximum RandomNumberGenerator (manages seed, returns numbers, creates memento and sets memento) 4 Memento class 3 Caretaker class 3 User interface (represent dice graphically, request new sequence, keeps a list of sequences, choose previous sequences) 3 Program builds and produces output 3 TOTAL 16 Question 6 [16] Maximum Class to simulate random walk capable of running in a thread 10 User interface (specify start, display coordinates of random walk) 3 Program builds and produces output 3 TOTAL 16 © UNISA 2015","libVersion":"0.2.3","langs":""}