{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Tutorial Letters/COS3711_2018_1_201.pdf","text":"COS3711/201/1/2018 Tutorial Letter 201/1/2018 Advanced Programming COS3711 Semester 1 School of Computing Discussion of assignment 1 BARCODE COS3711/201/1/2018 2 CONTENTS Page 1 INTRODUCTION ............................................................................................................................... 3 2 TUTORIAL MATTER......................................................................................................................... 3 3 COPYING OF ASSIGNMENTS ........................................................................................................ 3 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 1 ..................................................................... 3 4.1 Question 1.......................................................................................................................................... 3 4.2 Question 2.......................................................................................................................................... 4 4.3 Question 3.......................................................................................................................................... 4 4.4 Question 4.......................................................................................................................................... 5 4.5 Question 5.......................................................................................................................................... 5 4.6 Question 6.......................................................................................................................................... 6 4.7 Question 7.......................................................................................................................................... 6 4.8 Question 8.......................................................................................................................................... 7 5 MARKING RUBRIC........................................................................................................................... 7 COS3711/201/1/2018 3 Dear Student 1 INTRODUCTION The solutions and the discussions of the solutions are only made available electronically. The solution to assignment 1 is placed under Additional Resources of COS3711 on myUnisa. A separate folder is created for each question, in which you will find all the relevant files for its solution. Please note that the solutions provided on myUnisa are only suggested solutions and they are not the best or only solutions. Please note that the provided solutions were created and tested using Qt Creator 3.1.1 (opensource) based on Qt 5.2.1 (MSVC 2010, 32 bit) installed on a computer running on Windows 7 Enterprise (32- bit). This tutorial letter contains a short discussion of the solution to Assignment 1 of COS3711 made available on myUnisa. Hence, this tutorial letter should be used in conjunction with the solutions uploaded on myUnisa. The marking rubric used for marking of Assignment 1 is also included in this tutorial letter. It is impossible to follow a marking rubric strictly for a programming assignment. Hence the given marking rubric should be used only as a rough guideline. 2 TUTORIAL MATTER The following are important documents that you need to consult. Please download them from myUnisa if you do not already have them. COS3711/101/3/2018 First tutorial letter COS3711/MO001/3/2018 The contents of the myUnisa site for COS3711 COS3711/102/3/2018 Practical study guide COS3711/103/3/2018 Networking and the Web – Additional notes 3 COPYING OF ASSIGNMENTS Assignments that contained solutions copied from another student’s assignment are penalised heavily. 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 1 4.1 Question 1 The objective of this question is to become familiarised with an anti-pattern as explained in Chapter 7. The fundamental design problem with the Film class is that there are too many responsibilities in one single class; it has the data model, partial serialization code (responsible for saving the state of a Film object) and is also responsible for obtaining user input (combines model and view). You also need to understand why the given design is problematic for code reuse as well as extending the given class - something to think about. This question also corrects the anti-pattern by decomposing the responsibilities of the current class into different classes. This is one way of solving the Interface Bloat but the best way of decomposing the responsibilities will depend on the application context and requirements. COS3711/201/1/2018 4 Given below is the sample output of the GUI with necessary fields filled in: When the Save button is clicked, the film information is saved into a file films.txt as given below and the user is informed of the fact that the film information is saved. A very basic check is included to ensure that all the fields are completed before the Save button is clicked. 4.2 Question 2 The objective of this question is to introduce you to reflective programming offered by Qt via the QMetaObject class. The requirement of this question is to make the Film class reflective so that the state of a Film instance can be accessed using the generated meta-object in the FilmWriter class. This involves inheriting from QObject, including the Q_OBJECT macro and Q_PROPERTY macros for each data member that should be visible via the meta-object. Note that if a data member does not have a Q_PROPERTY macro, that data member will not be accessible via the meta-object. Reflective programming offers a generic way of accessing the state of any QObject (as long as the respective class is programmed to support reflective programming) instead of having to rely on class specific getter functions or toString() functions in a class. The output for this question is exactly the same as Question 1. 4.3 Question 3 The objective of this question is to introduce you to the model-view programming classes in Qt using QStandardItemModel and QTableView. QStandardItemModel is the data model, which you COS3711/201/1/2018 5 populate with the music data that you are tracking, and QTableView is used to view and edit this stored data. Much of the work here in in the GUI constructor: • Creating a model instance: model, with its header row. • Using setModel() to set the view’s model to the QStandardItemModel instance. • Setting up the view: enabling sorting and stretching the last column. • The connect() statements that link the add and delete buttons to GUI code as well as the statement that connects changes made in the model to a function that allows us to change the row colour as necessary. Adding an item to a QStandardItemModel involves the following. • The data items that are to be added to the model are QStandardItems. Note that for numeric values, it is suggested that you use setData() to have more control over the display of the data. However, as the cost price is being formatted in updateRow(), it is not handled here. • All these are then added to a QList, and the QList is appended to the model. To delete a row, you have to do the following. • Get the currentIndex() in the view – that is, an index that represents which row and column in the model is currently being pointed to in the view. • Then, after checking that the user does want to delete the row, the row number is extracted from the index, and that row removed from the model. The only other function that needs noting is the updateRow() function. This function is used to ensure that the cost price displays in a currency format, as well as change a row’s background colour depending on the value of the QStandardItem that is passed to it. The setBackground() function is used to colour each cell in the model (which is then reflected in the view). The structure of the solution can be improved by separating the model and view into separate classes. No graphic of the working program is given here as there is one in the questions in tut 101. 4.4 Question 4 The GUI for this program is fairly simple, and the solution is designed so that the file reading and XML checking are handled by separate classes. The ReadFile::readFile() function ensures that a file can be successfully opened and read. The file contents are returned as a QString to the calling function. The RegExChecker::check() function does most of the work by searching for tags using a regular expression and then classifying the found tags. In the GUI, if an empty string is returned, the Check button is not enable, so handling empty files. The data returned by RegExChecker::check() is displayed on the GUI, displaying a message box once the display is complete (so that the user knows the processing is finished). A sample file named menu.xml is provided to test the solution. 4.5 Question 5 The aim of this exercise is to recognise a class with too many responsibilities as well as to re-design such a class so that classes can be designed with one purpose or responsibility. Since neither the complete implementation for the class Customer, nor a description of its member functions, is given, it is not clear what the purpose of each function is. It is possible that your COS3711/201/1/2018 6 interpretation of the intention of each function might be different from our interpretation. Hence, there are numerous solutions possible for this question. 4.6 Question 6 The objective of this question is to become familiarised with dynamic properties of the QObject class. When the Film object was created, we used setProperty() to set the title property – note that this does not create a dynamic property, but sets the QMetaObject title property. Try commenting out the Q_PROPERTY macro for title in the Film class, and see how the output changes – note that the title is now printed at the end together with the other dynamic property. However, when the Object name property was added, it was added as a dynamic property to the Film instance. Ideally, dynamic properties are added at run time and it does not make sense to add properties dynamically when they are already included as class data members. The obvious benefit of including dynamic properties is to attach new properties and values to a QObject without making any changes to the class. So there is no need for recompiling the original class and you may add properties at run-time. However, such addition is not checked in any way. You might end up adding properties to an object, which really deviates from what the designer intended for the Film class. You should be using dynamic properties if you want to add some additional information (tagging) to objects occasionally. It should not be used to override the original design intention of the class. 4.7 Question 7 The objective of this question is to introduce you to the role of delegates in model-view programming classes in Qt. In in the GUI constructor, the delegate is set up on a particular column of the view, which is used to produce a custom display of the rating. Delegates are used to customise the rendering/display and editing of items in a view, and in this case we are concerned only with the display of the one column, and will leave all other behaviour to defaults. A separate class (RatingDelegate) was added to handle the display. This RatingDelegate inherits from QStyledItemDelegate, and implements the paint() function: after checking that the value is an int, it creates a rectangle to represent the rating amount (with 100 being the maximum) that will be displayed in the QTableView. Again, there is scope to split the responsibilities in MainWindow into two classes. No graphic of the working program is given here as there is one in the questions in tut 101. COS3711/201/1/2018 7 4.8 Question 8 The aim with this question was to practice using regular expressions to search for data that matched a certain pattern. You will see that 4 regular expressions were used in the program, one each for the types of errors that were being searched for. When the user chooses to load a file, after checking that the file exists, it is read line by line into a QList (for each line) of QStringLists (for each word in a line) – this was done so that it is possible to indicate on which line and in which word the error was found, and the Check button is enabled. Note that an error message is provided should the file not open. For checking, each word is matched against the regular expression patterns, and where there is a match, the line number, word number, and word are appended to the GUI display. There is a graphic of the running program in tut 101. Note also that a text file (myFile.txt) is provided with the sample solution so that you can use it to test the program. 5 MARKING RUBRIC Question 1 [25] Key Aspects Allocated marks Marks awarded Implementation of the re-designed Film class • Unnecessary functions removed 2 • Other functions all implemented 2 • Getter functions const 1 5 Implementation of the FilmWriter class • saves the state of a Film instance in a file (in any sensible, human-readable format) 4 • File checked for opening successfully, & closed again 2 6 Implementation of the FilmInput (GUI) class • User can enter film info via sensible widgets 3 • Film instance created 2 • Film instance saved using FilmWriter 3 • User interface: reset widgets, provide feedback, etc 1 9 Program builds (2) and provides some functionality (3) 5 Total marks 25 0 Comments: Question 2 [25] Key Aspects Allocated marks Marks awarded Film class is made reflective 10 FilmWriter class makes use of metaobject to access the state of a Film instance 10 Program builds (2) and provides some functionality (3) 5 Total marks 25 0 Comments: Question 3 [25] Key Aspects Allocated marks Marks awarded COS3711/201/1/2018 8 Model • QStandardItemModel used 2 • 4 items added for each row 2 • Model has header row 1 5 View • QTableView used 2 • View sets model 1 • Replacement value displays to 2 decimal points (including .00), even after edit 3 • Replacement ≥ R250 in different colour (works both ways), even after edit 3 • Stretch last column 1 10 Required functionality • Sort by selecting column heading 2 • Row can be deleted after checking with user 3 5 Program builds (2) and provides some functionality (3) 5 Total marks 25 0 Comments: Question 4 [25] Key Aspects Allocated marks Marks awarded File • User can select file 2 • Error message if cannot open 2 • Some indication that the file has loaded 2 6 Checking • Handled as a separate class 2 • Using regular expression 3 • Single regular expression used 1 • Tags found successfully 8 14 Program builds (2) and runs (data displayed on GUI) (3) 5 Total marks 25 0 Comments: © UNISA 2018","libVersion":"0.2.3","langs":""}