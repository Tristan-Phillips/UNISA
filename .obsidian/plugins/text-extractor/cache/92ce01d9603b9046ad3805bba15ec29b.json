{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Tutorial Letters/COS3711_2018_2_201-2.pdf","text":"COS3711/201/2/2018 Tutorial Letter 201/2/2018 Advanced Programming COS3711 Semester 2 School of Computing Discussion of Assignment 1 BARCODE COS3711/201/2/2018 2 CONTENTS Page 1 INTRODUCTION .......................................................................................................................... 3 2 TUTORIAL MATTER .................................................................................................................... 3 3 COPYING OF ASSIGNMENTS .................................................................................................... 3 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 1 ................................................................... 3 4.1 Question 1 .................................................................................................................................... 3 4.2 Question 2 .................................................................................................................................... 5 4.3 Question 3 .................................................................................................................................... 5 4.4 Question 4 .................................................................................................................................... 6 4.5 Question 5 .................................................................................................................................... 7 4.6 Question 6 .................................................................................................................................... 7 4.7 Question 7 .................................................................................................................................... 8 4.8 Question 8 .................................................................................................................................... 8 5 MARKING RUBRIC ...................................................................................................................... 9 COS3711/201/2/2018 3 Dear Student 1 INTRODUCTION This discussion, and the solutions, are only made available electronically. The solution to assignment 1 is placed under Additional Resources of COS3711 on myUnisa. A separate folder is created for each question, in which you will find all the relevant files for its solution. Please note that the solutions provided on myUnisa are only suggested solutions and they are not the best or only solutions. This tutorial letter contains a short discussion of the solution to Assignment 1 of COS3711 made available on myUnisa. Hence, this tutorial letter should be used in conjunction with the solutions uploaded on myUnisa. The marking rubric used for marking Assignment 1 is also included in this tutorial letter. It is impossible to follow a marking rubric strictly for a programming assignment. Hence the given marking rubric should be used only as a rough guideline. 2 TUTORIAL MATTER The following are important documents that you need to consult. Please download them from myUnisa if you do not already have them. COS3711/101/3/2018 First tutorial letter COS3711/MO001/3/2018 The contents of the myUnisa site for COS3711 COS3711/102/3/2018 Practical study guide COS3711/103/3/2018 Networking and the Web – Additional notes 3 COPYING OF ASSIGNMENTS Assignments that contained solutions copied from other students' assignments were penalised. 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 1 4.1 Question 1 The point of this question was to see whether you could take the requirements given and set up the appropriate classes while avoiding any anti-patterns. The fundamental design problem to avoid is having too many responsibilities in a single class: a data model is needed, code is needed for obtaining user input (combining model and view), and partial serialization code is needed to write the state of objects to file. You need to understand why separating these concerns will enhance code reuse. So looking at what was required in the question, there should be classes for at least the following.  The GUI will need to be in a class – this is the MainWindow class in the provided sample solution, and its job is to set up the GUI and handle the user interface (that is, the clicking of the Process button). This GUI class has an instance of StaffList as a data member; it is here that the list will be managed from. Note that the GUI uses appropriate widgets to ensure that only appropriate data is entered for the data fields, and so avoid the problems associated with invalid data being entered. COS3711/201/2/2018 4  There needs to be a class to hold the staff data – the Staff class in the sample solution. This class simply holds the data of a staff member (with the appropriate constructors, getters, and setters), and the enum to handle the employee type. Note that it does not hold a list of staff members, and does not handle any code for writing data to file. There is a QStringList that is used to simplify the handling of the employee type and the conversions between the enum and a QString representation of the data. This is only one way of approaching this, and there are other ways (which includes an approach that uses a meta-object to access the enum).  The StaffList class is used as the container to hold a QList of Staff objects, and so all this class does is provide for adding Staff instances to the class and returning a complete list of Staff objects. If you do not want to return the whole list in one go, you could provide a function that returns the number of items being held by the list, and then a getItem(int item) function that takes the number of the item that should be returned, and returns that particular object in the list. Again, note that this class has only one responsibility. Also, note that neither a text file nor a QStringList would be an appropriate container to hold Staff objects.  There is a separate class to handle the writing of Staff objects to file – the StaffWriter class in the sample solution. As Staff objects are written to file as they are created, it is simpler to pass one Staff object to the class at a time (via the constructor), and write that object’s data to file. Note that the writeToFile() function uses the getters in the Staff class to access data values for a Staff object. As only one file is used to write all the data, we are appending new data to the file. Remember to close the file once data has been written. This very modular approach allows us to add functionality to the various classes without there being any impact on any of the other classes. Thus, should there be a need to output the data to a GUI display window, there is only the need to add a class to provide this functionality without changing any of the other classes. This then allows for easier code reuse and the ability to extend classes without impacting the whole application. To get the application to run, all that is required is that an instance of the GUI, MainWindow, be created in main(), and its window shown. Once the user has entered data, there is only one action that needs to be handled.  When the Process button is clicked, a Staff instance is constructed, which is then added to the list maintained by the GUI, and written to a file via an instance of a StaffWriter object. Shown below is an example of data being entered in the GUI window, and of the data that was written to file. COS3711/201/2/2018 5 4.2 Question 2 The objective of this question is to introduce you to reflective programming offered by Qt via the QMetaObject class. The requirement of this question is to make the Staff class reflective so that the state of a Staff instance can be accessed using the generated meta-object in the staffWriter class. No change has to be made to the GUI class. Firstly, the Staff class will need to be made reflective. The following is required.  Staff must inherit from QObject as meta-objects can only be found from QObjects.  The Q_OBJECT macro must be included.  A Q_PROPERTY macro must be added for each data member that you want to make available as a property, supplying the property type and name, the function that will be used to read the property’s value, and the function needed to set the property’s value.  A Q_ENUMS macro to identify the enum in the class to the meta-object. You will see that the return type for the type Q_PROPERTY is StaffType, and so new getters and setters were added to handle this. You will also see that the meta-object was used to find information about the enum.  Note that all the getters and setters have been made private so that they cannot be accessed by another object. As Staff now is a QObject, it cannot be passed “by value” anymore as this uses an object’s copy constructor, and QObject’s copy constructor is private (preventing this way of passing objects around). Thus we now work with pointers to Staff objects. This further means that the list of Staff objects now is a list of pointers, and that it is now necessary to delete the memory allocated to these pointers when the list is destroyed. Changes also need be made to the StaffWriter class. The writeToFile() function now accesses a Staff object’s data via its meta-object. You will see that once the meta-object has been obtained, the code loops through all the properties (using QMetaProperty), accessing the property name and its value. Note that the value is returned as a QVariant and then converted to a QString. These are then written to file. Reflective programming offers a generic way of accessing the state of any QObject (as long as the respective class is programmed to support reflective programming) instead of having to rely on class specific getter functions or toString() functions in a class. The GUI and output should be the same as for Question 1. 4.3 Question 3 The objective of this question is to introduce you to the model-view programming classes in Qt using QAbstractTableModel and QTableView. You need to subclass QAbstractTableModel to create your custom model, which you will populate with the music data that you are tracking, and QTableView is used to view and edit this stored data. A good source of information for this question can be obtained from the QT Assistant: see subclassing under QAbstractTableModel. You firstly need to create your custom model (MusicModel in the sample solution). A CD class has been created so that data for the model can be saved in a QList of CDs. For a well-behaved model, the following functions need to be implemented:  rowCount(): This function returns the size of the QList.  columnCount(): This function returns 4 as there are 4 pieces of data per record, and so 4 columns in the “table” that this model manages. COS3711/201/2/2018 6  data(): This function is used to fetch data from the model to display in the view. Based on the row and column of the index sent to the function, it can be determined which piece of data to return from the QList. This is also where we ensure that the cost displays correctly.  headerData(): This function is used to return the headers for the various columns for the view.  setData(): This function is used when model data is updated in the view. Again, based on the index sent, it can be determined which piece of data in the list needs to be updated. It can also be used when adding data to the model.  flags(): This function is used to set flags that allow data in the model to be changed via the view. This custom model also implements addCD() so that data can be added to the model. Note that beginInsertRows() and endInsertRows() should be called before data is added to the QList that store the data in the model. The GUI class (MainWindow) has a pointer to the custom model, and the QTableView is part of the interface that was created using Qt Designer (in this example solution). In the GUI constructor, the model and view are linked.  Creating a model instance: model.  Using setModel() to set the view’s model to the model instance.  Setting up the view: stretching the last column.  The connect() statement that links the Add button to GUI code. Adding an item to the model involves using the addCD() function of the model, and passing the relevant data from the GUI. No graphic of the working program is given here as there is one in the question in Tut Letter 101. 4.4 Question 4 The main() function checks that some arguments are provided, collects these together in a QStringList and then passes them on to an instance of the Count class that does the work. The Count class constructors set up the environment: it sets the various flags as required and gathers the file list into a QStringList for processing. Count::doCount() loops through all the provided file names, processing them one at a time. Count::processFile() then opens each file, reads it contents, prepares the contents for parsing, and then each count that was requested via the flags is processed and its returned results strings collected. It is in Count::process() that the file contents are searched word by word, comparing each word to the required QRegExp using exactMatch(). The regular expressions are structured as follows.  a: [A-Z][A-Za-z]{4,} An initial capital alphabetic letter followed by at least 4 alphabetic characters to ensure that the length of the word is 5 or more characters.  b: [A-Za-z]+[-][A-Za-z]+ The + regular expression character means 1 or more occurrences of the characters before it. So there needs to be at least 1 alphabetic character, followed immediately by a hyphen, which is followed immediately by at least 1 alphabetic character.  c: ^([a-zA-Z])[a-zA-Z]*\\\\1$ This pattern uses grouping by putting the first alphabetic character at the beginning of the word in parentheses, followed by zero or more alphabetic characters, followed by \\\\1 which refers to the first set of parentheses, followed by the last alphabetic symbol, thus ensuring that the first and last characters should be the same character.  d: [^aeiou].* The ^ symbol is used to indicate that the vowels in the square brackets should not be found as the first character in a word matched by this regular expression. The point and asterisk indicate that the first letter can be followed by zero or more characters. Note the difference between the use of ^ here and that used in c (where it pointed to the start of the word). COS3711/201/2/2018 7 4.5 Question 5 The aim of this exercise is to recognise a class with too many responsibilities as well as to re-design such a class so that classes can be designed with one purpose or responsibility. Since neither the complete implementation for the class Customer, nor a description of its member functions, is given, it is not clear what the purpose of each function is. It is possible that your interpretation of the intention of each function might be different from ours. Hence, there are numerous solutions possible for this question. 4.6 Question 6 The objective of this question is for you to get familiarised with dynamic properties of the QObject class. Dynamic properties are added to a specific instance at run time, and it should be clear that although all instances of a class share the property list via the meta-object, dynamic properties are unique to objects. The obvious benefit of including dynamic properties is to attach new properties and values to a QObject without making any changes to the class. So there is no need for recompiling the original class and you may add these properties at run time. However, such additions are not checked in any way, and you might end up adding properties to an object that result in it deviating from what the designer intended for the original class. For example you can add a dynamic property named length with value 10km for a Staff object although we all know that it is a completely inappropriate property for a Staff object! The changes that need to be made to Question 2 include the following.  The data is obtained from the user and the setProperty() function is used to set the property of the appropriate instance in the list. What would happen if you used setProperty() to “add” a property with the same name as a property that already exists in the object (like name)? Test this with your program. You can also look at the Qt documentation for the setProperty() function, and should be able to predict what would happen. Note that we have populated the dialog with the names of staff members to make adding a dynamic property more realistic; for this we had to know that there was a property named name, and had to use the meta-object interface (as the getName() function is now private).  Changes also need to be made to the StaffWriter class function that writes to file. If left as it was in Question 2, you would see that dynamic properties are not picked up in the standard way that other properties are found. For each individual object, you need to get it dynamicPropertyNames() list, and then for each property name in this list you can use the property() function to access its value. The output for this question can be seen in Tut Letter 101. COS3711/201/2/2018 8 4.7 Question 7 A delegate is used to produce a custom display of the rating, and it is achieved by creating a separate class (RatingDelegate) to handle the display. This RatingDelegate inherits from QStyledItemDelegate, and implements the paint() function: after checking that the value is an int, it creates a rectangle to represent the rating amount (with 100 being the maximum) that will be displayed in the QTableView. The delegate also needs to be linked to the table view using the setItemDelegateforColumn() function. To delete data from the model, a Delete button needs to be added to the GUI. When this is clicked, the index of the currently selected row is found, and after checking with the user, this row is deleted. Note that in MusicModel::deleteRow(), beginRemoveRows() and endRemoveRows() are called before and after data is deleted from the model. The model that is used in this example shows an alternative way of handling the data in the model – instead of a single QList of CD items, the model in this case manages a separate QList for each data item, thus having to ensure that all four are kept in sync. Given below is a sample output screenshot of the GUI with the delegate used for the rating column. 4.8 Question 8 The aim with this question was to practice using regular expressions to search for data that matched a certain pattern. You will see that 4 regular expressions were used in the program, one each for the types of errors that were being searched for. When the user chooses to load a file, after checking that the file exists, it is read line by line into a QList (for each line) of QStringLists (for each word in a line) – this was done so that it is possible to indicate on which line and in which word the error was found, and the Check button is enabled. Note that an error message is provided should the file not open. For checking, each word is matched against the regular expression patterns, and where there is a match, the line number, word number, and word are appended to the GUI display. There is a graphic of the running program in Tut Letter 101. Note also that a text file (myFile.txt) is provided with the sample solution so that you can use it to test the program. COS3711/201/2/2018 9 5 MARKING RUBRIC Question 1 [25] Mark Separate Staff class created to hold data  data private 1  getters and setters included 1  getters are const 1  enum for staff type 2 5 Separate StaffList class created to store list of data  appropriate private container provided 2  function to add Staff 2  Data correctly transferred to container 1 5 Separate StaffWriter class created to handle file output  Staff object passed to writer 1  data written to file correctly 2  file: handle opening errors and closing 2 5 GUI class created with appropriate data widgets  appropriate widgets provided to get data from user 2  button for adding staff member 1  Staff object added to list and written to file automatically 2 5 Program builds (2) and runs, providing some functionality (3) 5 TOTAL 25 Question 2 [25] Mark Reflective  Staff class is made reflective 8 8 Output to file  Function uses QMetaObject and QVariant 6  No assumptions are made about number/names of properties 3  The enum is handled appropriately 3 12 Program builds (2) and runs, providing some functionality (3) 5 TOTAL 25 Question 3 [25] Mark Model  Inherits from QAbstractTableModel 1  Holds all 4 fields 2  Implements rowCount() 1  Implements columnCount() 1  Implements data() 2  Implements headerData() 1  Implements setData() 3  Implements flags() 1  Data can be added to the model and displays correctly 2 14  View  QTableView used 2  View sets model 2  Replacement value displays to 2 decimal points (including .00) 2 6 Program builds (2) and runs, providing some functionality (3) 5 TOTAL 25 COS3711/201/2/2018 10 Question 4 [25] Mark Arguments  Arguments read 1  No arguments handled 1  Argument flags correctly identified in all formats 2 4 Checking  File opening checked and file closed 2  Correct counts done as per argument flags 2  Regular expressions for flag –a 2  Regular expressions for flag –b 2  Regular expressions for flag –c 2  Regular expressions for flag –d 2  Regular expression used to remove punctuation 1  File parsed and counts tallied 3 16 Program builds (2) and runs, providing some functionality (3) 5 TOTAL 25 © UNISA 2018","libVersion":"0.2.3","langs":""}