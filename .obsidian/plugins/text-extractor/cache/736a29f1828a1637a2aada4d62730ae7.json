{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/some slides/lec08_propositionallogic.pdf","text":"Fundamentals of Artificial Intelligence Logical Agents and Propositional Logic Knowledge Based Agents ‚Ä¢ The intelligence of humans is achieved not by purely reflex mechanisms but by processes of reasoning that operate on internal representations of knowledge. ‚Ä¢ In AI, this approach to intelligence is embodied in knowledge-based agents. ‚Ä¢ Logical agents (knowledge-based agents) can ‚Ä¢ form representations of a complex world, ‚Ä¢ use a process of inference to derive new representations about the world, and ‚Ä¢ use these new representations to deduce what to do. ‚Ä¢ Knowledge-based agents is supported by logic such as propositional logic or first-order predicate logic. Knowledge Base ‚Ä¢ A knowledge base (KB) is a set of sentences in a formal language. ‚Ä¢ Inference: Deriving new sentences from old sentences in KB. ‚Ä¢ Each time a knowledge-based agent does three things. 1. TELLs the knowledge base what it perceives. TELL operations add new sentences (agent‚Äôs perceptions) to the knowledge base. 2. ASKs the knowledge base what action it should perform. ‚Ä¢ Extensive reasoning (inference) may be done about the current state of the world, about the outcomes of possible action sequences. 3. The agent TELLs the knowledge base which action was chosen, and the agent executes the action. A Simple Knowledge-Based Agent ‚Ä¢ MAKE-PERCEPT-SENTENCE constructs a sentence asserting that the agent perceived the given percept at the given time. ‚Ä¢ MAKE-ACTION-QUERY constructs a sentence that asks what action should be done at the current time. ‚Ä¢ MAKE-ACTION-SENTENCE constructs a sentence asserting that the chosen action was executed. ‚Ä¢ The details of the inference mechanisms are hidden inside TELL and ASK. Wumpus World ‚Ä¢ The wumpus world is a simple computer game, but it illustrates some important points about intelligence. ‚Ä¢ Wumpus eats anyone who enters its room. ‚Ä¢ The wumpus can be shot by an agent (wumpus dies if it is shot), but the agent has only one arrow. ‚Ä¢ The agent can safely enter a death wumpus‚Äôs room. ‚Ä¢ Some rooms contain bottomless pits that will trap anyone who wanders into these rooms. ‚Ä¢ A room contains gold. Wumpus World Description Performance measure: gold +1000, death -1000, -1 per step, -10 for using the arrow Environment: A 4√ó4 grid of rooms. The agent always starts in the square [1,1], facing to the right. The locations of the gold and the wumpus are chosen randomly, with a uniform distribution, from the squares other than the start square. Each square other than the start can be a pit, with probability 0.2. ‚Ä¢ Squares adjacent to wumpus are smelly ‚Ä¢ Squares adjacent to pit are breezy ‚Ä¢ Glitter iff gold is in the same square ‚Ä¢ Shooting kills wumpus if you are facing it ‚Ä¢ Shooting uses up the only arrow ‚Ä¢ Grabbing picks up gold if in same square ‚Ä¢ Releasing drops the gold in same square Actuators: Left turn, Right turn, Forward, Grab, Release, Shoot Sensors: Breeze, Glitter, Smell, (Bump, Scream) Exploring A Wumpus WorldExploring A Wumpus WorldExploring A Wumpus WorldExploring A Wumpus WorldExploring A Wumpus WorldExploring A Wumpus WorldExploring A Wumpus WorldExploring A Wumpus WorldSome Tight Spots in Wumpus WorldLogic LOGICS are formal languages for representing information such that conclusions can be drawn. SYNTAX: The Syntax of a logic defines the sentences (well-formed formulas) in that logic. SEMANTICS: The Semantics of a logic defines the meaning of sentences. ‚Ä¢ The semantics defines the truth of each sentence with respect to each possible world. ‚Ä¢ The term model is also used in place of possible world. SATISFACTION: ‚Ä¢ If a sentence Œ± is TRUE in model m, we say that m SATISFIES Œ± (or sometimes we simply say that m is a model of Œ±). ‚Ä¢ The notation M(Œ±) to mean the set of all models of Œ± (i.e. M(Œ±) is the set of all models that satisfy Œ±) . Logical Entailment (other names: Logical Consequence or Logical Implication) ‚Ä¢ Logical Entailment between sentences means that a sentence follows logically from another sentence. In mathematical notation, ùú∂ ‚ä® ùú∑ The formal definition of entailment : ùú∂ logically entails ùú∑ ùú∂ ‚ä® ùú∑ if and only if, ùú∑ is true in all worlds where ùú∂ is true ‚Ä¢ ùú∂ ‚ä® ùú∑ if and only if M(ùú∂) ‚äÜ M(ùú∑) . ‚Ä¢ if ùú∂ ‚ä® ùú∑ , then ùú∂ is a stronger assertion than ùú∑ : it rules out more possible worlds. Logical Entailment: Models ‚Ä¢ Logicians typically think in terms of models, which are formally structured worlds with respect to which truth can be evaluated ‚Ä¢ We say m is a model of a sentence Œ± if Œ± is true in m ‚Ä¢ M(Œ±) is the set of all models of Œ± (all models satisfy Œ±) ‚Ä¢ Then KB ‚ä® Œ± if and only if M(KB) ‚äÜ M(Œ±) M(Œ±) ‚Ä¢ E.g. KB = Giants won and Reds won Œ± = Giants won Entailment in Wumpus World Situation after detecting nothing in [1,1], moving right, breeze in [2,1] Consider possible models for ?s assuming only pits 3 Boolean choices ÔÉû 8 possible models Entailment in Wumpus World: Wumpus ModelsWumpus Models: is [1,2] safe? KB = wumpus-world rules + observations Wumpus Models: is [1,2] safe? KB = wumpus-world rules + observations Œ± 1 = ‚Äú[1,2] is safe‚Äù, KB ‚ä® Œ± 1, proved by model checking Wumpus Models: is [2,2] safe? KB = wumpus-world rules + observations Wumpus Models: is [2,2] safe? KB = wumpus-world rules + observations Œ± 2 = ‚Äú[2,2] is NOT safe‚Äù, KB ‚ä≠ Œ± 2, proved by model checking ‚Ä¢ the agent cannot conclude that there is no pit in [2,2]. (Nor can it conclude that there is a pit in [2,2]. Model Checking ‚Ä¢ In Wumpus world, the entailment is applied to derive conclusions from KB; i.e. a logical inference is carried out by checking the models. ‚Ä¢ The algorithm used in this process is called as model checking. ‚Ä¢ Model Checking is an inference algorithm that enumerates all possible models (of KB) to check that Œ± is true in all models in which KB is true, that is, that M(KB) ‚äÜ M(Œ±). Thus KB ‚ä® Œ± ‚Ä¢ Model checking algorithm can be expensive (or impractical) because KB can have too many models (or it can have infinite models in some logics). Inference (Proofs) ‚Ä¢ If an inference algorithm i can derive Œ± from KB (generally by syntactic operations), we write KB ‚ä¢i Œ± which is pronounced ‚ÄúŒ± is derived from KB by inference procedure i‚Äù. (or Œ± is proved/deducted from KB) ‚Ä¢ In a derivation, we start from premises (sentences (in KB) assumed to be true) and axioms (sentences that are true in every world). ‚Ä¢ Then, we apply an inference rule to sentences that are already derived (proved) to derive a new sentence at each step of the derivation. Inference: Soundness and Completeness Soundness: An inference algorithm i is sound (or truth-preserving) if whenever KB ‚ä¢i Œ±, it is also true that KB ‚ä® Œ± ‚Ä¢ If an inference algorithm is sound, all derivable sentences from KB are also logical consequences of KB. Completeness: An inference algorithm i is complete if whenever KB ‚ä® Œ±, it is also true that KB ‚ä¢i Œ± ‚Ä¢ If an inference algorithm is complete, all entailed sentences from KB are also derivable from KB. Propositional Logic ‚Ä¢ Propositional Logic is a simple but powerful logic. ‚Ä¢ The syntax of propositional logic defines the allowable sentences. ‚Ä¢ The semantics of propositional logic defines the rules for determining the truth of a sentence with respect to a particular model. ‚Ä¢ Propositional Logic contains proposition symbols and logical connectives (logical operators). ‚Ä¢ The meaning of a propositional symbol can be true or false. ‚Ä¢ The meaning of a logical connective is given by its truth table. Propositional Logic: Syntax ‚Ä¢ The atomic sentences consist of a single proposition symbol. ‚Ä¢ Each proposition symbol stands for a proposition that can be true or false. ‚Ä¢ There are two proposition symbols with fixed meanings (constants): True is the always-true proposition and False is the always-false proposition. ‚Ä¢ Complex sentences are constructed from other sentences, using parentheses and logical connectives. NEGATION CONJUNCTION DISJUNCTION IMPLICATION BICONDITIONAL Propositional Logic: Syntax ‚Ä¢ A literal is either an atomic sentence (a positive literal) or a negated atomic sentence (a negative literal). ‚Ä¢ A sentence whose main connective is ‚àß, such as P ‚àß Q, is called a conjunction; its parts are the conjuncts. ‚Ä¢ A sentence whose main connective is ‚à®, such as P ‚à® Q, is called a disjunction; its parts are the disjuncts. ‚Ä¢ A sentence such as P ‚áí Q is called an implication (or conditional). Its premise or antecedent is P, and its conclusion or consequent is Q. Propositional Logic: Semantics ‚Ä¢ The semantics defines the rules for determining the truth of a sentence with respect to a particular model. ‚Ä¢ In propositional logic, a model simply fixes the truth value‚Äîtrue or false‚Äîfor every proposition symbol. Ex. Model: ‚Ä¢ If the sentences in the knowledge base make use of the proposition symbols P, Q, and R, then one possible model is m1 = {P=false, Q=false, R=true} . ‚Ä¢ With three proposition symbols, there are 23=8 possible models P Q R true true true true true false true false true true false false false true true false true false false false true false false false Propositional Logic: Semantics ‚Ä¢ The semantics for propositional logic must specify how to compute the truth value of any sentence, for a given a model m. ‚Ä¢ Since all sentences are constructed from atomic sentences and the five connectives; we need to specify ‚Ä¢ how to compute the truth of atomic sentences and ‚Ä¢ how to compute the truth of sentences formed with each of the five connectives. Propositional Logic: Semantics Rules for evaluating truth with respect to a model m Atomic Sentences: ‚Ä¢ True is true in every model and False is false in every model. ‚Ä¢ The truth value of every other proposition symbol must be specified directly in the model m. Complex Sentences: five rules which hold for any sub-sentences P and Q in any model m ‚Ä¢ ¬¨P is true iff P is false in m. ‚Ä¢ P ‚àß Q is true iff both P and Q are true in m. ‚Ä¢ P ‚à® Q is true iff either P or Q is true in m. ‚Ä¢ P ‚áí Q is true unless P is true and Q is false in m. ‚Ä¢ P ‚áî Q is true iff P and Q are both true or both false in m. Propositional Logic: Semantics Truth Tables ‚Ä¢ The semantic rules can also be expressed with truth tables that specify the truth value of a complex sentence for each possible assignment of truth values to its components. Propositional Logic Wumpus world sentences ‚Ä¢ Px,y is true if there is a pit in [x, y]. ‚Ä¢ Wx,y is true if there is a wumpus in [x, y], dead or alive. ‚Ä¢ Bx,y is true if the agent perceives a breeze in [x, y]. ‚Ä¢ Sx,y is true if the agent perceives a stench in [x, y]. ‚Ä¢ There is no pit in [1,1]: ‚Ä¢ A square is breezy if and only if there is a pit in a neighboring square. ‚Ä¢ The breeze percepts for the first two squares visited in the specific world the agent is in. ‚Ä¢ From these sentences, we can derive (there is no pit in [1,2]). Propositional Logic Inference by Enumeration of Models ‚Ä¢ Our goal now is to decide whether KB ‚ä® Œ± for some sentence Œ±. ‚Ä¢ For example, is ¬¨P1,2 entailed by our KB? ‚Ä¢ Inference by Enumeration of Models is a direct implementation of the definition of entailment: ‚Ä¢ Enumerate the models, and check that Œ± is true in every model in which KB is true. ‚Ä¢ Models are assignments of true or false to every proposition symbol. ‚Ä¢ Inference by Enumeration of Models algorithm is sound and complete. ‚Ä¢ If KB and Œ± contain n symbols in all, then there are 2n models. ‚Ä¢ Thus, the time complexity of the algorithm is O(2n). Propositional Logic Inference by Enumeration of Models Propositional Logic Inference by Enumeration of Models ‚Ä¢ Enumerate rows (different assignments to symbols), ‚Ä¢ if KB is true in row, check that Œ± is too ‚Ä¢ Since there are 7 propositional symbols, there are 128 rows. ‚Ä¢ In all 3 rows, P1,2 is false, so there is no pit in [1,2]. ‚Ä¢ On the other hand, there might (or might not) be a pit in [2,2]. Logical EquivalenceValidity and SatisfiabilityInference and Proofs ‚Ä¢ A proof is a sequence of sentences that leads to the desired goal. ‚Ä¢ A proof starts with given premises and each new sentence in the sequence is obtained as a result of the application of an inference rule to previous sentences in the sequence. Some Inference Rules: Modus Ponens: And-Elimination: ‚Ä¢ All logical equivalences can be used as inference rules. Inference and Proofs ‚Ä¢ Inference rules are sound. i.e. when their premises are true their conclusions are also true. Wumpus World Proof Example: 1. (WumpusAhead ‚àßWumpusAlive) ‚áí Shoot Premise 2. (WumpusAhead ‚àß WumpusAlive) Premise 3. Shoot Modus Ponens 1 and 2 Another Example: 1. (WumpusAhead ‚àß WumpusAlive) Premise 2. WumpusAlive And-Elimination 1 Inference and Proofs Derivation (proof) of ¬¨P1,2 from given premises 1. ¬¨P1,1 Premise 2. B1,1 ‚áî (P1,2 ‚à® P2,1) Premise 3. B2,1 ‚áî (P1,1 ‚à® P2,2 ‚à® P3,1) Premise 4. ¬¨B1,1 Premise 5. B2,1 Premise 6. (B1,1 ‚áí (P1,2 ‚à® P2,1)) ‚àß ((P1,2 ‚à® P2,1) ‚áí B1,1) Biconditional elimination to 2 7. ((P1,2 ‚à® P2,1) ‚áí B1,1) And-Elimination to 6 8. (¬¨B1,1 ‚áí ¬¨(P1,2 ‚à® P2,1)) Logical equivalence for contrapositives to 7 9. ¬¨(P1,2 ‚à® P2,1) Modus Ponens to 8 and 4 10. ¬¨P1,2 ‚àß ¬¨P2,1 De Morgan‚Äôs rule to 9 11. ¬¨P1,2 And-Elimination to 10 Searching for Proofs ‚Ä¢ Searching for proofs is an alternative to enumerating models (exponential) and it is more efficient. ‚Ä¢ We can apply any of the search algorithms to find a sequence of steps that constitutes a proof. We just need to define a proof problem as follows: INITIAL STATE: The initial knowledge base. ACTIONS: The set of actions consists of all the inference rules applied to all the sentences that match the top half of the inference rule. RESULT: The result of an action is to add the sentence in the bottom half of the inference rule. GOAL: The goal is a state that contains the sentence we are trying to prove. Proof by Resolution ‚Ä¢ The inference rules that we look at are sound, but we have not discussed the question of completeness for the inference algorithms that use them. ‚Ä¢ Search algorithms such as iterative deepening search are complete in the sense that they will find any reachable goal. ‚Ä¢ But if the available inference rules are inadequate, then the goal is not reachable‚Äîno proof exists that uses only those inference rules. ‚Ä¢ For example, if we removed the biconditional elimination rule, the Wumpus World proof would not go through. ‚Ä¢ So, our proof system will not be complete. ‚Ä¢ A single inference rule, RESOLUTION, that yields a complete inference algorithm when coupled with any complete search algorithm. Clause ‚Ä¢ Resolution inference rule works on clauses. ‚Ä¢ A clause is a disjunction of literals. ‚Ä¢ A literal is either an atomic sentence (a positive literal) or a negated atomic sentence (a negative literal) ‚Ä¢ Clause Example: P ‚à® R ‚à® ÔÉòQ ‚à® ÔÉòS ‚Ä¢ A single literal can be viewed as a disjunction of one literal, also known as a unit clause. ‚Ä¢ Resolution is sound and complete for propositional logic Resolution Resolution Inference Rule ‚Ä¢ where li and mj are complementary literals. The resolution takes two clauses and produces a new clause containing all the literals of the two original clauses except the two complementary literals. ‚Ä¢ Conclusion of the rule is called as resolvent. P ‚à® R ‚à® ÔÉòQ ‚à® ÔÉòS T ‚à® Q ‚à® ÔÉòM ------------------------------------------------ P ‚à® R ‚à® ÔÉòS ‚à® T ‚à® ÔÉòM Conjunctive Normal Form ‚Ä¢ The resolution rule applies only to clauses. ‚Ä¢ knowledge bases and queries should consist of clauses. ‚Ä¢ Every sentence of propositional logic is logically equivalent to a conjunction of clauses. ‚Ä¢ A sentence expressed as a conjunction of clauses is said to be in conjunctive normal form (CNF). Converting to CNF 1. Eliminate ‚áî, replacing Œ± ‚áî Œ≤ with (Œ± ‚áí Œ≤) ‚àß (Œ≤ ‚áí Œ±) 2. Eliminate ‚áí, replacing Œ± ‚áí Œ≤ with ÔÉòŒ± ‚à® Œ≤ 3. CNF requires ÔÉò to appear only in literals, so we ‚Äúmove ÔÉò inwards‚Äù by repeated application of the following equivalences 4. Now we have a sentence containing nested ‚àß and ‚à® operators applied to literals. We apply the distributivity law, distributing ‚à® over ‚àß wherever possible. Converting to CNF ‚Ä¢ Example: A Simple Resolution Algorithm for Propositional Logic ‚Ä¢ PL-RESOLVE returns the set of all possible clauses obtained by resolving its two inputs. PL-RESOLUTION Example ‚Ä¢ Partial application of PL-RESOLUTION to a simple inference in the Wumpus world. ¬¨P1,2 is shown to follow from the first four clauses in the top row. Horn Clauses and Definite Clauses ‚Ä¢ The definite clause, which is a disjunction of literals of which exactly one is positive. ‚Ä¢ Horn clause is a disjunction of literals of which at most one is positive. ‚Ä¢ So all definite clauses are Horn clauses, ‚Ä¢ Clauses with no positive literals; these are called goal clauses. ‚Ä¢ Knowledge bases containing only definite clauses are interesting for three reasons: 1. Every definite clause can be written as an implication whose premise is a conjunction of positive literals and whose conclusion is a single positive literal. ‚Ä¢ In Horn form, the premise is called the body and the conclusion is called the head. ‚Ä¢ A sentence consisting of a single positive literal is called a fact. 2. Inference with Horn clauses can be done through the forward chaining and backward chaining algorithms. This type of inference is the basis for logic programming. 3. Deciding entailment with Horn clauses can be done in time that is linear in the size of the knowledge base Horn Clauses and Definite Clauses Definite Clause Examples: P ‚à® ÔÉòR ‚à® ÔÉòS R ‚àß S ‚áí P P P Goal Clause Example: ÔÉòR ‚à® ÔÉòS R ‚àß S ‚áí False or R ‚àß S ‚áí Forward-Chaining Algorithm for Propositional Logic Forward-Chaining Algorithm Example FC Algorithm: Fire any rule whose premises are satisfied in the KB, add its conclusion to the KB, until query is found. A set of Horn clauses. The corresponding AND‚ÄìOR graph. Forward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleForward-Chaining Algorithm ExampleProof of Completeness of FCBackward Chaining ‚Ä¢ Backward chaining is a form of goal-directed reasoning. Backward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleBackward Chaining ExampleResolution Proof Example ÔÉòP ‚à® Q Proof of Q ÔÉòL ‚à® ÔÉòM ‚à® P ÔÉòB ‚à® ÔÉòL ‚à® M Clause1 Clause2 Resolvent ÔÉòA ‚à® ÔÉòP ‚à® L A ÔÉòA ‚à® ÔÉòB ‚à® L ÔÉòB ‚à® L ÔÉòA ‚à® ÔÉòB ‚à® L B ÔÉòB ‚à® L L A B ÔÉòB ‚à® ÔÉòL ‚à® M ÔÉòL ‚à® M B L ÔÉòL ‚à® M M L ÔÉòL ‚à® ÔÉòM ‚à® P ÔÉòM ‚à® P M ÔÉòM ‚à® P P P ÔÉòP ‚à® Q Q Forward vs. Backward ChainingSummary ‚Ä¢ Logical agents apply inference to a knowledge base to derive new information and make decisions ‚Ä¢ Basic concepts of logic: ‚Ä¢ syntax: formal structure of sentences ‚Ä¢ semantics: truth of sentences wrt models ‚Ä¢ entailment: necessary truth of one sentence given another ‚Ä¢ inference: deriving sentences from other sentences ‚Ä¢ soundness: derivations produce only entailed sentences ‚Ä¢ completeness: derivations can produce all entailed sentences ‚Ä¢ Wumpus world requires the ability to represent partial and negated information, reason by cases, etc. ‚Ä¢ Forward, backward chaining are linear-time, complete for Horn clauses ‚Ä¢ Resolution is complete for propositional logic ‚Ä¢ Propositional logic lacks expressive power","libVersion":"0.2.3","langs":""}