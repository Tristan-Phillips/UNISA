{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/SORT/Prev Sem/COS3711/Drive/COS3711/Exam Papers/May_June 2013.pdf","text":"May/June 2013 COS2614 Question 01 QTextStream cin(stdin); QString str = \" \"; QString result = \" \"; if (argc > 1) { cin >> str; } else { str = QInputDialog::getText(0,\"String Reader\", \"Enter a string\"); int Length = str.length(); QString output = QString(\"Input String %1 with a length of %2\") .arg(str).arg(Length); result = QMessageBox::information(0, \"String and Length\", output, QMessageBox::Ok); } Question 02 2.1) Composition relationship. At least one data member of Registration (containing class), i.e. m_Attendee is of type Person (contained class). Instance of Registration is responsible for the destruction of instances of Person. 2.2) #include \"person.h\" class Registration { public: Registration(Person a); virtual double calculateFee()const; virtual QString toString() const; private: Person m_Attendee; QDate m_BookingDate; }; 2.3) Person a (\"M Biyela\", \"mz@utc.co.za\", \"UNISA\"); Registration *r = new Registration(a); 2.4) class StudentRegistration : public Registration { 2.5) double Registration::calculateFee()const { return Registration::calculateFee()/2; } 2.6) Composition relationship. There is a multiplicity of one-to-many relationship, where one RegistrationList contains many Registrations. ). Instance of RegistrationList is responsible for the destruction of instances of Registration. 2.7) class RegistrationList : public QList<Registration*> { 2.8) Guest Registration Student Registration Registration 2.9) double RegistrationList::calculateTotalFee() { double totalFees = 0.0; foreach(Registration *r, *this) { totalFees += r->calculateFee(); } return totalFees; } 2.10) Polymorphism is a mechanism by which a function call is resolved at run time via a pointer to some instance of a class. calculateFee() of all Registrations in the list returned via a pointer to some instance of Registration. Question 03 3.1.1) Required to draw the GUI with the following attributes:  WindowTitle o Product  QLabels o Product description o Product price o Product quantity  QLineEdits o For the above QLabels  QPushButton o Create Product 3.1.2) QLabel QLineEdit QPushButton QMainWindow 3.1.3) void Product::createProduct() { QLineEdit ProductEdit = new QlineEdit(); Qstring productText = productEdit->text(m_Description, m_PricePerItem, m_NoOfItems); Product * p = new ProductGui(\"Bread\", 10.50, 100); } 3.2.1) QActionGroup groups actions of similar kind , together. Sometimes it is useful to group actions together, e.g. if you have Left, Right, Justify, and Centre actions; and only one of these actions should be active at a given time. One way of achieving this would be to group these actions together in an actionGroup. 3.2.2) QMenu * chooseMenu = new QMenu(\"&Choose\", this); chooseMenu->addAction(\"chooseGreen\", \"Green\\tAlt+G\"); chooseMenu->addAction(\"chooseBlue\", \"Blue\\tAlt+B\"); QMainWindow::menuBar()->addMenu(chooseMenu); QObject::connect(chooseMenu, SIGNAL(triggered(QAction*)), this, SLOT(setColor())); Question 04 4.1) Design patterns describe elegant solutions to specific problems in object- oriented software. They capture solutions that have developed and evolved over time. Benefits: Code reusability – design patterns introduces classes that specify places where changes need to be made. Extensibility – measure of how easy it is to add enhancements to an application. One of the standard ways of making code extensible is to provide classes can easily be sub-classed. 4.2) Composite: Every QObject maintains a list of its children. You can make one QObject a child of another by calling setParent(), which automatically adds it to the child list of its parent. Observer: QObject class represents the application of a simplified form of the Observer pattern, particularly in its implementation of signals and slots. 4.3) Simplest way to implement the Monostate pattern is to make all the data members of the class static. In this way, all instances of the class have the same state since they all share the same data. QSettings class allows different instances to have different states within the same program, depending on the arguments provided during construction. To ensure that multiple instances of QSettings share the same state, you must use the same string arguments (for the organisation and application names). QSettings preserves the state of the program from one execution to the next, whereas classic monostate class only maintains one state within one execution of a program. QSettings achieves this by saving its state to a file, and does not use static members. 4.4) When a client needs to call the member functions of other classes, but it is not sure whether such other classes are available or when it would be appropriate to execute such member functions. With this pattern, calls to such member functions are represented by objects themselves, so that they can be executed at the appropriate time. 4.5) The implementation of implicit sharing in Qt containers applies a simplified form of the classic Flyweight pattern. Although it represents a way of saving memory by sharing data that would otherwise be duplicated, there isn’t any explicit data. Examples: QString, QVariant, and QStringList","libVersion":"0.2.3","langs":""}