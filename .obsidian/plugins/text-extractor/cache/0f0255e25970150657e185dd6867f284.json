{"path":"Subjects/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/Guide to Logic Translations.pdf","text":"Guide to First-Order Logic Translations Hi everybody! In last Friday's lecture, we talked about how to translate statements from English into first-order logic. Translating into logic is a skill that takes some practice to get used to, but once you get the hang of it, it's actually not too bad – and honestly it can be a lot of fun! In many ways, learning how to translate into first-order logic is like learning how to program. You've got this crazy set of symbols and terms with precise meanings. ∀ ∃ → ∧ = ∨ P(x) Q(x, y) R(x) S(y) .and the goal is combine them together in a way that says something interesting. ∀x. (P(x) ∨ R(x) → ∃y. (S(y) ∧ Q(x, y)) ) The good news is that, like programming, there are a lot of common patterns that come up time and time again in first- order logic. Once you've gotten the handle on these patterns and the methodology of how to do a translation, you'll find that it's a lot easier to approach logic translations. Let's illustrate this with an analogy. Take a look at this Java code. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } This is a method that takes in an array of integers and returns the sum of the elements in that array. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } Let's focus on this for loop. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } If you've been programming for a while, you can look at this loop and pretty quickly read it as “loop over the elements of an array” loop. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } There's actually a lot going on in this loop, though. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } There's a variable declaration here that makes a new variable that tracks an index. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } .there's an increment operator used to advance that index through the array. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } .a selection statement that picks out a single array element by using the variable we declared in the loop. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } .and a test to see whether we've read everything that relies specifically on using the < operator and not other operators like == or <=. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } When you're first learning to program, code like this can seem really, really complicated, but when you've been programming for a while you don't think about it that much. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } It's just “idiomatic” code – you know what it does by sight even if you don't think too hard about what it means. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } In many ways, first-order logic formulas are the same way. ∀p. (Person(p) → ∃q. (Person(q) ∧ p ≠ q ∧ Loves(p, q) ) ) Here's a first-order logic formula from lecture. It objectively has a lot of symbols strewn throughout it. ∀p. (Person(p) → ∃q. (Person(q) ∧ p ≠ q ∧ Loves(p, q) ) ) However, once you've gotten the hang of the idiomatic first-order logic patterns, you'll see that this actually isn't that bad! ∀p. (Person(p) → ∃q. (Person(q) ∧ p ≠ q ∧ Loves(p, q) ) ) If you tried to build this formula completely from scratch, it would be really challenging. However, if you know the patterns and how to string them together, this is a very natural formula to write. ∀p. (Person(p) → ∃q. (Person(q) ∧ p ≠ q ∧ Loves(p, q) ) ) This guide is designed to teach you what these common patterns are, how to combine them together, and how to use them to translate complicated statements. ∀p. (Person(p) → ∃q. (Person(q) ∧ p ≠ q ∧ Loves(p, q) ) ) Think of it as a crash course in first-order logic programming. ∀p. (Person(p) → ∃q. (Person(q) ∧ p ≠ q ∧ Loves(p, q) ) ) With that said, let's get started! Most of the time, when you're writing statements in first-order logic, you'll be making a statement of the form “every X has property Y” or “some X has property Y.” Statements of these (usually) fall into one of four fundamental types of statements. These four classes of statements are called Aristotelian Forms, since they were first described by Aristotle in his work “Prior Analytics” . though you don't need to know that unless you want to show off at cocktail parties. ^_^ “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” On Wednesday, we saw how to translate these statements into first-order logic. Here's what we came up with. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) In lecture we spent time talking about why gets∀ paired with and why gets paired with . We already talked→ ∃ ∧ in lecture about why this is, so we're not going to review it here. After all, our goal is to see how to use these patterns, not how to derive them. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) However, you absolutely should memorize these patterns. They're like the “loop over an array” for loop pattern in Java, C, or C++ – they come up frequently and you ultimately want to get to the point where you can easily read and write them as a unit. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Now, let's see how we can use these four statements as building blocks for constructing larger statements. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Imagine that we have these predicates available to us to use. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: .and that we want to translate this statement into first-order logic. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Every orange cat is fluffy. Orange(x) Cat(x) Fluffy(x) Available Predicates: Let's see how we can use these formulas to help out our translation. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Every orange cat is fluffy. Orange(x) Cat(x) Fluffy(x) Available Predicates: First, what kind of statement is this? “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Every orange cat is fluffy. Orange(x) Cat(x) Fluffy(x) Available Predicates: It seems to look a lot like this one – we're saying that all objects of one kind (orange cats) are also of another kind (fluffy). “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Every orange cat is fluffy. Orange(x) Cat(x) Fluffy(x) Available Predicates: Based on that. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Every orange cat is fluffy. Orange(x) Cat(x) Fluffy(x) Available Predicates: .we can start adding in a bit of structure to our first-order logic formula. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → x is fluffy) Orange(x) Cat(x) Fluffy(x) Available Predicates: From here, our goal is to keep replacing the remaining English statements in the formula with something in first-order logic that says the same thing. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → x is fluffy) Orange(x) Cat(x) Fluffy(x) Available Predicates: For example, this part of the formula is easy to translate. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → x is fluffy) Orange(x) Cat(x) Fluffy(x) Available Predicates: .because we have a predicate that directly expresses this idea! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → x is fluffy) Orange(x) Cat(x) Fluffy(x) Available Predicates: So let's go and snap that predicate in there. Progress! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: So what about the rest of the formula? How do we express the idea that x is an orange cat? “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: Well, we have two independent predicates – Orange(x) and Cat(x) – that each express a part of the idea. How can we combine them together? “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: Let's begin by seeing how not to do this. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: I'm going to put up our trusty warning indicators to show that what we're about to do is a really bad idea. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ Here's something common we see people do that doesn't work, “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ This superficially looks like it works correctly – it seems like it's saying that x is a cat that's orange. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ The problem is that it's not syntactically valid – it's the sort of mistake that would be a “compiler error” in many languages. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ The reason this doesn't work is that Orange and Cat are predicates – they take in objects and produce either true or false. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ This means that the statement Cat(x) evaluates to either “true” or “false.” Intuitively, it takes in an object and returns a boolean. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ boolean The problem is that Orange expects that it will take in an object and return a boolean – but it's not being provided an object as input! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ boolean This is the first-order logic equivalent of a type error. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ boolean So even though this might at first glance seem right, it's not actually legal. so we're going to have to find some other way of expressing this idea! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(Cat(x)) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: ⚠ ⚠ boolean Let's revert back to what we had before. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: We're trying to express the idea that x is an orange cat. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is an orange cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: If you think about it, that's the same as saying that x is an orange and that x is a cat. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is orange and x is a cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: This is something that's a lot easier to translate into first-order logic. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is orange and x is a cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: The “and,” for example, just becomes a ∧ connective. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (x is orange ∧ x is a cat → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: And, given the predicates we have available, we can translate the left and right halves of that expression directly into first-order logic. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(x) ∧ Cat(x) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: Tada! We're done. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(x) ∧ Cat(x) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: Although this wasn't a particularly complicated example, especially compared to what we did in class the other day, I do think it's helpful to see where it comes from, since we walked through it step-by-step. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Orange(x) ∧ Cat(x) → Fluffy(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: Hopefully that wasn't too bad! Let's go and do another one. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Orange(x) Cat(x) Fluffy(x) Available Predicates: Let's change our available set of predicates so that we can talk about whether something's a corgi, whether something's a person, and whether one thing x loves another thing y. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: With these predicates, let's see how to translate this statement into first-order logic. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: There's a corgi that loves everyone. Again, we can start off by asking what kind of statement this is. What exactly is it that we're talking about here? “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: There's a corgi that loves everyone. Fundamentally, we're saying that somewhere out there in the vast, magical world we live in, there is a corgi that has some specific set of properties. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: There's a corgi that loves everyone. (Specifically, the corgi has the property that it loves everyone!) “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: There's a corgi that loves everyone. That statement looks a lot like this one over here – we're saying that some corgis happen to love everyone. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: There's a corgi that loves everyone. We'll partially translate our statement by using that general pattern. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (x is a corgi ∧ x loves everyone) As before, we'll continue to make incremental progress translating bits and pieces of this formula until we arrive at the final result. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (x is a corgi ∧ x loves everyone) For example, we can directly express the idea that x is a corgi, so let's go do that. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves everyone) Now, we have to think about how to translate the statement “x loves everyone.” “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves everyone) It's not immediately clear how to do this given the four general forms we have above. This means that we need to think a bit before we move on. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves everyone) When translating statements like these, it sometimes helps to introduce variables representing names for things. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves everyone) So, for example, we could rewrite “x loves everyone” to “x loves every person y.” “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves every person y) This is suggesting that we're probably going to want to use one of the templates on the left, since this statement says something about every person y. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves every person y) To see exactly how this matches, we might want to rewrite this blue part to focus more on what we're saying about y. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ x loves every person y) When I was learning how to write, I remember being told that the passive voice should not be used. But sometimes, like in this case, it's actually helpful for exposing the structure of what's going on – every person y is loved by x. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ every person y is loved by x) If we write things this way, it becomes a bit clearer that this statement matches this first general pattern. Let's go and apply it! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ every person y is loved by x) Tada! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (y is a person → y is loved by x) ) You'll notice that I've written this part of the formula on the next line and indented it. It's extremely useful to structure the formula this way – it shows what's nested inside of what and clarifies the scope of the variables involved. While it's not strictly required that you do this in your own translations, we highly recommend it! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (y is a person → y is loved by x) ) Now that we're here, we can do the finishing touches of translating this statement by replacing these blue parts with predicates! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (y is a person → y is loved by x) ) That gives this, our final statement. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) And hey! We're done! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Before we move on, let's pause and look at the formula that we came up with. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Just as we can use the above patterns to translate the original statement into logic, we can use those same patterns to translate this out of logic and back into English (or any language of your choice, really!) “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) This first part is the start of a statement of the form “some Ps are Qs”. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) So we can start our translation like this. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) There is a corgi... that every person is loved by. This part of the statement starts off a statement of the form “all Ps are Qs”. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) There is a corgi... that every person is loved by. .so we can continue our translation like this. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) There is a corgi that every person... is loved by. The last bit is a predicate, so we can just read it off. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) There is a corgi that every person is loved by. We now have a (grammatically awkward) but correct translation of our logic statement back into English. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) There is a corgi that every person is loved by. With a bit of English rewriting, we can get back to our original statement. Nifty! Looks like we got it right! “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) “There is a corgi that loves everyone.” Let's try another translation, just to get some more practice with this skill. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: How might we translate this statement? “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. Before we walk through this one, why don't you try translating this one on your own? Try using a similar thought process to the one we used earlier. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. Did you actually try this? Because if you didn't, you really should. Like, seriously. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. So you translated the statement on your own? Great! Let's do this one together. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. First, we need to start off by thinking about what exactly this statement says. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. This says “if you pick any person, you'll find that there's some corgi that they like.” “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. That's a statement of this type. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: Everybody loves at least one corgi. .so we can make some initial progress like this. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (x is a person → x loves at least one corgi) From here, we can translate the “x is a person” part directly into first-order logic. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → x loves at least one corgi) Now, we have to figure out how to translate that last part. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) x loves at least one corgi ) As before, let's introduce more variables so that we have names for things. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) x loves at least one corgi y ) And, as before, let's fiddle around with the verb structure to make clearer what kind of statement this is. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) there is a corgi y that is loved by x ) From here it's (hopefully) a bit clearer that this is a “some P's are Q's” statement – some corgis happen to be loved by person x. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) there is a corgi y that is loved by x ) We can make more progress on our translation by using that template. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) ∃y. (y is a corgi ∧ y is loved by x) ) At this point we just need to put in the finishing touches and rewrite the blue parts using predicates. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) ∃y. (y is a corgi ∧ y is loved by x) ) .like this! Tada! We're done. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) ∃y. (Corgi(y) ∧ Loves(x, y)) ) It's interesting to put the two statements we translated side-by-side with one another. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) These statements have a lot of similarities, though they're clearly different in a number of ways. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ) ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) One major difference between these two is the order in which the quantifiers appear. The first has them in the order , and the second has them in the order∃∀ ∀∃. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Something we'd really like to stress is that, when we did these translations, we didn't just magically “guess” that we needed those particular quantifiers and that they would be in these orders. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Instead, we started off with the original statement and incrementally translated it top-down, only adding in the quantifiers when we needed them. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) One of the biggest mistakes we see people make when learning first-order logic for the first time is trying to write the whole statement in a single go, adding in quantifiers somewhat randomly to try to get things to work. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Don't do that! It's really, really hard to get right on a first try. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Instead, use the approach we outlined here. Work slowly, going one step at a time, and only adding in quantifiers when you need them. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) If you do, you're a lot less likely to make mistakes. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Going back to our programming analogy, you can write a lot of similar programs that all use if statements and for loops. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) However, you rarely write programs by just throwing a bunch of loops and if statements randomly and hoping that it'll work – because chances are, it won't. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) Instead, you work from the outside in – add in a loop when you need it, and if you need to nest an if statement, then you add it when you need it. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) Corgi(x) Person(x) Loves(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Corgi(y) ∧ Loves(x, y)) ) ∃x. (Corgi(x) ∧ ∀y. (Person(y) → Loves(x, y)) ) So at this point we've gotten some practice with the fundamentals of translation. Pretty much everything else we'll be doing is just more advanced applications of these concepts. To give you a better sense of how these concepts scale up to more complicated examples, let's walk through some more complex statements and how to translate them. Along the way, you'll see a bunch of nifty tricks and insights that will help you out going forward. Let's start off by seeing how to talk about pairs of things. Earlier, we talked about this Java code for iterating over all the elements of an array. private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } Let's imagine we want to write a different piece of code that iterates over all pairs of elements in the array. How might we do that? private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } private int sumOf(int[] elems) { int result = 0; for (int i = 0; i < elems.length; i++) { result += elems[i]; } return result; } Here's one possible option using the venerable “double-for-loop” pattern that you've probably gotten to know and love. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } As with the regular “loop over the elements of an array” loop, the double-for-loop is a programming idiom. Once you've seen it enough times, you just know what it means and don't have to think too much about it. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } One interesting detail about the double-for-loop pattern is that putting one loop inside of another yields a way of iterating over pairs of things. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Turns out, we can adapt this idea to work in first-order logic as well! private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Let's imagine that we have these two predicates, one of which says something is a pancake, and one of which says that two things taste similar. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: How might we translate this statement into first-order logic? private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes taste similar This statement is different from our earlier one because it talks about any possible pair of objects rather than any possible individual object. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes taste similar The good news is that we can translate it in a way that bears a strong resemblance to the above Java code with a double for loop. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes taste similar Specifically, we'll proceed as follows. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes taste similar First, let's introduce some new variables into our English so that we have names for things. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes x and y taste similar We can then rejigger the English statement so that it looks like this. After all, this means the same thing as what we started with. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any pancake x tastes similar to any pancake y Now, we can think back to our Aristotelean form templates that we just got really familiar with and see how to apply them here. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any pancake x tastes similar to any pancake y Since this statement says something to the effect of “any pancake x has some special property.” private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: Any pancake x tastes similar to any pancake y . we can begin translating it into logic like this. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ) x tastes similar to any pancake y ) Now, let's look at that middle portion and see if we can translate it as well. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ) x tastes similar to any pancake y ) Reordering the statement gives us this to work with, which exposes a bit more structure. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ) any pancake y tastes similar to x ) We can then rewrite it like this. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → ( x tastes similar to y ) ) As a final step, we'll translate that innermost portion. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → ( x tastes similar to y ) ) Tada! We're done. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) We now have a statement that says that any two pancakes taste similar. (We can debate whether this is true or not in a separate guide.) private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) Hopefully, you can notice that there's a bit of a parallel to the Java double for loop given above. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) If you think as quantifiers as a sort of “loop over everything” – which isn't that far from the truth – then the program and the formula both say “loop over one thing, then loop over another, then do something with the pair.” private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) So if you ever need to write something where you're dealing with a pair of things, you now know how! You can just write two independent quantifiers like this. private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } private void printPairsIn(int[] elems) { for (int i = 0; i < elems.length; i++) { for (int j = 0; j < elems.length; j++) { System.out.println(elems[i] + \", \" + elems[j]); } } } Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) It turns out, though, that there's another way to express this concept that some people find a bit easier to wrap their head around. For completeness, let's quickly talk about this before moving on. Pancake(x) TasteSimilar(x, y) Available Predicates: Let's go back to our original statement. Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes taste similar As before, let's add in some variables names so that we have ways of keeping our pancakes straight. (Ever gotten your pancakes confused? It's a horrible way to start off your day.) Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes x and y taste similar The idea is that we know that, at this point, we're going to be reasoning about a pair of pancakes, and we're going to reason about them right now. Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes x and y taste similar Therefore, rather than introducing two quantifiers at different points in time, we'll introduce both quantifiers at the same time. Pancake(x) TasteSimilar(x, y) Available Predicates: Any two pancakes x and y taste similar .like this. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (x and y are pancakes → x and y taste similar ) Generally speaking, it is not a good idea to introduce quantifiers for variables all at once, but in the special case of working with pairs, it's perfectly safe. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (x and y are pancakes → x and y taste similar ) So now all we have to do is translate each of the remaining English parts into English. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (x and y are pancakes → x and y taste similar ) Here's one way to do this. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) And we're done! This is a totally valid way to translate our original statement into first-order logic. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) It's interesting, and useful, to put this second translation side-by-side with our original one. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) These statements look pretty different, but they say exactly the same thing. Both are perfectly correct. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) There's actually something pretty cool and pretty deep going on here. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) For now, ignore the quantifiers. Just look at the predicates and how they relate. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) Abstractly, here are the two propositional logic patterns used in the two statements. Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) A → B → C A ∧ B → C These statements are actually logically equivalent to one another. (If you've checked out the Guide to Negating Formulas, you'll see a cool way to derive this!) Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) A → B → C A ∧ B → C≡ This pattern – changing a chain of implications into a single implication and a lot of ANDs and vice-versa – is sometimes called Currying and has applications in functional programming. (This is a total aside. you're not expected to know this.)Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) A → B → C A ∧ B → C≡ Ultimately, what's important is that you understand that both of these statements say exactly the same thing and that you end up comfortable working with both of them. Feel free to use whichever one you like more, but make sure you can quickly interpret both.Pancake(x) TasteSimilar(x, y) Available Predicates: ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) A → B → C A ∧ B → C≡ Let's do another example of where we might want to go and work with pairs. Let's switch our predicates from pancakes to people. Person(x) Knows(x, y) Available Predicates: How might we translate this statement into first-order logic? Person(x) Knows(x, y) Available Predicates: Everyone knows at least two people Well, it seems like there's going to be a pair involved here somewhere, since there's something about “at least two people” here. Person(x) Knows(x, y) Available Predicates: Everyone knows at least two people However, that does not mean that we should immediately start writing out something about a pair of people. Remember – we should only introduce quantifiers when we immediately need them, and it's not clear that we need to start talking about these two people yet. Person(x) Knows(x, y) Available Predicates: Everyone knows at least two people Instead, let's look at the overall structure of this statement and see what it is that we're trying to say. Person(x) Knows(x, y) Available Predicates: Everyone knows at least two people As usual, let's start by introducing some variables so that we can keep track of who we're talking about. Person(x) Knows(x, y) Available Predicates: Every person x knows at least two people y and z We can then partially translate this statement using the techniques we've seen so far. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → x knows at least two people y and z ) Now, we need to express the idea that x knows two people x and y. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → x knows at least two people y and z ) There are a couple of ways to do it, and since we've got time, we'll do it in two different ways. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → x knows at least two people y and z ) Previously, we talked about working with pairs in a universally-quantified setting. Here, though, this particular pair is going to be existentially quantified, since we're saying that there exist two people with certain properties.Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → x knows at least two people y and z ) It might be easier to see that if we rewrite things like this. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → there are two people y and z that x knows ) Thinking back to our double for loop intuition, let's see if we can translate this statement by nesting some existential statements inside of one anothter. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → there are two people y and z that x knows ) Let's begin by rewriting the English like this. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → there is a person y that x knows and a different person z that x knows. ) We can now make some progress translating this. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ there is a different person z that x knows ) ) We can then finish up the rest of this translation by translating this blue part in the middle. But that shouldn't be too bad! Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ there is a different person z that x knows ) ) Here's one way to do it. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z is a different person from y ) ) ) The last step is to say that z and y aren't the same person. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z is a different person from y ) ) ) Even though we didn't explicitly list it in our list of predicates, remember that first-order logic has the equality predicate built into it, so we're always allowed to state that two things are the same or are different. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z is a different person from y ) ) ) Here's one way to do that. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) And hey! We're done! Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) Notice how we're using a pair of nested existential quantifiers to express the idea that there's a pair of people with specific properties. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) Hopefully, this seems familiar, since it's closely related to the analogous doubly-nested quantifiers we saw when talking about pairs of pancakes. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) Just as we could write “any pair of pancakes” in two ways, we can write “some pair of different people” in two ways. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) Here's the alternative approach. Here, we introduce the quantifiers for y and z at the same time, then constrain y and z with preconditions at the same time. Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. ∃z. (Person(y) ∧ Person(z) ∧ z ≠ y ∧ Knows(x, y) ∧ Knows(x, z) ) ) ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) These two approaches are completely equivalent, and both of them are correct. As with quantifying over pairs using , it's a good idea to get comfortable with∀ quantifying over pairs using with both of these∃ approaches.Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. ∃z. (Person(y) ∧ Person(z) ∧ z ≠ y ∧ Knows(x, y) ∧ Knows(x, z) ) ) ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) On Problem Set Two, you'll get to consider a variation on this problem: how would you express the idea that this person x knows exactly two people? That's a trickier proposition, but (hypothetically speaking) you may want to use this basic setup as a starting point.Person(x) Knows(x, y) Available Predicates: ∀x. (Person(x) → ∃y. ∃z. (Person(y) ∧ Person(z) ∧ z ≠ y ∧ Knows(x, y) ∧ Knows(x, z) ) ) ∀x. (Person(x) → ∃y. (Person(y) ∧ Knows(x, y) ∧ ∃z. (Person(z) ∧ Knows(x, z) ∧ z ≠ y) ) ) There's one last topic I'd like to speak about in this guide, and that's what happens when you start talking about sets and set theory in first-order logic. Even if you don't find yourself talking about set theory much in first-order logic, the lessons we'll learn in the course of exploring these sorts of translations are extremely valuable, especially when it comes to checking your work. Let's imagine that we have the set of predicates over to the left. We can say that something is a set, that one thing is an element of something else, that something is an integer, and that something is negative. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: How might we translate this statement into first-order logic?Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: The set of all natural numbers exists This statement is, in many ways, quite different from the ones we've seen so far. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: The set of all natural numbers exists First, the statement doesn't seem to look anything like the Aristotelian forms that we saw earlier. Instead, it just says that something exists. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: The set of all natural numbers exists Second, this statement refers to a specific thing – the set of all natural numbers – and so it's not exactly clear how we'd actually translate this into logic. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: The set of all natural numbers exists If you encounter a statement like this one, which asks you to show that something exists, it often helps to reframe the statement to translate in a different light. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: The set of all natural numbers exists Rather than saying “this specific thing exists.” Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: The set of all natural numbers exists .we can say something like this – that of the sets that are out there, one of them has some special properties. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: There is a set that is the set of all natural numbers This looks a lot more like the forms that we saw earlier, so we can start to translate it into first-order logic using similar techniques. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: There is a set that is the set of all natural numbers Here's one way that we can get this translation started. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) So now we need to find a way to pin down the fact that S is the set of all natural numbers. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) To do so, let's take a few minutes to think about how we might do that. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) If we're going to say that S is the set of all natural numbers, we're probably going to need to find some way to talk about its elements. After all, sets are uniquely defined by their elements, so if we want to say that we have a set with a certain property, we can do so by saying that it has the right elements. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) We're not sure how we're going to do that, but at least we know to keep an eye out for that. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) Next, we need to find a way to say that something is a natural number. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) We have the ability to say that something is an integer or that something is negative, and that might come in handy – the natural numbers are the integers that aren't negative! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) So even if we have no idea where we're going right now, we at least know that (1) we want to say something about the elements of S, and (2) we're going to try to say something about how they're integers that aren't negative. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) Rather than just show you the final answer, let's see how not to do this. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) As before, I'm going to put up the emergency warning flags indicating that we're doing something wrong here. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers )⚠ ⚠ Let's try an initial approach. What does it mean for S to be the set of all natural numbers? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers )⚠ ⚠ Here's a reasonable – but incorrect – way of thinking about it. If you don't see why this is incorrect, don't worry! It's subtle, which is precisely why we're taking the time to go down this route. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S contains all the natural numbers )⚠ ⚠ Now, how might we translate this red statement into first-order logic? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S contains all the natural numbers )⚠ ⚠ Again, let's change up the ordering of the English to expose a bit more structure. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ every natural number is an element of S )⚠ ⚠ This matches one of our nice Aristotelian forms, so we can rewrite it like this. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x is a natural number → x is an element of S ) ) ⚠ ⚠ We can clean up the consequent of that implication (the part that's implied) using the predicates we have available. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x is a natural number → x ∈ S ) ) ⚠ ⚠ As for the antecedent – as we saw earlier, the natural numbers are the integers that aren't negative, so we can say something like this. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x is an integer and x isn't negative → x ∈ S ) ) ⚠ ⚠ We can then translate that into logic like this. Done! .ish Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ So it seems like we're done, but we still have those big red warning signs everywhere. Why doesn't this work? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Well, fundamentally, the way this statement works is by saying “there is some set S that is the set of all natural numbers.” Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Since this is an existentially-quantified statement, it's true if we can find a choice of S that makes it true. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ We've tried to structure this statement with the intent that, specifically, the only choice of S that will work should be , the set of all natural numbers.ℕ Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ If we can make this statement true without choosing S to be the set of all natural numbers, then we haven't actually stated that exists.ℕ Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Unfortunately, it is entirely possible to choose a set besides that makes this formula true.ℕ Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Specifically, what if we choose S to be the set ?ℝ Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Choose S = ℝ. That means that S is definitely a set. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Choose S = ℝ. .and this part of the formula is true: every nonnegative integer is contained in S. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Choose S = ℝ. This means that the statement we've written doesn't say “the set of all natural numbers exists.” It says “there is some set that contains all the natural numbers,” which is similar, but not the same thing. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Choose S = ℝ. Fundamentally, the issue with this translation is that we've put on a set of minimum requirements on S, not a set of exact requirements. As a result, it's possible to make this formula true with a choice of S that has some, but not all, of the properties of . We're going to needℕ to rework the formula to correct that deficiency. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Choose S = ℝ. To do so, let's go back in time to the last point where everything was working correctly. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) ⚠ ⚠ Choose S = ℝ. . which was this point here! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) Okay, so we know that just saying “S contains all the natural numbers” isn't going to work, because other sets besides can also contains all the natural ℝ numbers. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) So what other approaches can we take? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) I'm going to show you another approach that doesn't work, which is a common strategy that we see students take after they realize that the previous approach is incorrect. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) Again, up go the warning signs! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers )⚠ ⚠ Maybe we should think about this differently. The reason that we could get away with choosing for our set ℝ S was that our formula said “S has to have at least these elements.” What if we try a different tactic and say that S has to have at most these elements?Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers )⚠ ⚠ That is, what if we try replacing the previous blue statement with this red statement? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ the only elements of S are natural numbers )⚠ ⚠ This isn't the same thing as before. do you see why? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ the only elements of S are natural numbers )⚠ ⚠ Given that it's different, let's see if we can translate this into first-order logic. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ the only elements of S are natural numbers )⚠ ⚠ Rewording this statement and introducing some variables helps make clearer what we're going to do next. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ every element of S is a natural number )⚠ ⚠ This statement matches one of our forms, so let's go and translate it. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → x is a natural number ) ) ⚠ ⚠ And, since we've seen earlier how to express the idea that x is a natural number. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → x is a natural number ) ) ⚠ ⚠ .we can complete our translation like this. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ So we're done! But is it correct? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ As before, we should check to make sure that the only way this statement can be made true is by picking S to be the set of all natural numbers. Is that really the case? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Unfortunately, no. What if we pick this choice for S? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Choose S = {137}. Well, it's a set. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Choose S = {137}. . and this statement is true: every element of S is indeed a natural number. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Choose S = {137}. So our translation isn't correct – even if there is no set of all natural numbers, we can still make the formula true by picking some other set. in this case, any set that happens to only contain natural numbers. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Choose S = {137}. Interesting, we could have also chosen S = Ø as a counterexample. Then this inner statement happens to be vacuously true because there are no elements of S to speak of! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Choose S = Ø So here are our two attempted translations, each of which isn't correct. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) Interestingly, although each of them is wrong, they're wrong in complementary ways. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) Our first statement was wrong because it let us choose sets that had all the natural numbers, plus some other things that shouldn't be there. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) However, notice that we can't pick an S that misses any natural numbers, because the inside says that all the natural numbers should be there. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) This second statement was incorrect because it let us choose sets S with too few elements, since all it required was that elements that were present were natural numbers. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) However, note that this formula doesn't let us choose a set S that contains anything that's not a natural number, since it requires everything in S to be a natural number. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) In a sense, you can think of our translations this way. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) This first part says “ ℕ ⊆ S,” since it requires that every natural number be in S. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) (ℕ ⊆ S) This second part says S , since it requires that⊆ ℕ every element of S be a natural number. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) (ℕ ⊆ S) (S ⊆ ℕ) In other words, each individual constraint doesn't guarantee that S has to be , but the two statementsℕ collectively would require that S = !ℕSet(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) (ℕ ⊆ S) (S ⊆ ℕ) Let's wind back the clock and see if we can use this to our advantage. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) )⚠ ⚠ ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) (ℕ ⊆ S) (S ⊆ ℕ) So this is the last point where we had the right idea. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) The problem was that in the last two cases, we kept mistranslating this blue statement, which got us the wrong answer. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S is the set of all natural numbers ) So what if we translate it like this? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S ⊆ ℕ ∧ ℕ ⊆ S ) We can then snap in the two parts of the formulas that we built up earlier. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ S ⊆ ℕ ∧ ℕ ⊆ S ) .like this. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) And hey! This actually works! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) If we choose an S that contains something it shouldn't, this part will catch it. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) .and if we pick an S that misses something it was supposed to contain, this part catches it! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) So in that sense, we have a working formula! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) As a final step, though, we can clean this up a bit. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) Look at these two implications. Notice anything about them? Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) Except for the fact that the antecedent and the consequent have been swapped, they're the same! Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) And hey. don't we have a special symbol to say that A B and that B A?→ → Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) So as a final step, let's take this formula and rewrite it using the biconditional connective. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ∧ ∀x. (Integer(x) ∧ ¬Negative(x) → x ∈ S ) ) That ends up looking like this. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S ↔ Integer(x) ∧ ¬Negative(x)) ) This single biconditional contains everything we need. Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S ↔ Integer(x) ∧ ¬Negative(x)) ) In the forwards direction, it says “everything in S needs to be a natural number.” Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S ↔ Integer(x) ∧ ¬Negative(x)) ) In the reverse direction, it says “every natural number needs to be in S.” Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S ↔ Integer(x) ∧ ¬Negative(x)) ) Generally, if you're trying to write a statement in first-order logic that says that some set exists (which, hypothetically speaking, might happen sometime soon), you might find yourself using a biconditional to pin down the elements of the set. It's an easy way to say “the set contains precisely these elements.”Set(x) x ∈ y Integer(x) Negative(x) Available Predicates: ∃S. (Set(S) ∧ ∀x. (x ∈ S ↔ Integer(x) ∧ ¬Negative(x)) ) Wow! We've covered a ton in this guide. Before we wrap up, let's briefly recap the major themes and ideas from what we've seen here. First, we saw these four basic statement building blocks. These are idiomatic expressions in first-order logic – the same way that a for loop over an array is idiomatic in most programming languages – and are extremely useful in assembling more complex statements. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) We saw that translating things incrementally, going one step at a time and judiciously rewriting the English, is a reliable way to end up with good translations. Plus, it sidesteps a ton of classes of mistakes. “All Ps are Qs.” “Some Ps are Qs.” “No Ps are Qs.” “Some Ps aren't Qs.” ∀x. (P(x) → Q(x)) ∃x. (P(x) ∧ Q(x)) ∀x. (P(x) → ¬Q(x)) ∃x. (P(x) ∧ ¬Q(x)) ∀x. (Person(x) → ) x loves at least one corgi y ) We saw how to quantify over pairs of things, and saw that there are multiple ways of doing so. ∀x. ∀y. (Pancake(x) ∧ Pancake(y) → TasteSimilar(x, y) ) ∀x. (Pancake(x) → ∀y. (Pancake(y) → TasteSimilar(x, y) ) ) We saw that we can check our work by plugging in specific values and seeing whether they work they way we expect them to work. ∃S. (Set(S) ∧ ∀x. (x ∈ S → Integer(x) ∧ ¬Negative(x) ) ) ⚠ ⚠ Choose S = {137}. And, finally, we saw where biconditionals come from, especially in set theory contexts. ∃S. (Set(S) ∧ ∀x. (x ∈ S ↔ Integer(x) ∧ ¬Negative(x)) ) Hope this helps! Please feel free to ask questions if you have them. Did you find this useful? If so, let us know! We can go and make more guides like these.","libVersion":"0.2.3","langs":""}