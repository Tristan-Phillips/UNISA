{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/Past Exams/COS3711 Exam+Solutions 2015-2019.pdf","text":"May/Jun 2015 Efficient and elegant solutions to common problems in object-oriented programming, they promoted code reuse and extensibility. Common used programming practices/solutions to recurring programming problems, that is efficient and ineffective. A software architectural pattern for implementing user interfaces. It divides a given software application three types of objects, the model, the view and the controller objects. The model is the application object, the view is the screen representation, and the controller defines communication between user and view In MVC, controller defines the way in which the UI reacts to user input. In Qt, the view and the controller are combined, and in place of a controller is a delegate, which controls rendering, and editing of individual items. QAbstractListModel provides abstract model that can be sublassed to create one-dimensional list models, it provides a more specialized interface than QAbstractItemModel, and not suitable for use with tree views. QStandardItemModel provides a generic model for storing custom data or standard Qt data types, it provides an item-based approach to working with a model. this model can be used directly. class PlantListModel : public QAbstractListModel { ....}; QVariant PlantListModel::data(const QModelIndex &index, int role)const { if(index.row() >= strngList.size()) return QVariant(); if(role == Qt::DisplayRole/FontRole) return stringList.at(index.row()); else return QVariant(); } returns item flags for the given index. base class implementation returns a combination of flags that enables the item(ItemIsEnabled),and allow it to be selected(ItemIsSelectable) Reflective Programming is that you reflect upon/inspect the code at run time. Which means ýou are not aware of the actual name of the method or the field in the class but you can enumerate what are the fields or methods available for a given class and then invoke which ever you want to from the enumerated list. When the thing you are checking is not a simple regular expression, but something that requires advance calculation. QValidator::State Checker::validate(QString &s, int &) { return req.validate(s); } Any non-whitespace character followed by either a 1 or a 2. E.g. ‘f2’, ‘y1’, i1’ Solo* s; s = Solo::instance(); So that there can be only once instance of such a fuction in the whole program, this enables it to keep tract of(maintain) the Solo instances created. The constructor of Solo is private, can only be accessed by friends of the class. Make the class that is to subclass solo a friend class of solo. for every instance of Solo that should be created, there should be a static data member to hold that instance. 5 instances will require 5 static data members. To backup, and restore a state of an object. The memento and the originator yes, if the caretaker gets serialized, it will be capable. class FooMemento { public: private: friend class Foo; FooMement(); QStringList getState() const; void setState(QStringList s); QStringList state; }; QStringList FooMemento::getState() const { return state; } void FooMemento::setState(QStringList s) { state = s; } it provides a XML writer with a simple streaming API. QDomDocument SAX QXmlStreamReader class ClassA : public QObject I assume that classA has a changed() signal connect(&objectA, &classA::changed(), this, &Client:display(QString)); connect(&tA, &QThread::started(), &objectA, &classA:doWork()); tA.start(); Oct/Nov 2015 class Register : public QObject { Q_OBJECT public: Register(); void newRegister(QString str); signal: setRegister(QString); private: QString m_Register; }; Register.cpp void Register::newRegister(QString s) { emit setRegister(m_register); } class Output : public QObject { Q_OBJECT public: explicit Output(QObject* parent = 0); public slots: void outputRegister(QString s); }; main.cpp QObejct::connect(&r, &Register::setRegister(QString), &o, &Output::outputRegister()); new method 20(0[0-9](1[0-5][/-.](0[1-9])|(1[0-2]) //shape class class Shape : public QObject { Q_OBJECT public: void setLength(int l); int getLenth() const; }; Circle class Circle : public QObject { Q_OBJECT Q_PROPERTY(double circumference READ getCircumference WRITE setCircumference) public: void setCircumference(double c); private: double circumference; }; QString WhatAmI(QObject* obj) { const QMetaObject* meta = obj->metaObject(); QString name = meta->className(); return name; } yes, it sets dynamic a dynamic property for Shape class, property name is \"length\", and value of property is 5. Yes, because this object inherits from a QObject and can therefore perform like a MetaObject, this property is not predefined, but it is assigned to the object as a dynamic property Meta-object describes the structure of another objects. it contains meta-information about Qt objects. it inspects objects at runtime. 2. QListView* listView = new QListView(); 3. listView->setModel(model); 7. model->index(row); 8. model->setData(index,data); 9. dataChanged(QModelIndex,QModelIndex) It is used to locate data in the data model QListWidget request that data be stored in the actual widget, and presents a default view of list. This means that it is not flexible , to create custom views to represents data in many forms, as you would do when using many views along with a QStringListModel. To reduce inter-dependencies between objects, so failures in client do not impact other concrete subclasses. Decoupling enables us to attach more subclasses to the InputField without having to change code in the client class. Solo* Solo::instance(); OR Solo* s; s = Solo::instance(); This line is trying to call a private constructor. This is to ensure that there is only one instance of Solo in the whole application, if there need to be more than one, the data member would not be static, or there would be more than one static data member of Solo pointer. to free up memory when Solo instance goes out of scope. Also this is to ensure that there is no instance of Solo running in the program. Structural pattern You want to build an simple interface that reads data from external sources, i.e a database, also within this interface, you want to eliminate the dependency of the client program in the implementation of the subsystem. Serializer is used if the state of a object is to be output to a Device, ie a File, or Console window. Memento is used if the state of an object is to be stored using a list, in a separate object called a memento. It holds the memento for the originator, and the originator So that a originator can be able to create its own memento. 1. The originator requests a memento by calling its SetMemento(Memento m) function, 2. this function will call the getState() function of the memento, which returns a list of states(values of data members) of the originator. 3. The data member values are extracted from list, and assigned to their respective data members in the Originator class(restore). after these steps, the originator is now restored to its previous state. DOM parser load full XML file in memory and creates a tree representation of XML document, while SAX is an event based XML parser and doesn't load whole XML document into memory. QThread* t = new QThread(); RandomWalk* r = new RandomWalk(); r->moverToThread(); connect(&t, &QThread:started(), &r, &RandomWalk::startWalking()); connect(&t, &QThread:finished(), this, &RandomWalk::complete()); t->start(\"RandomWalk\"); May/Jun 2016 class GuestList : public QObject* one->setParent(guestlist); two->setParent(guestlist); class Guest : public QObject { Q_OBJECT Q_PROPERTY(QString name READ getName WRITE setName) public: Guest(QString Name= \"Unknown\"); ~Guest(); QString getName() const; void setName(QString n); private: QString name; } class ConferenceGuest : public Guest { Q_OBJECT public: ConferenceGuest(QString name); }; Memento design pattern is being implemented, the state of a class is saved to a QStringlist. serializer pattern saves an object's state to a QIODevice such as a file, or console. yes it is posible. line 36: one->setProperty(\"meal\",\"vegetarian\"); it is good coding practice, guestList is a QObject, which means it applies Qt child management facility. When guestList is deleted, all its children will be deleted QList<QStandardItem*> list; QStandardItem* guestName = new QStandardItem(String(\"Calvin)); QStandardItem* arrival = new QStandardItem(); QStandardItem* stay = new QStarndarditem(); arrival->setData(QVariant(\"2016/05/08\"),Qt::DisplayRole()); stay->setData(QVariant(4),Qt::DisplayRole()); list << guestname << arrival << stay; currentGuests->appendRow(list); No, it would not work. we have to set the table views model to the QStandardItemModel created. guestGUI->setModel(currentGuests); QRegExp nameFilter(\"([A-Z]([a-z]+)\\\\s{1})+\"); QRegExpValidator nameValidator = new QRegExpValidator(namefilter); guestName->setValidator(nameValidator); The model which in this instance is QStandardItemModel communicates with the source of data, being a list of QStandardItems, providing and interface for the view to access data at the source. The view being QTabelView obtains model indexes from the QStandardltemModel, indexes reference to data in the list. By supplying indexes to the model, the QTabelView can retrieve items of data from the list. The delegate renders the items of data, when items is edited, the delegate communicates with the model directly using model indexes. The representation of data is separated from the data source, thus same data can be used of different views. QTableWidget requires that the data be stored on the actual widget, while QStandardItem can be used as a repository for standard Qt data types. items are stored in QStandarditem, and it can be used with views to represent data in many forms. QDomDocument doc(\"MyXml\"); QDomElement root = doc.createElement(\"guests\"); doc.appendChild(root); for(int i = 0; i<meta->propertyCount();i++) { const QMetaProperty mprop = meta->property(i); QString name = mprop.name().toString(); QString value = mprop.read(g).toString(); QDomElement tag = doc.createElement(\"guest\"); root.appendChild(tag); tag.setAttribute(\"type\",type); QDomElement name = doc.createElement(name); tag.appedChild(name); QDomText text = doc.createTextNode(value); name.appendChild(text); } QDomDocument. QXMLStreamWriter is a better alternative, it provides a simple streaming API, and operates on a QIODevice. This approach is not systemic, and therefor error prone, and can produce some inconsistencies. class GuestToXml { public: void write(Guest *g); QDomDocument getDoc() const; static GuestToXml* getInstance(); private: GuestToXml(); static GuestToXml* onlyInstance; QDomDocument doc; QDomElement rootElement; -Firstly we move the constructor an make it private. This way an instance of this object cannot be created by simply calling the constructor. This also stops multiple objects being created. -Secondly we add a private data member which is static and a pointer. This is initialized to NULL in the implementation file. Making this variable static, means it is accessibly on a global scope. This member variable is essentially a pointer to the current object. -Thirdly, in order to use this variable which is static, we need a static function. This static function is made public and will be called by the client code(as a form of creating an instance of the object). However in the implementation of this function, there will exist an if statement that checks if this static variable is NULL or not. In the event it is NULL an instance is created, however if not then it merely returns the pointer to that static variable. This way there can never exist more than one instance of this object. class SearchForGuest : public QObject { Q_OBJECT public: SearchForGuest(QList<Guest*> list, QString name); public slots: QList<Guest*> find(); signals: void found(Guest*); private: QList<Guest*> localist; QString localName; }; 16. QThread t = new QThread(); 17. SearchForGuest* sfg = new SearchForGuest(pastGuests, \"El Maestro\") 18. sfg.moveToThread(&t); 19. connect(&sfg, &SearchForGuest::found(Guest), this, handleFound(Guest*)); 20. connect(&t, &QThread::started(), &sfg, &SearchForGuest::find(); 21. t->start() May/Jun 2017 class ServiceProvider : public QObject { Q_PROPERTY(QString website READ getWebsite WRITE setWebsite) .......... }; Q_OBJECT marco - enables meta-object features, and signals and slots. Q_PROPERTY marco - enables the use of QT property system, using setters and getters. name,ProviderA yes, it will dynamically set the property website, to the value www.spA.so.za item-based models are data repository, they store actual data in the default model provided. QTableWidget provides an item-based table view with a default model. Items in the table view are provided by QTableWidgetItem. QStandardItemModel provides an item-based approach to wroking with the model and with a view to display. this model can be used with different views. QTableWidget, it is able to use same data on different views without having to copy the data. With data been in a standard display, it is not suitable for use on modified models. The Observer pattern uses the view and controller portion of the MVC pattern to make function calls using an event-driven approach. This maintains separation between data storage and display. An Example would be if a button is clicked on a GUI. Qt implements the necessary inter- object communication using the connect SIGNALS to SLOTS function. class Contract : public QObject { Q_OBJECT public: Contract(); Virtual float getPrice() = 0; protected: QString number; float price; }; Contract* ContractFactory::createContract(QString choice) { if(choice == \"prepaid\") return new MyPrepaid(); if(choice == \"contract\") return new MyContract(); } void ContractList::add(Contract* c) { const QMetaObject* meta = c->metaobject(); QString className = meta->className(); if (className == “MyPrepaid”) listP.append(c); if (className == “MyContract”) listC.append(c); } QProcess *p = new QProcess(); p->start(“processContracts.exe”); we add the signals: output(Qstring s); slots: handleOutput(); void Manage::runProcessContracts() { QProcess *p = new QProcess(); connect(&p, &p::readyReadStandardOutput, this, &Manage::handleOutput()); connect(&p, &p::finished(int), this, &QProcess::done()); p->start(“processContracts.exe”); } void Manage::handleOutput() { QByteArray bytes = p.readAllStandardOutput(); emit output(QString(bytes)); } QStringlist list1 = list.at(i).split(\"#\"); QString number = list1.at(0); QString message = list1.at(1); writer.writeStartElement(\"contract\"); writer.writeAttribute(\"number\",QString::number(number)); writer.writeTextElement(\"message\", message); writer.writeEndElement(); class XMLWriter : public QObject { public: XMLWiter(); ~XMLWriter(); public slots: void run(); signals: void returnItem(QString); }; Serializer design pattern. 1. Serializer pattern backups an object's state without its knowledge into a QIODevice such as a file or console. 2. Th serializer pattern uses two classes each responsible for either writing to a file, or reading from a file, while the memento design pattern uses one class to manage all actions. May/Jun 2018 class Film : public QObject { Q_OBJECT Q_PROPERTY(QString title READ getTitle WRITE setTitle) Q_PROPERTY( int duration READ getDuration WRITE setDuration) public: void setTitle(QString s); void setDuration(int); QSting getTitle() const; int getDuration() const; protected: QString title; int duration; }; Film* f = new Film(); f->setProperty(\"title\",\"007\"); QVariant v = f->property(\"title\"); the ability to inspect a objects property at runtime, and even manipulate them. QVariant stores most common data types known QT. A QVariant can be converted to the common data type using the convert() function. atshsta22sdjsjd, a word containing at least one digit. 232.9 OR 23, strings that start with at least one digit, and can end zero or more digits. In Qt m/v architecture, the view and the controller are merged to form model/view. m/v uses delegates to render and edit the model, based on changes made in the view. QAbstractTableModel: An abstract class used for tabular data. You must subclass this class to use it. QStandardItemModel: A concrete model that can be used for both tabular / hierarchical data (trees). QTableView: A model-based view class used with a model to display data. QTableWidget: An item-based model that combines the functionality of both model and view. Also called convenience class. QAbstractProxyModel: Base class for proxy models used for sorting. makes the view, and model children of mainwindow. ui->tableview->setModel(tableModel); line 13 retrieves data with the specified role, in the specified index, and converts to float. line 14 sets data at specified index, to the specified value(using format), and role. QColor colour = Qt::white; int row = itemSelected->row(); if (runTime >= 2) colour = Qt::yellow; for (int col=0; col<model->columnCount(); col++) model->item(row, col)-> setBackground(colour); it is used when you have a set of of different algorithms, such as outputting to different sources. we want to choose algorithms interchangeably, with minimal amount of change in the program. class ActorList { public: ActorList(QList<Actor> list); Virtual void Output() = 0; private: QList<Actor> data; } Singleton pattern. such that it is the only instance pointer of ActorList class. ActorList* ActorList::getActorList() { if(!actorList == NULL) return actorList; else return actorList = new ActorList(); } QDomElement tag = doc.creatElement(\"Actor\"); root.appendChild(tag); QDomElement element = doc.creatElement(\"Name\"); tag.appendChild(element); QDomText text = doc.createTextNode(name); element.appendChild(text); QString xml = doc.toString(); class WriteToFile : public QObject { Q_OBJECT public: WriteToFile(QStringList t, QString f); public slots: bool write() const; signals: void written(QString); private: QStringList textToWrite; Qstring filename; }; bool WriteToFile::write() const { QFile file(f); if (file.open(QIODevice::WriteOnly)) { QTextStream write(&file); foreach(QString str,t); { write <<str<<\"\\n\"; file.close(); emit written(str); QThread::sleep(3); } QThread::currentThread()->quit(); } } //main QThread thread = new QThread; WriteToFile writer = new WriteToFile(t,fn); connect(thread, SIGNAL(started()),writer,SLOT(write())); old method connect(&thread,&thread::started,&writer, &WriteToFile::write); // new method thread->start(); Oct/Nov 2018 it does not change any data members of Counter. It handles the display of output, which should be handled by a separate class. it handles the computation of its data member, to increment or decrement. class Counter : public QObject { Q_OBJECT public: Counter(int i); void increment(int i); void decrement(int i); signals: void changed(QString) private: int num; }; class Output : public QObject { Q_OBJECT public: explicit Output(QObject* parent =0); public slots: void displayState(QString message); }; void Client::doWork() { QObject::connect(&sp, &Counter::changed(QString),&output, &Output::displayState(QString)); Counter* counter = new Counter(); DisplayOutput* display = new DisplayOutput(); connect(&counter, &Counter::changed(QString), &display, &DisplayOutput::displayState(QString)); class Counter : public QObject { Q_OBJECT Q_PROPERTY(int num READ getNum WRITE setNum) public: void setNum(int n); int getNum()const; private: int num; }; Counter* c = new Counter(); c->setProperty(\"propertyName\", \"value\"); similarity: both properties can be discovered at runtime. difference: dynamic properties can are not known by the metaobject, and are created at runtime. The model is the application object. The view is the screen representation of the model. The controller defines a way the user interface reacts to user input. data(const QModelIndex &index, int role) returns a Qvariant value, for the specified role, from the item with the given index form the model. if( role == Qt::DisplayRole) { int col = index.column(); int row = index.row(); if(col==0) return name.at(row); if(col==1) return number.at(row); if(col==2) return performace.at(row); return QVariant(); } ui->myTableView->setItemDelegateForColumn(2, new MyDelegate(this)); provides display and editing facilities for data items of a model. so that the object can be restored to that internal state later. Originator - an object that knows how to save its self. memento - the object that i swriten and read by an originator. Caretaker - the object that holds the memento for the originator, like a controller object, it knows when to backup, and restore the originator. class StaffMemento { public: private: friend class Staff; StaffMemento(); setState(QStringList s); QStringList getState() const; }; StaffMemento Staff::createBackup() { QStringList state; state << name << age; StaffMemento backup; backup.setState(state); return backup; } a) The client is decoupled from the subclasses and is now using the factory method to create instances of subclasses. b)The client is able to switch between classes depending on its needs at a point in time. c) the clients needs only to provide a type of class to create, it doesnt know of the classes it creates. May/Jun 2019 restricted access,the class Shape will not be able to be instantiated by other classes, only friend classes of Shape will have access to the constructor. Shape class doesnt become an Abstract class. getShapeNumber can have a default implementation. class Shape : public QObject { Q_OBJECT Q_PROPERTY(int nextNum READ getShapeNumber) public: int getShapeNumber()const; private: int nextNum; } class Circle : public QObject { Q_OBJECT Q_PROPERTY(double radius READ getRadius) public: int getRadius()const; private: double radius; } foreach(Shape* s, list) { const QMetaObject* meta = s->metaObject(); QString class = meta->className(); cout << class << \": \"; for(int i =1, i < meta->propertyCount(); i++) { const QMetaProperty prop = meta->property(i); QString propname = prop.name().toString(); QString value = prop.read(s).toString(); cout << propname << \" = \" << value; if(i<propertyCount() - 1) cout<<\",\"; } } class ShapesToXml { public: ShapesToXml(); bool write(QList* list, QString fileName); private: QXmlStreamWriter writer; writer.writeStartElement(\"shapeList); ------------------------------------------------- (Shape* shape, sl) --------------------------------------------------- const QMetaObejct* meta = shape->metaobject(); for(int i=0; i<meta.propertyCount();i++) { const QMetaProperty mprop = meta.property(i); Qstring class =meta->className(); QString value = mprop.read(shape).toString(); } -------------------------------------------------- writer.writeStartElement(\"shape\"); writer.writeAttribute(\"type\",class); writer.writeTextElement(\"shapenumber\", value); writer.writeEndElement(); ------------------------------------------------- writer.writeEndElement(); i) data that is stored in a data source and represented by a model, allows that the model interface can be modified or extended to add extra features, without need to modify the data source. ii)It is easy to maintain either a view of a data model separately without having to maintain both, if there is a bug in the view, only the view needs maintenance. iii)Data models enables that the same data can be used on multiple views, without having to modify the data source so that it may be used on different view, the model code can be reused for custom views of data. Roles are used my views to indicate to th emodel whcihc type of data it needs. bool vehicleModel::setData(const QModelIndex &index, const QVariant &value, int role) { if (index.isValid() && role==Qt::EditRole) { int col = index.column(); int row = index.row(); switch (col) { case 0: vList.at(row)->setModel(value.toString()); break; case 1: vList.at(row)->setMake(value.toString()); break; case 2: vList.at(row)->setYear(value.toInt()); break; case 3: vList.at(row)->setVIN(value.toString()); break; default: return false; } emit dataChanged(index, index); return true; } return false; } QRegExp vinNum; vinNum.setPattern( class VehicleFactory { public: Vehicle* create(char category); } Vehicle* VehicleFactory::create(char category) const { switch(category) case 'm': return new Motorcyle(); break; case 'p': return new PassangerVehicle(); break; case 'c': return new CommercialVehicle(); break; default: return NULL; } create function needs to be passed a Qvariant variable as an argument, instead of a char, then QVariant is then converted into a string. Vehicle* vehicleFactory::create(QVariant v) const { QString value = v.toString(); switch(value) case 'm': return new Motorcyle(); break; case 'sedan': return new Sedan(); break; case 'hatchback': return new Hatchback(); break; case 'c': return new CommercialVehicle(); break; default: return NULL; There is only one factory method in this scenario, therefore an Abstract factory class it is of no use. it is implemented if there must be exactly one instance of a class. not comply: the constructor must be private or protected. comply: the instance variable is private. SingleA instace1 = new SingleA(); SingleA instance2 = new SingleA(); if(instance1.name == instance2.name) return true; class SingleB { public: ~SingleB() static SingleB* getInstance() const; private: SingleB(); static SingleB* instance; } SingleB s = new SingleB(); if(s == SingleB::getinstance()) return true; GOOD LUCK!!!","libVersion":"0.2.3","langs":""}