{"path":"Subjects/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Materials/solution-self-assess-2018.pdf","text":"Solutions to the self-assessment questions COS3751 1 State spaces 1.1 Representation of the initial state A non-graphical state representation for the empty board could be a 3 × 3-array, where every row, column and diagonal represents a row, column and diagonal respectively on the board. Each cell of the array may contain either x, or o or a dash sign (empty cell). Let I be the initial state. It is represented as follows: I =   - - - - - - - - -   For the sake of completeness, each state of the game should also contain the mark of the player whose turn is next. The game assumes Player X to play ﬁrst. So the initial state is represented as a pair: I′ = (I, x). 1.2 State representation after the ﬁrst move Let M1 be the state of the board after one move. It is represented as follows. M1 =   - - - - x - - - -   After this move, it is Player O’s turn to play. So the full state at this stage is: M1′ = (M1, o). 1.3 Search tree After four moves, the game reaches the state: M4′ = (M4, x), where: M4 =   - - x - x - o o -   The complete search tree for the next two plies of the game is given in Figure 1. 1 x x o o x x o o x x x x o o x x x o o x x x o o x x x o o x x x o o o x x x o o o o x x x o o o x x x o o x x o o o x o x x o o x o x x o o x x o x o o x x x x o o o x x x o o o o x x x o o x x o x o o x x x o o o o x x x o o o x x x o o x o x x o o x x x o o o x o x x o o x x x o o o x x o x o o Figure 1: Search tree for two plies of the Tic-Tac-Toe game 2 Constraint Satisfaction Problem 2.1 Variables and domains Choosing variables and domains in CSP problems can be somewhat tricky. You have to consider the goal you are working towards. However, the best place to start is normally to regard the limited resource as the starting point for the domains (and thus the thing needing the resource as the variables). Another way of thinking about this is to say the items we are contending for would be the domains, the items that would like to make use of them (contend for them) would be the variables. In the given problem, time slots are limited: the sessions are contending for their use – so we regard the time slots as the domain. Therefore the variables are the seven sessions. - Let X be the set of variables. X = {PC, AC, EC, RT, MC, BM, OT}. - Let DX be the domain for the variables. DX = {T1, T2, . . . , Tn}. Here n is the total number of available times slots and each Ti (for i = 1, 2, . . . , n) represents a time slot. All the variables have the same domain. 2.2 Constraint graph The nodes of the graph represent the variables, thus the conference sessions. The con- straints of the graph represent the conﬂicts of interest about the diﬀerent topics. So we 2 draw an edge between two sessions if they have a conﬂicting area of interest, as shown in the graph in Figure 2. Figure 2: The constraint graph for the scheduling problem 2.3 Solution to the problem We would like to determine the smallest number of time slots to accommodate the diﬀerent sessions without conﬂicts of interest. This can be phrased as follows: divide the nodes of the graph into sets so that no nodes with an edge between them belong to the same set. This amounts to ﬁnding an assignment of colours to the nodes of the graph so that if there is an edge between nodes u and v, then the colours assigned to nodes u and v are diﬀerent. In other words, if we can colour the constraint graph with the fewest number of colours possible, we can schedule the conference as follows: schedule all sessions that has the same colour at the same time. Since we know that two nodes cannot be linked by an edge if they have the same colour, this means that we cannot have any scheduling conﬂicts. In Figure 3, we have a colouring of the constraint graph that satisﬁes the requirement we set. That is, no two nodes that are linked by an edge have the same colour. In this colouring, we have used four colours, which means we can hold the conference sessions in four time slots so that there are no conﬂicts. Speciﬁcally we have: • PC = T1, (blue) • RT = OT = T2, (yellow) • MC = AC = T3, (red) • EC = BM = T4, (green). Note that the order of assigning time slots to the sessions does not really matter as long as sessions with diﬀerent colours are held at diﬀerent times. 3 First Order Logic Translation of the given sentences to First Order Logic (FOL): . ∀x[(¬smoke(x) ∧ party(x)) =⇒ happy(x)] . ∀y[single(y) =⇒ party(y)] 3 Figure 3: A colouring of the constraint graph for the scheduling problem . single(john) ∧ ¬smoke(john) . ∀z[happy(z) =⇒ exciting(z)] It is important to standardize the variables (to use diﬀerent variable names) to avoid confusion when dropping the universal quantiﬁers. The above statements are converted as follows to clause form: . smoke(x) ∨ ¬party(x) ∨ happy(x) . ¬single(y) ∨ party(y) . single(john) . ¬smoke(john) . ¬happy(z) ∨ exciting(z) Note that universal quantiﬁers have been dropped because all variables were universally quantiﬁed. Skolem functions are introduced only to remove existential quantiﬁers. (See section 9.5 Resolution of R&N.) We would like to use resolution refutation to show that someone has an exciting life. So the goal is ∃w, exciting(w). At this stage it is important to keep the existential quantiﬁer of the goal. We will deal with quantiﬁers after the goal is negated. In this case if skolemisation is applied to the goal before it is negated, the meaning of the goal will be changed and the resolution refutation proof will be incorrect. The negation of the goal is ¬[∃w, exciting(w)] ≡ ∀w, ¬exciting(w). We may drop the universal quantiﬁer in the negated goal. We now use resolution refutation. We resolve the premises together with the negated goal until the empty clause is generated. 4 1. smoke(x) ∨ ¬party(x) ∨ happy(x) (assumption) 2. ¬single(y) ∨ party(y) (assumption) 3. single(john) (assumption) 4. ¬smoke(john) (assumption) 5. ¬happy(z) ∨ exciting(z) (assumption) 6. ¬exciting(w) (negated goal) 7. ¬happy(z) (5&6, z/w) 8. smoke(x) ∨ ¬party(x) (1&7, x/z) 9. ¬single(y) ∨ smoke(y) (2&8, y/x) 10. ¬single(john) (4&9, john/y) 11. [ ] (3&10) 4 Machine Learning For the collection of data, S, if we look at the decision attribute ‘sunburn’, then the number of positive outcomes is 3 (three people got burnt by the sun). The number of negative outcomes is 5 (ﬁve people did not get sunburn). Therefore S = [3+, 5−]. The positive proportion in terms of the outcome sunburn is p+ = 3/8, whilst the negative proportion is p− = 5/8. Entropy(S) = −p+ log2(p+) − p− log2(p−) = −(3/8) log2(3/8) − (5/8) log2(5/8) = 0.95443 There are three values for ‘hair’, namely: blonde, brown, red. In order to calculate the Information Gain (IG) of the attribute ‘hair’, we have to consider the diﬀerent subsets of the attribute ‘hair’ and calculate their respective entropy. blonde: Sblonde = [2+, 2−]. Entropy(Sblonde) = −(2/4)log2(2/4) − (2/4)log2(2/4) = 1. brown: Sbrown = [0+, 3−]. The entropy is zero if no information is gained by observing a certain attribute’s value. Thus: Entropy(Sbrown) = 0. red: Sred = [1+, 0−]. Per deﬁnition: Entropy(Sred) = 0. Therefore: IG(S, hair) = 0.95443 − [(4/8) ∗ 1 + (3/8) ∗ 0 + (1/8) ∗ 0] = 0.45443. 5","libVersion":"0.2.3","langs":""}