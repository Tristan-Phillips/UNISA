{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Notes/ConcurrencyinQt-Ch17-02.pdf","text":"Concurrency in Qt Applications Ynon Perek Basic ConceptsThreads Key Ideas ● Having more than one \"production line\" for our program. ● Each production line is called a Thread. ● Useful for CPU intensive apps - we can use more hardware ● Easy to code, hard to debug Threads Key Ideas “Now that the best and the brightest have spent a decade building and debugging threading frameworks in Java and .NET, it’s increasingly starting to look like threading is a bad idea; don’t go there” -- Leading Sun developer Tim Bray Async Programming Key Ideas ● Keeping your production line busy all the time. ● Useful for I/O intensive apps - no need to deal with threads. ● Main theme: \"Let me know when this operation is done\". ● Async Programming is not Threads - but it can turn out very useful. We'll talk about that on the Networking Module Agenda ● Easy Threading with QtConcurrent ● Filtering and Mapping in Threads ● Fine Grained Threading with QThread ● Synchronizing Threads ● Thread Dependent Data Structures The Four Horsemen of the Apocalypse ● QProcess ● QtConcurrent::Run ● QRunnable Objects ● QThread Threading The Easy WayQtConcurrency Namespace ● QtConcurrency provides us the functions to use threads a-la Java ● (almost) No synchronization or locking is required ● Best for sending tasks to secondary threads and not worry about it. ● Starts to be a pain when we need to monitor progress QtConcurrent Namespace ● A task is defined as any class derived from QRunnable ● QThreadPool is used to start a task in its own thread ● We can poll the ThreadPool for status, but in general we use custom progress events ● Just like Java ● Remember to include <QtCore> QtConcurrent Example - The Task class CountTask : public QRunnable { public : CountTask( QString id, int start, int end, int step): iId ( id ), iStart ( start ), iEnd( end ), iStep ( step ) { } void run() { for (int i=iStart; i < iEnd; i+= iStep ) { qDebug() << iId << \" i = \" << i; } } private : int iStart, iEnd, iStep; QString iId; }; QtConcurrent Example - main int main( int argc, char *argv[]) { QCoreApplication a(argc, argv); for ( int i= 0 ; i < NUM_THREADS; ++i ) { CountTask *c = new CountTask( QString (\"task[%1]\" ).arg(i), 0 , 100 , 1 ); // QThreadPool takes ownership and // will delete c at the end QThreadPool ::globalInstance()->start(c); } return a.exec(); } QtConcurrent - Staying In Control ● Controlling a secondary task requires some way of communicating with it ● Usually, we'll use a volatile bool as a kill switch ● Here's an example CounterTask.h #ifndef COUNTERTASK_H #define COUNTERTASK_H #include <QRunnable> class CounterTask : public QRunnable { public : CounterTask( int start, int end, volatile bool *stop); void run(); private : int iStart, iEnd; volatile bool *iStop; }; #endif // COUNTERTASK_H CounterTask.cpp #include \"countertask.h\" #include <QtCore> #include <QWaitCondition> CounterTask::CounterTask( int start, int end, volatile bool *stop): iStart(start), iEnd(end), iStop( stop ) { // blank } void CounterTask::run() { for ( int i=iStart; i < iEnd; ++i ) { if ( *iStop ) { break; } QWaitCondition sleep; QMutex *mutex = new QMutex (); sleep.wait(mutex, 1000 ); delete mutex; qDebug() << \"i = \" << i << QThread::currentThread(); } } Starting a task void MainWindow::startATask() { CounterTask *t = new CounterTask( 0 , 100 , &iStop); QThreadPool ::globalInstance()->start(t); } Stopping all active tasks void MainWindow::stopTasks() { iStop = true; QThreadPool ::globalInstance()->waitForDone(); } QtConcurrent - Reporting Progress ● Reporting progress means activating a method from worker thread in the manager thread ● Keep in mind the old UI rule: We Can Only Update the GUI from the GUI Thread QtConcurrent Reporting Progress ● Using QMetaObject::invokeMethod can resolve the issue ● This call will run a slot from another object by its name ● It uses the same mechanism as emitting a signal, but does not require a QObject ● Let's See how it works ! The Task void CounterTask::run() { QMetaObject::invokeMethod( iMaster, \"progress\" , Qt:: QueuedConnection, Q_ARG(int , i)); } Qt Concurrent Takeaways ● Qt manages threads for us using QThreadPool ● To enter the pool, we must have a QRunnable at hand ● Thread communication is done using shared variables ● Use a volatile bool as a kill switch ● Use QMetaObject::invoke to mark progress ● Consider using Signals/Slots when data needs to be passed around between threads QtConcurrent Processing Multiple Values ● Qt Concurrent provides methods to process multiple values in a Map/Reduce Style. ● Best use when a lot of work is needed, but you wish Qt will take care of splitting it to threads. ● Works best when the work can be modeled as a collection of items in a sequence. Map/Reduce Basic ConceptMap/Reduce Basic Concept ● Take a list of values ● Do some sort of calculations on them - Concurrently, of course. ● Enjoy the result Map/Reduce Basic Concept ● What can you do ? ○ Map: Take a list and return a list of the same size ○ Filter: Take a list and return a (probably) smaller list ○ Reduce the resulting elements to a single one But When will this end ?Map/Reduce Basic Concept ● In the functional functions of Qt Concurrent, we use QFuture and QFutureWatcher to communicate with the task. ● This works in the same signal/slot mechanism we already know and love. Map/Reduce Example - Primes bool isPrime(int k) { for ( int i= 2 ; i < k/2 ; ++i ) { if ( k % i == 0 ) return false; } return true; } Primes - The header class MainWindow : public QMainWindow { ... private slots : void hasAllThePrimes(); void start(); void foundAnotherOne( int where); private : Ui::MainWindow *ui; QFutureWatcher< int > iWatcher; }; #endif Primes - The cpp file void MainWindow::start() { QList< int > allNumbers; for ( int i= 1000000 ; i < 9000000 ; ++i ) { allNumbers << i; } QFuture< int > primes = QtConcurrent ::filtered(allNumbers, isPrime); iWatcher.setFuture(primes); QObject::connect(&iWatcher, SIGNAL(finished()), this, SLOT(hasAllThePrimes())); QObject::connect(&iWatcher, SIGNAL(resultReadyAt( int )), this, SLOT(foundAnotherOne( int ))); } Primes - The cpp file (partial) void MainWindow::hasAllThePrimes() { qDebug() << \"Found them all. total = \" << iWatcher.future().resultCount(); qDebug() << \"the third is: \" << iWatcher.resultAt(2 ); } Primes - The cpp file (partial) void MainWindow::foundAnotherOne( int where) { qDebug() << \"Another Prime: \" << iWatcher.resultAt(where); } Map/Reduce TakeAways ● Use the functional paradigms in QtConcurrency when: ○ There are many items to work on ○ It's easy to tell what needs to be done ○ It's tedious to split the work yourself ● Map returns a list of the results ● Filter returns a list of the originals that match a criteria ● Reduce works on the matches to return a single value QtConcurrency Takeaways ● Use QFuture and QFutureWatcher to work with future values ● Note that not all QFuture calculations can be cancelled. Only map, filter and reduce support cancellations. Introducing QThreadQThread ● A QObject derived class representing a thread in an OS independent way ● Represents a separate thread of control within the program. ● A QThread start() method will create a new thread, start the run() method, and finish the thread when the run() ends ● QThread works best for start-and-report background tasks Creating A Thread class MyThread : public QThread { Q_OBJECT protected: void run(); }; void MyThread::run() { ... } Creating A Thread ● Once a Thread class is defined, start a new thread by calling start() ● The start() method returns immediately, and normal code execution continues. ● Some time in the future the run() method is invoked from the new thread ● default run() implementation starts an event loop Threads And Event Loops ● Each QObject \"lives\" in a specific thread's event loop. All its slots are called in the context of its thread. ● Use QObject::moveToThread to change an object's thread affinity (which means its event loop). ● If a QObject has a parent, It is not possible to change its thread affinity. ● Qt uses a Message Queue to pass signals between threads. Synchronizing Threads ● In Qt, The following mechanisms are available: ○ QMutex ○ QReadWriteLock ○ QSemaphore ○ QWaitCondition QMutex ● Provides a Mutual exclusive lock for shared data ● Methods: ○ lock ○ tryLock ○ unlock ● If the mutex is already locked, any other thread trying to lock it will sleep until it is unlocked ● When the mutex is unlocked, a single thread that is blocked on lock will be released and start its work QReadWriteLock ● Works a bit like QMutex but differentiates read and write operations ● Allows multiple readers and a single writer, and prevents starvation ● Methods: ○ lockForRead ○ lockForWrite ○ try... ○ unlock QSemaphore ● A general purpose counting semaphore ● Methods: ○ acquire(int n=1) ○ release(int n=1) ○ int available() QSemaphore Example QSemaphore sem(5); // sem. available() == 5 sem.acquire (3); // sem. available() == 2 sem.acquire (2); // sem. available() == 0 sem.release(5); // sem.available() == 5 sem.release(5); // sem.available() == 10 sem.tryAcquire (1); // sem. available() == 9, returns true sem.tryAcquire (250); // sem. available() == 9, returns false QWaitCondition ● A general purpose signal/wait mechanism ● Allows a thread to tell another thread that a condition has been met, and it is now safe to resume work ● Perfect for Producer/Consumer ● Methods: ○ wait ○ wakeAll() ○ wakeOne() QObject And Threading ● The child of a QObject must always be created in the thread where the parent was created. This implies, among other things, that you should never pass the QThread object (this) as the parent of an object created in the thread (since the QThread object itself was created in another thread). ● QObject And Threading ● Event driven objects may only be used in a single thread. Specifically, this applies to the timer mechanism and the network module . For example, you cannot start a timer or connect a socket in a thread that is not the object's thread . QObject And Threading ● You must ensure that all objects created in a thread are deleted before you delete the QThread . This can be done easily by creating the objects on the stack in your run() implementation. ● all threads must be cleaned up using wait() before the program ends. Threading And Signals & Slots ● When making a Signal/Slot connection, you are allowed to choose the connection type. Here are the available types: ○ Auto (default): If the signal was made from the same thread, this is the same as direct. If it's from another thread, this is the same as queued ○ Direct: The slot is invoked immediately in the sender's thread ○ Queued: The slot is invoked when control is returned to the Event loop of the receiver thread, within the context of the receiver. When To Use What Task: Run one method within another thread and quit the thread when the method is finished. Solution: ● Write a QRunnable and use the global thread pool When To Use What Task: Operations are to be performed on all items of a container. Processing should be performed using all available cores. Solution: Use the map/filter/reduce set and let Qt do the rest. When To Use What Task A long running operation has to be put in another thread. During the course of processing, status information should be sent to the GUI thread. Solution Use a QThread derived class and emit the relevant signals Task Have an object living in another thread and let it perform different tasks upon request. This means communication to and from the worker thread is required. Solution Write a QObject derived class and have it implement the required signals and slots. Move it to another thread's event loop.","libVersion":"0.2.3","langs":""}