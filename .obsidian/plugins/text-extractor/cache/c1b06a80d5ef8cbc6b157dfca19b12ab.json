{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/Theory/ModelAndViewsCh13.pdf","text":"Model/View Tutorial Every UI developer should know about ModelView programming and the goal of this tutorial is to provide you with an easily understandable introduction to this topic. Table, list and tree widgets are components frequently used in GUIs. There are 2 different ways how these widgets can access their data. The traditional way involves widgets which include internal containers for storing data. This approach is very intuitive, however, in many non-trivial applications, it leads to data synchronization issues. The second approach is model/view programming, in which widgets do not maintain internal data containers. They access external data through a standardized interface and therefore avoid data duplication. This may seem complicated at first, but once you take a closer look, it is not only easy to grasp, but the many benefits of model/view programming also become clearer. In the process, we will learn about some basic technologies provided by Qt, such as: • The difference between standard and model/view widgets • Adapters betweeen forms and models • Developing a simple model/view application • Predefined models • Intermediate topics such as: o Tree views o Selection o Delegates o Debugging with model test You will also learn whether your new application can be written easier with model/view programming or if classic widgets will work just as well. This tutorial includes example code for you to edit and integrate into your project. 1. Introduction Model/View is a technology used to separate data from views in widgets that handle data sets. Standard widgets are not designed for separating data from views and this is why Qt 4 has two different types of widgets. Both types of widgets look the same, but they interact with data differently. Standard widgets use data that is part of the widget. View classes operate on external data (the model) 1.1 Standard Widgets Let's have a closer look at a standard table widget. A table widget is a 2D array of the data elements that the user can change. The table widget can be integrated into a program flow by reading and writing the data elements that the table widget provides. This method is very intuitive and useful in many applications, but displaying and editing a database table with a standard table widget can be problematic. Two copies of the data have to be coordinated: one outside the widget; one inside the widget. The developer is responsible for synchronizing both versions. Besides this, the tight coupling of presentation and data makes it harder to write unit tests. 1.2 Model/View to the Rescue Model/view stepped up to provide a solution that uses a more versatile architecture. Model/view eliminates the data consistency problems that may occur with standard widgets. Model/view also makes it easier to use more than one view of the same data because one model can be passed on to many views. The most important difference is that model/view widgets do not store data behind the table cells. In fact, they operate directly from your data. Since view classes do not know your data's structure, you need to provide a wrapper to make your data conform to the QAbstractItemModel interface. A view uses this interface to read from and write to your data. Any instance of a class that implements QAbstractItemModel is said to be a model. Once the view receives a pointer to a model, it will read and display its content and be its editor. 1.3 Overview of the Model/View Widgets Here is an overview of the model/view widgets and their corresponding standard widgets. Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QListWidget QListView Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QTableWidget QTableView QTreeWidget QTreeView Widget Standard Widget (an item based convenience class) Model/View View Class (for use with external data) QColumnView shows a tree as a hierarchy of lists QComboBox can work as both a view class and also as a traditional widget 1.4 Using Adapters between Forms and Models Having adapters between forms and models can come in handy. We can edit data stored in tables directly from within the table itself, but it's much more comfortable to edit data in text fields. There is no direct model/view counterpart that separates data and views for widgets that operate on one value (QLineEdit, QCheckBox ...) instead of a dataset, so we need an adapter in order to connect the form to the source of data. QDataWidgetMapper is a great solution because it maps form widgets to a table row and makes it very easy to build forms for database tables. Another example of an adapter is QCompleter. Qt has QCompleter for providing auto-completions in Qt widgets such as QComboBox and, as shown below, QLineEdit. QCompleter uses a model as its data source. 2. A Simple Model/View Application If you want to develop a model/view application, where should you start? We recommend starting with a simple example and extending it step-by-step. This makes understanding the architecture a lot easier. Trying to understand the model/view architecture in detail before invoking the IDE has proven to be less convenient for many developers. It is substantially easier to start with a simple model/view application that has demo data. Give it a try! Simply replace the data in the examples below with your own. Below are 7 very simple and independent applications that show different sides of model/view programming. 2.1 A Read Only Table We start with an application that uses a QTableView to show data. We will add editing capabilities later. // main.cpp #include <QtGui/QApplication> #include <QtGui/QTableView> #include \"mymodel.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); QTableView tableView; MyModel myModel(0); tableView.setModel( &myModel ); tableView.show(); return a.exec(); } We have the usual main() function: Here is the interesting part: We create an instance of MyModel and use tableView.setModel(&myModel); to pass a pointer of it to to tableView. tableView will invoke the methods of the pointer it has received to find out two things: • How many rows and columns should be displayed. • What content should be printed into each cell. The model needs some code to respond to this. We have a table data set, so let's start with QAbstractTableModel since it is easier to use than the more general QAbstractItemModel. // mymodel.h #include <QAbstractTableModel> class MyModel : public QAbstractTableModel { Q_OBJECT public: MyModel(QObject *parent); int rowCount(const QModelIndex &parent = QModelIndex()) const ; int columnCount(const QModelIndex &parent = QModelIndex()) const; QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const; }; QAbstractTableModel requires the implementation of three abstract methods. // mymodel.cpp #include \"mymodel.h\" MyModel::MyModel(QObject *parent) :QAbstractTableModel(parent) { } int MyModel::rowCount(const QModelIndex & /*parent*/) const { return 2; } int MyModel::columnCount(const QModelIndex & /*parent*/) const { return 3; } QVariant MyModel::data(const QModelIndex &index, int role) const { if (role == Qt::DisplayRole) { return QString(\"Row%1, Column%2\") .arg(index.row() + 1) .arg(index.column() +1); } return QVariant(); } The number of rows and columns is provided by MyModel::rowCount() and MyModel::columnCount(). When the view has to know what the cell's text is, it calls the method MyModel::data(). Row and column information is specified with parameter index and the role is set to Qt::DisplayRole. Other roles are covered in the next section. In our example, the data that should be displayed is generated. In a real application, MyModel would have a member called MyData, which serves as the target for all reading and writing operations. This small example demonstrates the passive nature of a model. The model does not know when it will be used or which data is needed. It simply provides data each time the view requests it. What happens when the model's data needs to be changed? How does the view realize that data has changed and needs to be read again? The model has to emit a signal that indicates what range of cells has changed. This will be demonstrated in section 2.3. 2.2 Extending the Read Only Example with Roles In addition to controlling what text the view displays, the model also controls the text's appearance. When we slightly change the model, we get the following result: In fact, nothing except for the data() method needs to be changed to set fonts, background colour, alignment and a checkbox. Below is the data() method that produces the result shown above. Remember to include the directives #include <qdebug.h> #include <qfont.h> and #include <qbrush.h> in mymodel.cpp. The difference is that this time we use parameter int role to return different pieces of information depending on its value. // mymodel.cpp QVariant MyModel::data(const QModelIndex &index, int role) const { int row = index.row(); int col = index.column(); // generate a log message when this method gets called qDebug() << QString(\"row %1, col%2, role %3\") .arg(row).arg(col).arg(role); switch(role){ case Qt::DisplayRole: if (row == 0 && col == 1) return QString(\"<--left\"); if (row == 1 && col == 1) return QString(\"right-->\"); return QString(\"Row%1, Column%2\") .arg(row + 1) .arg(col +1); break; case Qt::FontRole: if (row == 0 && col == 0) //change font only for cell(0,0) { QFont boldFont; boldFont.setBold(true); return boldFont; } break; case Qt::BackgroundRole: if (row == 1 && col == 2) //change background only for cell(1,2) { QBrush redBackground(Qt::red); return redBackground; } break; case Qt::TextAlignmentRole: if (row == 1 && col == 1) //change text alignment only for cell(1,1) { return Qt::AlignRight + Qt::AlignVCenter; } break; case Qt::CheckStateRole: if (row == 1 && col == 0) //add a checkbox to cell(1,0) { return Qt::Checked; } } return QVariant(); } Each formatting property will be requested from the model with a separate call to the data() method. The role parameter is used to let the model know which property is being requested: enum Qt::ItemDataRole Meaning Type Qt::DisplayRole text QString Qt::FontRole font QFont BackgroundRole brush for the background of the cell QBrush Qt::TextAlignmentRole text alignment enum Qt::AlignmentFlag enum Qt::ItemDataRole Meaning Type Qt::CheckStateRole suppresses checkboxes with QVariant(), sets checkboxes with Qt::Checked or Qt::Unchecked enum Qt::ItemDataRole Now we need to determine how using a separated model impacts the application's performance, so let's trace how often the view calls the data() method. In order to track how often the view calls the model, we have put a debug statement in the data() method, which logs onto the error output stream. In our small example, data() will be called 42 times. Each time you move the cursor over the field, data() will be called again — 7 times for each cell. That's why it is important to make sure that your data is available when data() is invoked and expensive lookup operations are cached. 2.3 A Clock inside a Table Cell We still have a read only table, but this time the content changes every second because we are showing the current time. QVariant MyModel::data(const QModelIndex &index, int role) const { int row = index.row(); int col = index.column(); if (role == Qt::DisplayRole) { if (row == 0 && col == 0) { return QTime::currentTime().toString(); } } return QVariant(); } Something is missing to make the clock tick. We need to tell the view every second that the time has changed and that it needs to be read again. We do this with a timer. In the constructor, we set its interval to 1 second and connect its timeout signal. MyModel::MyModel(QObject *parent) :QAbstractTableModel(parent) { // selectedCell = 0; timer = new QTimer(this); timer->setInterval(1000); connect(timer, SIGNAL(timeout()) , this, SLOT(timerHit())); timer->start(); } Here is the corresponding slot: void MyModel::timerHit() { //we identify the top left cell QModelIndex topLeft = createIndex(0,0); //emit a signal to make the view reread identified data emit dataChanged(topLeft, topLeft); } We ask the view to read the data in the top left cell again by emitting the dataChanged() signal. Note that we did not explicitly connect the dataChanged() signal to the view. This happened automatically when we calledsetModel(). 2.4 Setting up Headers for Columns and Rows Headers can be hidden via a view method: tableView->verticalHeader()->hide(); The header content, however, is set via the model, so we re-implement the headerData() method: QVariant MyModel::headerData(int section, Qt::Orientation orientation, int role) const { if (role == Qt::DisplayRole) { if (orientation == Qt::Horizontal) { switch (section) { case 0: return QString(\"first\"); case 1: return QString(\"second\"); case 2: return QString(\"third\"); } } } return QVariant(); } Note that method headerData() also has a parameter role which has the same meaning as inMyModel::data(). 2.5 The Minimal Editing Example In this example, we are going to build an application that automatically populates a window title with content by repeating values entered into table cells. To be able to access the window title easily we put theQTableView in a QMainWindow. The model decides whether editing capabilities are available. We only have to modify the model in order for the available editing capabilities to be enabled. This is done by reimplementing the following virtual methods: setData() and flags(). // mymodel.h #include <QAbstractTableModel> #include <QString> const int COLS= 3; const int ROWS= 2; class MyModel : public QAbstractTableModel { Q_OBJECT public: MyModel(QObject *parent); int rowCount(const QModelIndex &parent = QModelIndex()) const ; int columnCount(const QModelIndex &parent = QModelIndex()) const; QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const; bool setData(const QModelIndex & index, const QVariant & value, int role = Qt::EditRole); Qt::ItemFlags flags(const QModelIndex & index) const ; private: QString m_gridData[ROWS][COLS]; //holds text entered into QTableView signals: void editCompleted(const QString &); }; We use the two-dimensional array QString m_gridData to store our data. This makes m_gridData the core of MyModel. The rest of MyModel acts like a wrapper and adapts m_gridData to theQAbstractItemModel interface. We have also introduced the editCompleted() signal, which makes it possible to transfer the modified text to the window title. bool MyModel::setData(const QModelIndex & index, const QVariant & value, int role) { if (role == Qt::EditRole) { //save value from editor to member m_gridData m_gridData[index.row()][index.column()] = value.toString(); //for presentation purposes only: build and emit a joined string QString result; for(int row= 0; row < ROWS; row++) { for(int col= 0; col < COLS; col++) { result += m_gridData[row][col] + \" \"; } } emit editCompleted( result ); } return true; } setData() will be called each time the user edits a cell. The index parameter tells us which field has been edited and value provides the result of the editing process. The role will always be set to Qt::EditRole because our cells only contain text. If a checkbox were present and user permissions are set to allow the checkbox to be selected, calls would also be made with the role set to Qt::CheckStateRole. Qt::ItemFlags MyModel::flags(const QModelIndex & /*index*/) const { return Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsEnabled ; } Various properties of a cell can be adjusted with flags(). Returning Qt::ItemIsSelectable | Qt::ItemIsEditable | Qt::ItemIsEnabled is enough to show an editor that a cell can be selected. If editing one cell modifies more data than the data in that particular cell, the model must emit adataChanged() signal in order for the data that has been changed to be read. 3. Intermediate Topics 3.1 TreeView You can convert the example above into an application with a tree view. Simply replace QTableView with QTreeView, which results in a read/write tree. No changes have to be made to the model. The tree won't have any hierarchies because there aren't any hierarchies in the model itself. QListView, QTableView and QTreeView all use a model abstraction, which is a merged list, table and tree. This makes it possible to use several different types of view classes from the same model. This is how our example model looks so far: We want to present a real tree. We have wrapped our data in the examples above in order to make a model. This time we use QStandardItemModel, which is a container for hierarchical data that also implements QAbstractItemModel. To show a tree, QStandardItemModel must be populated withQStandardItems, which are able to hold all the standard properties of items like text, fonts, checkboxes or brushes. //mainwindow.h #ifndef MAINWINDOW_H #define MAINWINDOW_H #include <QMainWindow> QT_BEGIN_NAMESPACE // QT_BEGIN_NAMESPACE / QT_END_NAMESPACE are not needed in Qt user code class QTreeView; //forward declarations class QStandardItemModel; class QStandardItem; QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT private: QTreeView *treeView; QStandardItemModel *standardModel; QList<QStandardItem *> prepareRow( const QString &first, const QString &second, const QString &third ); public: MainWindow(QWidget *parent = 0); }; #endif // MAINWINDOW_H // modelview.cpp #include <QTreeView> #include <QStandardItemModel> #include <QStandardItem> #include \"mainwindow.h\" const int ROWS = 2; const int COLUMNS = 3; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { treeView = new QTreeView(this); setCentralWidget(treeView); standardModel = new QStandardItemModel ; QList<QStandardItem *> preparedRow =prepareRow(\"first\", \"second\", \"third\"); QStandardItem *item = standardModel->invisibleRootItem(); // adding a row to the invisible root item produces a root element item->appendRow(preparedRow); QList<QStandardItem *> secondRow =prepareRow(\"111\", \"222\", \"333\"); // adding a row to an item starts a subtree preparedRow.first()->appendRow(secondRow); treeView->setModel(standardModel); treeView->expandAll(); } QList<QStandardItem *> MainWindow::prepareRow(const QString &first, const QString &second, const QString &third) { QList<QStandardItem *> rowItems; rowItems << new QStandardItem(first); rowItems << new QStandardItem(second); rowItems << new QStandardItem(third); return rowItems; } To run your application, update the main.cpp file as follows. #include <QApplication> #include <QTreeView> #include \"mymodel.h\" #include \"mainwindow.h\" int main(int argc, char *argv[]) { QApplication a(argc, argv); //QTableView tableView; //MyModel myModel(0); //tableView.setModel(&myModel ); //tableView.show(); MainWindow w; w.show(); return a.exec(); } We simply instantiate a QStandardItemModel and add a couple of QStandardItems to the constructor. We can then make a hierarchical data structure because a QStandardItem can hold other QStandardItems. Nodes are collapsed and expanded within the view. 3.2 Working with Selections We want to access a selected item's content in order to output it into the window title together with the hierarchy level. So let's create a couple of items: update the modelview.cpp to the following code, build and run your application. #include <QTreeView> #include <QStandardItemModel> #include <QItemSelectionModel> #include \"mainwindow.h\" MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { treeView = new QTreeView(this); setCentralWidget(treeView); standardModel = new QStandardItemModel ; QStandardItem *rootNode = standardModel->invisibleRootItem(); //defining a couple of items QStandardItem *americaItem = new QStandardItem(\"America\"); QStandardItem *mexicoItem = new QStandardItem(\"Canada\"); QStandardItem *usaItem = new QStandardItem(\"USA\"); QStandardItem *bostonItem = new QStandardItem(\"Boston\"); QStandardItem *europeItem = new QStandardItem(\"Europe\"); QStandardItem *italyItem = new QStandardItem(\"Italy\"); QStandardItem *romeItem = new QStandardItem(\"Rome\"); QStandardItem *veronaItem = new QStandardItem(\"Verona\"); //building up the hierarchy rootNode-> appendRow(americaItem); rootNode-> appendRow(europeItem); americaItem-> appendRow(mexicoItem); americaItem-> appendRow(usaItem); usaItem-> appendRow(bostonItem); europeItem-> appendRow(italyItem); italyItem-> appendRow(romeItem); italyItem-> appendRow(veronaItem); //register the model treeView->setModel(standardModel); treeView->expandAll(); //selection changes shall trigger a slot QItemSelectionModel *selectionModel= treeView->selectionModel(); connect(selectionModel, SIGNAL(selectionChanged (const QItemSelection &, const QItemSelection &)), this, SLOT(selectionChangedSlot(const QItemSelection &, const QItemSelection &))); } Views manage selections within a separate selection model, which can be retrieved with the selectionModel() method. We retrieve the selection Model in order to connect a slot to its selectionChanged() signal. void MainWindow::selectionChangedSlot(const QItemSelection & /*newSelection*/, const QItemSelection & /*oldSelection*/) { //get the text of the selected item const QModelIndex index = treeView->selectionModel()->currentIndex(); QString selectedText = index.data(Qt::DisplayRole).toString(); //find out the hierarchy level of the selected item int hierarchyLevel=1; QModelIndex seekRoot = index; while(seekRoot.parent() != QModelIndex()) { seekRoot = seekRoot.parent(); hierarchyLevel++; } QString showString = QString(\"%1, Level %2\").arg(selectedText) .arg(hierarchyLevel); setWindowTitle(showString); } We get the model index that corresponds to the selection by calling treeView->selectionModel()->currentIndex() and we get the field's string by using the model index. Then we just calculate the item's hierarchyLevel. Top level items do not have parents and the parent() method will return a default constructed QModelIndex(). This is why we use the parent() method to iterate to the top level while counting the steps performed during iteration. The selection model (as shown above) can be retrieved, but it can also be set withQAbstractItemView::setSelectionModel. This is how it's possible to have 3 view classes with synchronised selections because only one instance of a selection model is used. To share a selection model between 3 views use selectionModel() and assign the result to the second and third view class withsetSelectionModel().","libVersion":"0.2.3","langs":""}