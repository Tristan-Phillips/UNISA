{"path":"UNISA/98906 - BSc Science in Computing/COS3751 - Techniques of Artificial Intelligence/Telegram Notes/Solution 1 - 2019.pdf","text":"BAR CODE Deﬁne Tomorrow. university of south africa Tutorial Letter 201/1/2019 Techniques of Artiﬁcial Intelligence COS3751 Semester 1 Department of Computer Science School of Computing CONTENTS Model solutions for Assignment 01 COS3751/201/1/2019 ASSIGNMENT 1 Solution Total Marks: 62 Unique Assignment Number: 741522 Study material: Chapters 1 through 4. You may skip sections 4.2 and 4.5. Important: When we use the phrase ‘deﬁne’ (particularly in Question 2), we are looking for a formal deﬁnition using some form of formal notation, and not simply an English description or deﬁnition. For example: ‘Deﬁne the initial state for an agent in Johannesburg’. Answer: In(Johannesburg). ‘Deﬁne the actions available to this agent given that the agent simply moves between major metropolitan areas’. Answer: Actions(In(Johannesburg)) = {Go(Bloemontein), Go(Durban), . . . }. When we want an English deﬁnition we will explicitly ask for it. Question 1: 8 Marks (1.1) The road safety of children at school road-crossings are extremely important1. Consider a agent that controls the booms at a school-crossing. When there are children that want to cross the road, the agent should lower the booms, so that the road traﬃc stops, and the children can cross safely. The agent should not close the boom when there are vehicles in the crossing, or raise the booms when there are children in the crossing. The agent thus has sensors to detect children on the side of the road, and sensors to detect if there are objects in the crossing. Answer the following questions. Justify your answer in each case. (a) (2)Is the environment fully, or partially observable? It is important to consider the environment in terms of what the agent needs in order to complete its task. It is also important to realise that this is simply a toy problem and we need not concern ourselves with issues outside of the described environment. The agent need not be aware of children other than those who need to cross the road, i.e. those that are in the immediate vicinity of the crossing. It also does not need to track all cars, just those that may be in the crossing when the booms should be lowered. Given all the above, this may be considered enough to make the environment fully observable. (b) (2)Is the environment competitive, or cooperative? There is only one agent in operation. It is thus a single-agent environment which is by deﬁnition neither competitive, nor cooperative. (c) (2)Is the environment static, or dynamic? The environment may change while the agent is deliberating, for example, more children may arrive wishing to cross the road, while the agent is determining if it is 1https://www.arrivealive.co.za/Scholar-Patrol-and-Road-Safety 2 COS3751/201/1/2019 safe to lift the boom, or while other students are still crossing. Changing environments like this are dynamic. (1.2) (2)Is this an example of a model-based, or reﬂex-based agent? Justify your answer. This is a simple reﬂex-based agent. It can determine exactly how to behave by simple polling of its sensors. Question 2: 10 Marks One night three friends come to a rickety bridge spanning a torrential river. They want to cross it, but do not trust the bridge to carry all of them at the same time. They decide to cross the bridge two at a time. To make matters worse, the bridge is in such disrepair that some of the wooden planks that make up the bridge have fallen away leaving gaping holes – making the crossing very dangerous. Luckily the three friends (Andile, Bob, and Charlize) have a battery powered torch with them. They decide that the people crossing the bridge will take the torch with them. Bob, however, hurt his ankle while walking in the dark, and he can only manage a slow limp across the bridge. The friends are worried that the torch may run out of power, before they all manage to cross, and decide to ﬁgure out how to get everyone across in the least amount of time. By their estimate, Andile can cover the length of the bridge in 12 minutes, Bob can do so in 19, and Charlize in 13. Suppose the state is represented as a set S ⊆ {Andile, Bob, Charlize, T orch}. If pi ∈ S, then pi is on the right-hand side of the bridge, otherwise they (it) are on the left-hand side. T orch represents the torch and, as with the people, if it is present in S, then it means the torch is on the right-hand side of the bridge, otherwise it is on the left-hand side. As people (and the torch) move from one side of the bridge to the other, they are added/removed to the set representing the current state. For example, suppose we start with S = {Andile, Bob, Charlize, T orch} and Andile walks across the bridge with the torch, we have S′ = {Bob, Charlize}. (2.1) (1)Deﬁne the goal state for this problem. Since the goal is that everyone (and the torch) is on the other side the bridge, and the state representation speciﬁes what is on this side, the goal state is the empty set, i.e. {}. (2.2) (3)Suppose the current state is S = {Bob}. Deﬁne the applicable actions for this state. (Hint: you ﬁrst need to deﬁne the notation for the actions, and then specify the applicable actions for this state.) All actions for this problem can be written as Cross(P ) with P ⊆ {Andile, Charlize, Bob}, and 1 ≤ |P | ≤ 2. This speciﬁes that one or two of the three people can cross the bridge at a time. Note that the action does not track the torch; it will move along with the people who cross. The transition function must move the Torch accordingly. Since state S speciﬁes that Bob is on the other side of the bridge without the torch, Andile and Charlize must be on this side with the torch. The applicable actions from state S are thus: 1. Cross({Andile}) 2. Cross({Charlize}) 3 3. Cross({Andile, Charlize}) (2.3) (6)Provide the transition model for the search, but limit your answer to the case where S = {Andile, Bob, T orch}. You will again have to provide the applicable actions before providing the transition model. Make sure you show the resulting states when applying the actions. The applicable actions for this state are: 1. a0 = Cross({Andile}) 2. a1 = Cross({Bob}) 3. a2 = Cross({Andile, Bob}) Our transition model is then all the resulting states when applying these actions. 1. Result(a0, S) 7→ S′ = {Bob} 2. Result(a1, S) 7→ S′ = {Andile} 3. Result(a2, S) 7→ S′ = {} Question 3: 5 Marks (3.1) (3)Explain how a Breadth First Search (BFS) ensures that it always expands the shallowest node ﬁrst. Provide an example to aid your discussion. BFS uses a FIFO queue for its frontier. This means whenever a node is expanded, the generated nodes are placed on the frontier as they are generated. This means a node’s immediate children are placed on the queue, and will be expanded before any nodes further away from the node is expanded. Example evaluated based on correctness of FIFO discussion. (3.2) (2)Explain when one might want to choose Depth First Search (DFS) over BFS. (Hint: In which version of the algorithm does one have an advantage over the other?) DFS has a clear space complexity advantage over BFS when a tree search is per- formed. Question 4: 5 Marks Consider the search tree in Figure 1. Show the order in which the nodes will be expanded at each level (start with level 0 and continue until the goal test is successful), given that IDS is used. Assume the goal node is G, and that nodes are expanded from left to right (M is expanded before E and so on). (Hint: make sure you understand the diﬀerence between expansion and generation, and also that you understand when goal checks occur.) Expansion means we apply legal actions to a chosen node – this, by deﬁnition, means that our order looks somewhat diﬀerent from what one may expect. Also, note that the IDS is a repeated invocation of the depth limited search. In the depth limited search, once we generate a node, we 4 COS3751/201/1/2019 O M D K I C J H E L F G B N A Figure 1: Search Tree (Iterative Deepening Search (IDS)) recursively call the depth limited search on that node. Thus, goal state checking happens immediately after generation for each node. In general, the children of nodes that are expanded are thus goal checked. 1. Limit 0: (No expansion – O is just goal tested) 2. Limit 1: O (M and E are just goal tested, not expanded) 3. Limit 2: O M E 4. Limit 3: O M D C E L 5. Limit 4: None, search terminates once L is expanded – once L is expanded, G will be generated and goal tested on the recursive call. Visually, this is what happens (squares are goal tests and circles are expansions). Limit 0: O Limit 1: O M E Limit 2: 5 O M D C E L B Limit 3: O M D K I C J H E L F G Question 5: 16 Marks Consider the graph provided in Figure 2, and answer the questions that follow. The step cost between nodes is provided next to the edges. (5.1) (3)Prove that a consistent heuristic is admissable. (Hint: if you can prove that admissibility holds for nodes 1 step away from the goal, then you can prove that nodes k-steps away from the goal is admissible). We ﬁrst repeat the two applicable deﬁnitions: A heuristic is consistent if its estimate of the cost to the goal is always less- than-or-equal to the sum of the actual cost to any successor node plus its estimate from that node to the goal. As an equation: h(n) ≤ c(n, n ′) + h(n′) where n is a node and n ′ is a neighbour of n. Also, h(m) = 0 if m is the goal. A heuristic is admissible if the estimated cost to the goal is always less-than- or-equal to the actual cost to the goal. As an equation: h(n) ≤ c(n, m) 6 COS3751/201/1/2019 H B G K N D E C J A O L I M F 4 8 10 7 5 8 4 6 7 4 3 2 7 5 8 Figure 2: Search As suggested in the hint, we give a proof by induction: Say h is consistent. 1. Base case: Assume that the goal is a neighbour of n, i.e. n′ = m. Since h is consistent, h(n′) = 0 and h(n) ≤ c(n, n ′) + 0. So h is admissible, 1 step from the goal. 2. Inductive case: Let n ′ be a node on the shortest path between n and m, k steps from m, and say h(n ′) ≤ c(n′, m). Since h is consistent, h(n) ≤ c(n, n ′) + h(n′). So h(n) ≤ c(n, n ′) + c(n ′, m) = c(n, m). Since n is k + 1 steps from the goal, we conclude that the heuristic is admissible. (5.2) (11)Perform a Uniform Cost Search (UCS) on the graph. The start node is M and the goal node is F . Provide a step-wise explanation of the search as it progresses. At each step, provide the frontier, and show which node is selected for expansion. Provide the ﬁnal path from the start to the goal. Use the following format for your answer (step 1 has been completed below): Step Node expanded Frontier 1 M(ˆg = 0) . . . . . . . . . Remember: the ﬁrst step of a well-written search algorithm is always to generate the start node (i.e. place the start node in the frontier). Step two should begin with expanding the node in the frontier with the smallest ˆg value. 7 Step Node expanded Frontier 1. M(ˆg = 0) 2 M E-M(7), O-M(7), G-M(10) 3 E-M O-M(7), G-M(10), A-O-M(12), N-O-M(14), C-E-M(15) 4 O-M G-M(10), A-O-M(12), N-O-M(14), C-E-M(15) 5 G-M A-O-M(12), H-G-M(14), N-O-M(14), C-E-M(15), F-G-M(18) 5 A-O-M H-G-M(14), N-O-M(14), C-E-M(15), F-G-M(18) 7 H-G-M N-O-M(14), C-E-M(15), D-H-G-M(17), F-G-M(18), J-H-G-M(18) 8 N-O-M C-E-M(15), D-H-G-M(17), F-G-M(18), J-H-G-M(18) 9 C-E-M D-H-G-M(17), F-G-M(18), J-H-G-M(18) 10 D-H-G-M F-G-M(18), J-H-G-M(18) 11 F-G-M J-H-G-M(18) Note at step 8, another path to C is found, and ignored, since it is higher than the existing path. At step 9, N is already in the explored list, so we don’t add M-E-C-N to the frontier. At step 4, expanding G-M actually generates F-G-M (a goal path), but since there may still be a shorter path to F, the algorithm carries on. Ties were broken using lexicographical name ordering of the node name in the state space. The ﬁnal path is thus: M-G-F with a path cost of 18. (5.3) (2)Perform an A∗ search on the graph in Figure 2. The start node is G and the goal node is H. Provide a step-wise explanation of the search as it progresses. At each step, provide the frontier, and show which node is selected for expansion. Provide the ﬁnal path from the start to the goal. Use table 1 for the ˆh values for each node in the graph. Use the following format for your answer (step 1 has been completed below): Step Node expanded Frontier 1 G(ˆg = 0, ˆh = 20, ˆf = 20) 2 . . . . . . Remember: the ﬁrst step of a well-written search algorithm is always to generate the start node (i.e. place the start node in the frontier). Step two should begin with expanding the node in the frontier with the smallest ˆf value. Remember that the cost (both step and path) are calculations with respect to the eﬀort expended in order to reach a node. In a navigation setting, for example, this could mean distance, time, or fuel. In other settings it might mean something else: hourly wages paid, volume of paint used, compute cycles on a cloud CPU, number of hours inoperative, etc. Nodes can thus also just be a snapshot of the world, and need not just be location on a map – think about it carefully: if your search leads you to node X, all you’ve done is created a snapshot of a potential world in which you (or the agent) are in world-state represented by node X. IF X is a city on a map, and the search has plotted a path to X, it is simply a state in which the agent has travelled to reach X – and thus simply a snapshot of the potential world. (For example, we can use A∗ to solve the Australian map colouring CSP.) 8 COS3751/201/1/2019 Node Estimated COST to goal A 12 B 15 C 8 D 13 E 15 F 18 G 19 H 0 I 7 J 7 K 14 L 14 M 12 N 17 O 8 Table 1: Estimated Distance to Goal for A ∗ search. Step Node expanded Frontier 1. G(ˆg = 0, ˆh = 19, ˆf = 19) 2 G H-G(4,0,4), F-G(20,8,18), G-M(10,12,22) 3 H-G F-G(20,8,18), G-M(10,12,22) The ﬁnal path is: G-H, with a cost of 4. Question 6: 18 Marks Consider the problem of placing spaza-shops in a neighbourhood. The ideal is to have all the shops operating in harmony. To achieve this, we need to make sure that they are placed in such a way that they don’t interfere with eachother. That is, we don’t want them to contest for customers. As such we must place them in such a way that no spaza can poach another’s customers. As it stands the four spaza-shops in a certain neighbourhood were opened withtout these con- siderations, and as a result there has been some frustration amongst the shop-owners as well as the residents. In an attempt to remedy this unfortunate state of aﬀairs, you have been tasked to ﬁnd a way to optimally place the shops to improve relations among the shop-owners and residents. The shop owners, are extremely amenable to any solution, and have agreed that moving shop is not a problem. Using local search algorithms, a search to solve the problem is performed as follows: • Given a start or initial state, • Deﬁne an objective function to aid the local search, • Generate a successor state from the current state by moving a spaza-shop to a new location, • An optimum (minimum/maximum as measured by the objective function) is considered a goal. 9 A B C D 1st Str. 2nd Str. 3rd Str. 4th Str. 5th Str.1stAve.2ndAve.3rdAve.4thAve.5thAve. Figure 3: Initial shop locations After thinking for a while, you simplify the neighbourhood to a four-by-four grid, with each shop presented as shop A, B, C, or D. The grid lines represent the streets, and avenues in the neighbourhood, and the blocks represent typical town blocks that may contain houses or shops. You map out the location of the shops and produce the start state in Figure 3 (we represent the state grahically simpliﬁed to aid your eﬀort, and you are welcome to provide graphical representations of successor states if asked): The shop-owners have agreed on the following rules: 1. Shops may not be located on the same street/avenue. 2. There must be at least one block between two shops. Based on these rules, you can see that no shops violate rule 1, and C and D violate rule 2. (6.1) (3)Provide a good objective function that can be used as a maximizer (i.e. a global maxi- mum, a reward function) for the problem. Hint: 1. An objective function (also called either a loss, or reward function) is a function that maps the current state to some linear value which can be used to judge the ﬁtness or goodness of the state. When we want to avoid loss, we deﬁne an objective function with respect to loss, and we try to minimize loss by minimising the evaluation of the state using the objective function (i.e. we look for a state that results in the smallest value when evaluated using the objective function). When we want reward, we deﬁne an objective function with respect to reward and we try to maximize the objective function. 2. First write down the function in plain English, and then provide the mathematical equation for it. 3. Use the streets, and blocks in your equation. For a maximizer, we want to express the objective function as a maximizer of the rules. So we want a state that has: 1. As many streets as possible that do not have two or more shops on them. 10 COS3751/201/1/2019 2. As many blocks with a shop on them that is not adjacent to a block with another shop on it. For a given state S, we deﬁne the following: 1. A : S 7→ N which returns the number of streets and avenues that have 1 or less shops on them. 2. B : S 7→ N with returns the number of blocks with a shop on it, that is not adjacent to another block with a shop on it. The objective function is then simply a sum of these values: F (S) = A(S) + B(S) (1) (6.2) (2)Now that you have deﬁned your objective function, use it to evaluate the start state as provided in Figure 3. Show your calculations. F (S) = A(S) + B(S) = 10 + 2 = 12 (6.3) (4)A hill-climb/hill-descent local search generates a series of successors, and takes the best one from among them (using the objective function). Beginning from the initial state in Figure 3, provide two successors, one that is worse, and one that is an improvement. Show why the successor is better, or worse by using the objective function to evaluate it. Remember: generate all possible successors, and choose the better/worse from among them. To simplify the search, each successor state is generated by moving one shop one street up or down on the grid – that is relocating it to a diﬀerent street, and never to a diﬀerent avenue). Worse: Move Shop D to 3rd street. This evaluates to F (S′ 1) = 9 + 1 = 10 Better: Move shop D to 5th street. This evaluates to F (S′ 2) = 9 + 4 = 13 (6.4) (7)From the previous question, take the ’better’ state you identiﬁed. Generate all possible successors (remember: a successor is generated by moving one shop, one street up or down). Are there any improvements (show your calculations for each state)? (Mark given for each successor that follows the search rules provided at start of question.) There is only one improvement: move shop A to 4th street. This yields F (S′′) = 14 which is a solution to the problem. 11 (6.5) (2)What type of topographical feature is most likely being created by the situation in the previous question? (Provide a rough sketch of this type of feature in a two dimensional state-space landscape.) Global Max Local Max The end result is a global maximum – a solution was found. Copyright c⃝UNISA 2019 (v2019.1.1) 12","libVersion":"0.2.3","langs":""}