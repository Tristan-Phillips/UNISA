{"path":"Subjects/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/Theory/theory-questions.pdf","text":"2018-6 What do you understand by the term “reflective programming”? Reflection is the self-examination of an object’s members. Using reflective programming, you can write general-purpose operations that work on classes of varied structures without needing to know the structure before-hand. To retrieve the value of an unknown property in reflective programming, you would use a QVariant. What is the role of QVariant in reflective code? A QVariant is a generic value-holder. In reflective programming, since you don’t know what the data types of the object’s properties are ahead of time, you can a QVariant to be able to hold any data type’s value. How can QVariants be used in a strongly typed language like C++ where an int or QString may be required? Since QVariant is a generic value-holder, you can use a QVariant to hold QString or int data type values, i.e. you can create a QVariant as a wrapper around another typed value. To convert the QVariant back to the original data type, you can use the toInt() or toString() methods, among others. Qt’s approach to the MVC design pattern is model-view programming. Briefly describe Qt’s model- view architecture by referring to the MVC design pattern and how the handling of the user interface is managed. MVC (model-view-controller) is a classic design pattern consisting of three kinds of objects. The model is the application object, the view is its screen presentation, and the controller defines the way the user interface reacts to user input, i.e. managing the interactions between events, models and views. Qt includes a model-view framework that maintains separation between the way data is organized and managed and the way that it is presented to the user. In Qt’s implementation there is no controller per say. The controller mechanism is found in delegates. Delegates control the rendering (how items appear in a view) and editing of individual items in views (they can even determine what kind of widget shows up when the user triggers editing of an item). In the model- view architecture, a delegate can be seen as playing the role of the controller from the MVC design pattern. Why is getInstance() function static? A static member is associated with the class itself rather than one that belongs to a particular object. In the Singleton design pattern, the point is to only have one instance of the data (e.g. a QStringList). Calling the getInstance() function must return that single instance associated with the class. Thus is needs to be declared as static so that it is shared by all objects of the class. UDP stands for User Datagram Protocol. What is a datagram? How does this approach differ from the way TCP sockets work? A datagram is a basic transfer unit (a message) associated with a packet-switched network. TCP guarantees in-order delivery while UDP does not. UDP is better when time is more important than delivery, compared to TCP when correct delivery is more important. Distinguish between QAbstractTableModel, QStandardItemModel, QTableView, QTableWidget, and QAbstractProxyModel by explaining how and/or where each is used to manage tabular data. QAbstractTableModel and QStandardItemModel are data models that both inherit from QAbstractItemModel. QAbstractItemModel defines the standard interface that enables views (and delegates) to access data. The difference between them is that QStandardItemModel is a general- purpose concrete data model and can be used as is to display table data, without providing your own implementation. QTableView is one view type in the framework that uses an external model to display the data. A QTableWidget on the other hand, is a convenience class that has a standard built- in model which is quicker to implement and use, but less flexible. The QAbstractProxyModel allows you to sort/filter your data without affecting the original model. It is also abstract and requires your own implementation. 2017-10 Which anti-pattern is avoided by checking input values? Input kludge What do you understand by the term “meta-object” and what is its major benefit? A meta object is an object that describes the structure of another object. In Qt the QMetaObject provides information about the properties and methods of a QObject. QMetaObject provides a generic interface through which the state of any QObject can be accessed. Discuss two differences between dynamic properties and properties accessed via the QMetaObject interface in the Qt framework. Discuss one similarity. Fixed properties defined by the Q_PROPERTY macro are known to the QMetaObject of that class. All objects of the same class share the same meta-object and thus have the same set of meta properties. Dynamic properties on the other hand, are acquired at runtime and are specific to the object that acquired them. In other words, two objects of the same class have the same meta property list, but they can have different lists of dynamic properties. Dynamic properties can be used in much the same way as fixed properties; for example, they can be serialized. Explain the relationship between the Observer pattern and the MVC pattern. In the Observer pattern the observer objects react to changes in the subject object without the subject explicitly having to inform them all. In the Qt framework the Signals and Slots features use a simplified form of this pattern. This concept applies to the MVC pattern in that the views in the MVC pattern need to react to changes in the state of the data model objects so that they can display the most current information. The controller (delegates in Qt’s model-view) are responsible for handling the events that impact both the data and the model. Qt’s model-view programming architecture easily fits the MV parts of the MVC pattern. Explain what the C part of MVC refers to, and how Qt implements it. The C refers to the Controller part of MVC design pattern. Controller code manages the interactions among events, models, and views (controlling the data flow between them). Qt implements this in its model-view architecture by using delegates. Delegates control the rendering and editing of individual items in views. They add several kinds of controller features to the Qt model-view framework including the means for moving data to and from the model. The Memento and Serializer design patterns have some similarities. How does the Memento design pattern differ from the Serializer design pattern? The Memento pattern is used to keep previous states of an object in memory. It's useful to implement an \"Undo\" operation, for example. Serialization is the process of transforming an object to a byte array, in order to save it on disk. QThread provides one approach to concurrency. In which situations are threads useful, and when do their overheads outweigh the potential benefits? Threads are useful and can improve performance if there is a significant amount of advance calculation that can be done, and you have idle cores. Sometimes the added complexity from using threads can outweigh the benefits. 2017-6 What is the purpose of the Q_OBJECT and Q_PROPERTY macros in a class definition? Briefly explain the practical programming benefits of a class that implements them. By adding the Q_OBJECT macro, the Meta Object Compiler (moc) knows to generate additional functions for the QObject derived class containing the macro, making features such as MetaObjects and MetaProperties used in reflective programming possible. The Q_PROPERTY macro gives you a choice of ways to access data members: directly through getters/setters (fast, more efficient) or indirectly through the QObject/QMetaObject interface (enables more reusable code). Describe what a QSharedPointer is, and how it is of benefit to a programmer. QSharedPointer, is a smart pointer that deletes its referenced object, but copies are permitted, and the QSharedPointer keeps a reference count. The shared heap object is deleted only when the last shared pointer to it is destroyed. What does the term “item-based” mean in the context of item-based solutions (e.g. QTableWidget, QStandardItemModel)? Item-based solutions store the actual data that is to be viewed and manipulated. View objects make frequent calls to item model methods to get or set data or to do various other operations. Discuss the fundamental difference between the QTableWidget and QStandardItemModel approaches. Which is less flexible? Explain. QTableWidget is an item-based table view with default model. The QStandardItemModel is a generic model for storing data. The latter requires the use of a view such as QTableView to display the data whereas QTableWidget does not. QTableWidget is less flexible since it is a convenience class, designed to be used as is for common scenarios, whereas QStandardItemModel can be used with different kinds of views as required. Writing to, and reading from, XML is an example of which design pattern? Discuss in detail how this pattern differs from the Memento design pattern, pointing out two major differences. Serializer pattern. A serializer is an object that is responsible only for reading or writing objects, usually to a file or database. In the memento design pattern, the originator object’s internal state is captured and stored as a memento in a caretaker which can be restored later without violating the encapsulation of the class. The data members of the class, which determine the state of its objects, may not all be accessible (via setters and getters) outside the class. Hence the class itself has to be involved in saving and restoring the state of its objects. The serializer pattern can modify the output. 2016-10 Which other approach could have been used to write to XML apart from using QXmlStreamWriter? DOM (Document Object Model). Given a QLineEdit in a graphical user interface, explain 2 ways a regular expression could be used to validate text a user enters in the line edit box. You can use the class QRegExpValidator and a QRegExp to validate an input string by using the setValidator() method on the QLineEdit to specify the regular expression to use. Alternatively, you could capture the user input from the QLineEdit and pass it to a function which uses the built in QRegExp methods to validate the value, such as exactMatch(). 2015-10 The Factory Method design pattern decouples the client from the concrete subclasses of the class hierarchy. Explain two benefits of this decoupling between the client and the concrete subclasses of the class hierarchy. One of the benefits of factory patterns is that we can manage the created objects in a pool (reusing the ones that can be reused). Indirect object creation also makes it possible to decide at runtime which class objects to create. This enables the “plugging in” of replacement classes without requiring changes in the client code. Both Serializer and Memento design patterns save states of objects and can be used to provide a roll-back facility. When would you use Memento instead of Serializer? When you need to save the internal state of an object and protect that state to be (possibly) restored at some point in future, use the Memento design pattern. Why is Originator a friend of Memento? The constructor and getState()/setState() methods of Memento are private, to ensure that the Memento cannot be modified from outside the pattern. To allow the Originator to create a Memento object, it must be a friend class of Memento. What objects does Caretaker hold? The Memento object which is a saved state (snapshot). Assume that a state of Originator is saved at some stage using the Memento design pattern. State the sequence of actions required to roll back to the saved state of Originator. The originator uses the setMemento() method to restore itself to the state in the provided memento object. The setMemento() method gets the saved state from the provided memento using getState(), and sets the data members of the originator to the values from the saved state. State the difference between SAX and DOM parsers. The main difference is that SAX is a sequential access parser, so it parses the document as it reads it, and makes first chunks of parsed data available almost instantly. Because of this it can emit events as it encounters elements, e.g. a start tag. SAX can process an XML file of any size. DOM needs to load the whole document into the memory to get it parsed and as such, the max file size is limited by the amount of RAM available. DOM is suitable for applications that require random access to various parts of an XML document. DOM is convenient and standard but has high memory and processing requirements. SAX is fast and relatively memory efficient but is not very simple to use. State a relevant Qt class for network communication using TCP. QTcpServer (generates instances of QTcpSocket for each incoming connection). 2015-6 What is a design pattern, and give one of its benefits? Design patterns are efficient and elegant solutions to common problems in object-oriented software design. They are high-level abstract templates that can be applied to particular kinds of design problems. Describe what is understood by the term anti-pattern. AntiPattern is a term used to describe a commonly used programming practice that has proved to be ineffective, inefficient, or otherwise counterproductive. What are the differences between QAbstractItemModel and QStandardItemModel in terms of using them and the data structure that they can work with? QStandardItemModel is a generic model for storing data and can be used as is without subclassing. It is a concrete model for items in a tree or table. With QAbstractItemModel, since it is an abstract class, you have to implement your own model logic. You can decide which data structure to use. Describe the purpose of the flags() function. For editable models, you must override flags() and setData(). If you want in-place editing (in the actual view), you would return Qt::ItemIsEditable from flags(). Why would you want to create your own custom subclass of QValidator? When the requirements for validating user input go beyond simple numeric range-checking or validation with a regex, you can define your own validator class by deriving from QValidator. What is the purpose of applying the Memento design pattern? When you need to capture and externalise an object’s internal state with the possibility of restoring the object to a previous state via a rollback/undo feature, without violating encapsulation. What are the encapsulation requirements of a class when applying the Memento pattern? The data members of the class, which determine the state of its objects, may not all be accessible (via setters and getters) outside the class. Hence the class itself has to be involved in saving and restoring the state of its objects. The originator can access the memento since it is a friend class. Can Caretaker save the state of the objects that it holds to a file? Explain your answer. The Caretaker cannot access the state stored in the Memento, and thus cannot save its contents to a file. Explain the purpose of the QXmlStreamWriter class. QXmlStreamWriter is a stream-based class used to generate XML documents. It has a simple and straightforward API: for every XML token or event you want to write, the writer provides a specialized function. Name three XML parsers available in the Qt framework. SAX, DOM, QXmlStreamReader Briefly explain the purpose of the classes QTcpSocket and QTcpServer within the context of networking using TCP. There are two TCP classes in Qt, QTcpSocket and QTcpServer. QTcpSocket represents a socket. QTcpServer represents a server, which listens for incoming connections and generates QTcpSocket instances for each connection. 2014-10 What is the main difference between QProcess and QThread? QProcess and QThread provide two approaches to concurrency. QProcess is a convenient class for starting and controlling other processes. A QProcess can launch another process, which is a child that terminates when its parent does. Communication is done via streams and data is passed using command line arguments. QProcess is managed by the OS. QThreads are for concurrency within a single process. They share code and data, using locks (e.g. QMutex), wait conditions and semaphores to ensure data integrity. They are managed by a process. What are the similarities and differences between thread safe and re-entrant functions? A reentrant method is one that can be called simultaneously by multiple threads, provided no two invocations of the method attempt to reference the same data. A thread-safe method can be called simultaneously by multiple threads at any time, because any shared data is protected somehow (e.g., by QMutex) from simultaneous access. How is the communication between (a) the different processes, and (b) the different threads effected or implemented? a) QProcess takes advantage of signals and slots for communication. For example, the signal readyReadStandardOutput() is emitted when data is available on the selected channel of the child process. The parent process can then read its output by calling read() , readLine() , or getChar() . If the child process has standard input enabled, the parent can use write() to send data to it. The use of signals eliminates the need for a read loop. b) Sometimes it is necessary to access one object from different threads; for example, when objects living in different threads need to communicate. Since threads use the same address space, it is easier and faster for threads to exchange data than it is for processes. Data does not have to be serialized and copied. Objects can be updated safely by using QMutex, QWaitCondition or QSemaphore to ensure it stays in a “valid” state. 2013-6 List three ways in which the Qt framework supports validation of user input using validators. • Input mask – an active pattern that controls what can be typed into an input widget by the user. • Validators – objects that can be attached to input widgets (such as QLineEdit, QSpinBox, and QComboBox ) to provide a general framework for checking user input. • Regular expressions – powerful tools for validating input, for extracting data from input, and for searching and replacing. Qt supports accessing TCP and UDP directly at socket level. Give 3 differences between TCP and UDP that you need to keep in mind when choosing which one to use. TCP Sockets UDP Sockets Guaranteed in-order delivery Fire and forget Point-to-point only Point-to-point or broadcasts Great when correct delivery is important Great when time is more important than delivery List and explain any two regular expression meta-characters. 1. Special characters • . (the dot matches any character) • \\n (matches the newline character) • \\f (matches the form feed character) • \\t (matches the tab character) • \\x hhhh (matches the Unicode character whose code is the hexadecimal number hhhh in the range 0x0000 to 0xFFFF ) 2. Quantifiers – Modifiers that specify the number of occurrences of the preceding character (or group) that may appear in the matching expression. • + (1 or more occurrences) • ? (0 or 1 occurrences) • (0 or more occurrences) • { i , j } (at least i but not more than j occurrences) 3. Character Sets – Sets of allowable values for the character in the specified position of the matching expression. Several character sets are predefined: • \\s (matches any whitespace character) • \\S (matches any non-whitespace character) • \\d (matches any digit character: 0 to 9 ) • \\D (matches any non-digit character) • \\w (matches any “word” character; i.e., any letter or digit or the underscore _ ) • \\W (matches any non-word character) Character sets can also be specified in square brackets: • [AEIOU] (matches any of the characters A , E , I , O , or U ) • [a-g] (the dash makes this a range from a to g ) • [^xyz] (matches any character except for x , y , and z ) 4. Grouping and Capturing Characters – (round parentheses) can be used to form a group. Groups can be back-referenced, meaning that if there is a match, the grouped values can be captured and accessed in various ways. For convenience, up to nine groups can be referenced within the regular expression by using the identifiers \\1 thru \\9. There is also a QRegExp member function cap(int nth) , which returns the n th group (as a QString). 5. Anchoring Characters – Assertions that specify the boundaries of a matching effort. • The caret (^), if it is the first character in the regex, indicates that the match starts at the beginning of the string. • The dollar sign ($), when it is the last character in the regex, means that the effort to match must continue to the end of the string. • In addition, there are word boundary (\\b) or non-word boundary (\\B) assertions that help to focus the attention of the regex. See more on p441+.","libVersion":"0.2.3","langs":""}