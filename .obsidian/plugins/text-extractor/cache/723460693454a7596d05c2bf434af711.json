{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Tutorial Letters/COS3711_2018_1_202.pdf","text":"COS3711/202/1/2018 Tutorial Letter 202/1/2018 Advanced Programming COS3711 Semester 1 School of Computing Discussion of assignment 2 BARCODE COS3711/202/1/2018 2 CONTENTS Page 1 INTRODUCTION ............................................................................................................................... 3 2 TUTORIAL MATTER......................................................................................................................... 3 3 COPYING OF ASSIGNMENTS ........................................................................................................ 3 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 2 ..................................................................... 3 4.1 Question 1.......................................................................................................................................... 3 4.2 Question 2.......................................................................................................................................... 4 4.3 Question 3.......................................................................................................................................... 5 4.4 Question 4.......................................................................................................................................... 5 4.5 Question 5.......................................................................................................................................... 6 4.6 Question 6.......................................................................................................................................... 7 4.7 Question 7.......................................................................................................................................... 8 4.8 Question 8.......................................................................................................................................... 8 5 MARKING RUBRIC........................................................................................................................... 8 COS3711/202/1/2018 3 Dear Student 1 INTRODUCTION The solutions and the discussions are only made available electronically. The solution to assignment 2 is placed under Additional Resources of COS3711 on myUnisa. A separate folder is created for each question, in which you will find all the relevant files for its solution. Please note that the solutions provided on myUnisa are only suggested solutions and they are not the best or only solutions. Please note that the provided solutions were created and tested using Qt Creator 3.1.1 (opensource) based on Qt 5.2.1 (MSVC 2010, 32 bit) installed on a computer running on Windows 7 Enterprise (32- bit). This tutorial letter contains a short discussion of the solution to Assignment 2 of COS3711 made available on myUnisa. Hence, this tutorial letter should be used in conjunction with the solutions uploaded on myUnisa. The marking rubric used for marking of Assignment 2 is also included in this tutorial letter. It is impossible to follow a marking rubric strictly for a programming assignment. Hence the given marking rubric should be used only as a rough guideline. 2 TUTORIAL MATTER The following are important documents that you need to consult. Please download them from myUnisa if you do not already have them. COS3711/101/3/2018 First tutorial letter COS3711/MO001/3/2018 The contents of the myUnisa site for COS3711 COS3711/102/3/2018 Practical study guide COS3711/103/3/2018 Networking and the Web – Additional notes COS3711/201/1/2018 Discussion of assignment 1 3 COPYING OF ASSIGNMENTS Assignments that contained solutions copied from another student’s assignment are penalised heavily. 4 DISCUSSION OF SOLUTIONS TO ASSIGNMENT 2 4.1 Question 1 Creating the main GUI should not present you with any problems apart, maybe, from inserting the date – use QDate::currentDate(), and then use the toString()function to display it. Creating the Transaction class should also not have presented any problems. Although the transaction type is indicated using an enum, the solution example uses a static const QStringList to hold the transaction types to simplify working with the enum; this QStringList is used to convert backwards and forwards between the words “Withdrawal” and “Deposit” and the type of transaction (which is of the enum TransactionType type) stored in the class. A toString()function is included to facilitate displaying the information in each Transaction. COS3711/202/1/2018 4 The TransactionList should be created using the Singleton pattern. Creating the singleton instance follows the standard implementation, and there should be no problems here. The part that is not explicitly described in the question is the class that is used to manage the TransactionList, called TransactionHandler in the example solution. This class would need a TransactionList pointer data member and functions to allow for deposits, withdrawals, and writing to file. It is this class that would access the singleton TransactionList (in the constructor). Also, in the makeDeposit() and makeWithdrawal() functions a Transaction object would be created, added to the list maintained by the TranasctionHandler class, and display the transaction to the console. The writeToFile() function would need to get the transaction list (a function would need to be added to the TransactionList class to return the list), and looping through the list write each transaction to the file. The GUI that is the frontend of the application has a data member of the TransactionHandler type, and it calls the appropriate methods (via the signal/slot system) of this handler class to make deposits and withdrawals, and request that all data be written to file. Thus the object that provides the user interface is kept independent of the transaction list (and its transactions) through the handler class that manages the transaction list. 4.2 Question 2 In typical object-oriented fashion, the sample solution uses a separate class to write a Transaction list to XML using DOM. This TransactionWriter class has a QDomDocument and a QDomElement as data members (named doc and rootElement respectively). It’s constructor that sets up the root element, and appends it to the doc. The addTransaction() function accepts a Transaction pointer, and proceeds to build up a transactionElement; the transactionElement is appended to the rootElement, and each data element is appended to the transactionElement. QDomText text elements hold the actual data from the Transaction object, and this text element is appended to the data element. This is done for each piece of data: date, time, amount, and type. See Figure 1 for a graphical view of the DOM hierarchy. Figure 1 The DOM hierarchy The work of using this TransactionWriter class is the job of the TransactionHandler class, and the writeToFile()function specifically. Here, the file is created and a QTextStream opened to the file; false is returned at this point should the file not open successfully so that the calling function can COS3711/202/1/2018 5 take appropriate action (informing the user). Then, once a TransactionWriter object is instantiated, you can simply loop through the transaction list, passing each Transaction to the addTransaction() function in turn. Finally, get the DOM document and write it to file (using the built- in toString() function). This process could also have been handled by passing the whole list to the TransactionWriter and then looping in that object. 4.3 Question 3 Creating the Sort class hierarchy should be straightforward enough, and there should be no problems here. To implement the factory method, the full treatment involves an AbstractFactory class (with the chooseSort() function returning a Sort pointer that will be the factory method, and a virtual destructor), and a concrete SortFactory class that implements the chooseSort() function. In this latter function, it uses its one argument to select which sort algorithm to use, and then instantiates the appropriate class. NULL is returned in the case that the choice selected is not recognised. Note that it is not essential to have the abstract base class. To allow a user to choose a sort then means updating the GUI, and adding the required combo box. There will also need to be a function written to handle the user clicking on the Sort button, and the necessary slot created and connect statement added. As before, the GUI just handles the user interface, and the actual work is passed on to the TransactionHandler object. Here, if false is returned due to sort failure, the user is informed of the error. Now all that has to be done is the doSort()function of the TransactionHandler: create a pointer to the SortFactory (of type AbstractFactory), get the transaction list, use the SortFactory object to choose the sort algorithm and pass the transaction list, and then if NULL has not been returned call the sort() function. Displaying this sorted list to the console is a simple task. Below is example where the selection sort was used. 4.4 Question 4 The PrimeFinder class is implemented so that it can run as a thread: it inherits from QObject and implements the Q_OBJECT macro. It must also implement a slot which can be run once the thread has COS3711/202/1/2018 6 started (findPrimes() in this case).. There is one constructor that accepts the thread number, as well as its start and end points – the thread number was needed so that it would be possible to know which thread was emitting a prime so that the prime number could be displayed in the correct window. The findPrimes() function loops through all the numbers in the range that it has to check, and if a prime number is found, a signal is emitted (indicating the prime number found, and which thread number is was that found it). The MainWindow class sets up the GUI and when the user clicks the Start button, PrimeFinder instances are created and moved to newly created threads before the threads are started. The task is divided up among the number of threads required. The signals and slots are connected (to handle when a thread is started, when prime numbers are found and when a thread is finished its work), and the thread is then started. The displaying of the prime numbers simply checks which thread has returned a value so that it can be displayed in the correct window. As threads are completed, the count of the number of threads is decremented, and once this reaches zero, the list that contains the threads can be cleared and the Start button enabled so that the whole process can start over afresh. If the user closes the window before all the threads have completed their work, the program loops through the list of threads, quitting each thread (and waiting for the thread to finish execution), and then allowing the application to close. 4.5 Question 5 The GUI will need to be updated again, adding the Read button, setting up the slot in the MainWindow class, and adding a connect statement to link the signal and slot. As before, the GUI class handles the button being clicked, but then passes the control to the TransactionHandler object in the GUI class to do the actual work. The parsing of an XML file using SAX would follow the usual procedure: • create a QFile object linking to the XML file, • create the handler (in this case a TransactionReader object), • create a QXmlSimpleReader object (here called reader) setting its content handler to the handler object you created, • create a QXmlInputSource object (setting its source to your QFile object), • and then parse the file. Finally, the newly created list can be retrieved from the handler, transactions added to the cleared list, and displayed to the console. Note that two new functions were added to the TransactionList class to facilitate the reading and subsequent display: a clear() function to clear the list of all data, and a toString() function to return the contents of the list as a QString. The real work that you have to do is to write the TransactionReader class (which inherits from QXmlDefaultHandler). As the data has been serialized to XML using text nodes rather than attributes, most of the work is in the characters() function. However, you will need to write code for the startDocument(), startElement(), endElement(), and endDocument() functions. To make the process simpler, this class also has data members that will be used to instantiate Transaction objects (as Transaction*), a QList< Transaction*> to keep the list of items, and a QStringList details to hold all the data until the Transaction object is created. The startDocument() function then simply sets the Transaction* to NULL, and returns true. COS3711/202/1/2018 7 The startElement() function ensures that details is cleared of all data when in the start element of a <transaction> element. The endElement() function checks whether we have reached the </transaction> end element, and creates a Transaction object using the data collected in details. This pointer is then added to the list being maintained by the reader. to NULL if it has reached the end of a Transaction object, and if the QStringList that holds the bits of data for the objects is 6 (that is, an object has now been created), it clears the QStringList. The endDocument()function simply has to return true – there is no work to do. A getList() function is added so that other objects will have access to the private Transaction list that is created in the parsing process. 4.6 Question 6 DOM (Document Object Model), SAX (Simple API for XML), and QXmlStreamReader are popular APIs for handling XML documents. DOM reads the whole XML file into memory. This has the advantage of being able to move around in the document allowing multi-pass algorithms, but it does mean that you must have enough memory to handle the size of the XML file. DOM follows a formal specification, which is not true of SAX (which has various implementations, although the java implementation is seen as a standard). DOM can also be used for reading and writing XML documents. DOM uses a hierarchical tree model to store the contents of a parsed XML document, and so you are forced into this model of tree nodes for all XML documents even if the data is actually tabular. SAX can run on a file of any size as it handles the XML file one node at time, and can only be used for reading XML documents. Although it does save on memory, it is a sequential and unidirectional process, which is less flexible than parsing using DOM. SAX is also event-based, meaning that the parsing of the file is triggered by tags in the file, and not controlled by the programmer, and it does not use the hierarchical tree structure of the DOM; this does lead to faster processing, though. But then some kinds of XML validation require the whole document be loaded, and in SAX this is not done, and so some errors may only be discovered after the document has been parsed. Qt’s QXmlStreamReader and QXmlStreamWriter APIs can be used to read and write XML documents respectively. QXmlStreamReader is a fast and easy to use one-pass parser with an API that is similar to the rest of Qt. It also reads incrementally and so can handle very large files. Similarly, QXmlStreamWriter is probably the easiest approach to generating XML; it can also auto-format, producing a more human-readable, indented format. Note that it is also possible to generate (or write) XML by hand, actually creating each tag as a QString. This is not a reliable approach as it is error prone (especially where special characters are involved) and not guaranteed to produce XML that is parsable. Some have argued that to parse machine generated code SAX is better, whereas to parse human readable documents DOM is more useful. Clearly there are pros and cons to all three approaches, and so it will depend entirely on your needs in each application as to which would be better for that particular application. If you need to manipulate the data, then you must go with DOM. But if you only need to read an XML document, and do so sequentially, then QXmlStreamReader may be the better option. If data is read in, or managed, as a DOM tree, then writing XML using DOM makes most sense. COS3711/202/1/2018 8 4.7 Question 7 In this solution, we have added TextAndStyle to represent the text and the formatting style applied to the text. The TextAndStyleMemento class is used to represent a memento of TextAndStyle. MyNotepad acts as the caretaker and thus requests mementos, stores up to five mementos, as well as using these mementos to perform undo operations. We have implemented TextAndStyleMemento slightly differently from what you may be familiar with. We haven’t used a QString or a QStringList to represent the state of a TextAndStyle object. Instead we used TextAndStyle as a data member of TextAndStyleMemento. This technique eliminates the process of creating a string equivalent of the state of an object as well as string processing to set the state of an object. Note that QTextEdit can be used as an advanced document editor. It has built-in undo facilities. Hence this exercise should be seen just as an exercise to implement the Memento pattern. It is also arguable whether or not this is a good project in which to implement the Memento pattern. Firstly, MyNotepad can work independently without the TextAndStyle class. We only use TextAndStyle when we want to create a backup. Secondly, the Memento pattern is usually applied when the Originator has strict encapsulation requirements where no getters and setters are provided for this class. However, TextAndStyle needs to have getters so that MyNotepad can access the saved text and format of the text. 4.8 Question 8 UDPSend: The sender’s constructor initialises socket, sets up a list of insults in a QStringList, and sets up the GUI interface (with the connect statement to begin the transmission). The startSending() function creates a socket, sets up the timer to produce random timeouts so that the sendMessage() function will be called at random intervals. The sendMessage() function does most of the work: a random message is written to a QDataStream that operates on a QByteArray, and this is then broadcast. The timer’s interval is changed again to ensure another random wait before the next message is sent. UDPListen: The constructor simply sets up the GUI and connects the listen button’s clicked() signal to the startListening() function/slot. The startListening() function creates a QUdpSocket, binds it to the port that will be used, and then listens for incoming datagrams. When one is detected, it is signalled via the readyRead() signal, which is connected to the processPendingDatagrams() slot. The incoming datagram is read into the QByteArray buffer, and then used by the QDataStream object to read the data into a QString and display it in the listener’s QTextEdit display window. As datagrams are received, they are then displayed in the window. Remember to add QT += network to the .pro files for both applications. 5 MARKING RUBRIC Question 1 [35] Key Aspects Allocated marks Marks awarded Transaction class • Deposit/Withdrawal handled as enum 2 • Type handled appropriately 2 • 4 private data members 2 6 TransactionList class • Appropriate container used 1 9 COS3711/202/1/2018 9 • Implemented as a singleton 5 • Transactions can be added 1 • Memory properly deleted 2 TransactionHandler class • Implemented as a separate class 2 • Transactions handled as pointers 2 • Uses singleton TransactionList 1 • Manages transaction list: deposit/withdrawal 2 • Transactions written to console 1 8 Write to file • File open/checked/close 3 • Full list written in human-readable form 2 5 GUI • Date display 1 • Appropriate widgets used 1 2 Program builds (2) and provides some functionality (3) 5 Total marks 35 0 Comments: Question 2 [15] Key Aspects Allocated marks Marks awarded Writing handled as separate class 3 Whole list written to XML using DOM text elements 6 File open, checked, and closed; user informed of errors 3 Program builds (1) and provides some functionality (2) 3 Total marks 15 0 Comments: Question 3 [25] Key Aspects Allocated marks Marks awarded Sort • Base class abstract 2 • Concrete classes inherit from base class 2 • Sorts by amount correctly 6 10 Factory Method • Returns concrete class pointer based on user choice 3 • Returns NULL if unrecognised choice 1 4 GUI/console • GUI updated with combo box for user choice 3 • Signals and slots added 1 • Sorted list displayed to console 2 6 Program builds (2) and provides some functionality (3) 5 Total marks 25 0 Comments: Question 4 [25] Key Aspects Allocated marks Marks awarded PrimeFinder • Inherits from QObject (not QThread) 2 • Implements a slot to do the work 3 • Accepts start and end parameters 2 • Prime number emitted 1 8 COS3711/202/1/2018 10 MainWindow/GUI • Start/End/Number of threads can be set 3 • Task divided up correctly 2 • Tasks moved to threads and started correctly 3 • Memory cleaned up on completion 2 • Memory cleaned up on ending before tasks complete 2 12 Program builds (2) and runs (data displayed on GUI) (3) 5 Total marks 25 0 Comments: © UNISA 2018","libVersion":"0.2.3","langs":""}