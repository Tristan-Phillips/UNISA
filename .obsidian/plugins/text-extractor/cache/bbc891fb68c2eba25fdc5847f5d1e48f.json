{"path":"UNISA/98906 - BSc Science in Computing/COS3711 - Advanced Programming/Unsorted/Open Book Exam Files/61269921_COS2621_2021_Nov_Exam.pdf","text":"Leendert Viljoen 61269921 COS2621 2021 Nov Exam Question 1 a. 4 b. 4 c. 3 d. 1 e. 4 f. 2 g. 1 h. 4 i. 3 j. 1 k. 2 l. 5 m. 2 n. 4 o. 3 Question 2 1. 10-bit address, 1024 cells, 8-bit cell size. This is normally a 1KB system. We need n address bits to be able to address 2n memory positions and in this example 210 = 1024. Which means the 10-bit address is correct. 8-bits is the size of one byte. 2. 10-bit address, 1024 cells, 12-bit cell size. Old-style since 12-bit words are no longer used but are still viable. Usually, a cell size that is the power of 2 will be used. 3. 9-bit address, 1024 cells, 10-bit cell size. The address is too short so not possible. 1024 cells can’t be addressed into only 9 address bits as 29 = 512. The cell size is not a standard size so it’s not advisable but still possible. 4. 11-bit address, 10 cells, 10-bit cell size. Possible, not advisable. Only 4 bits are needed to address 10 cells. 5. 10-bit address, 1024 cells, 1024-bit cell size. Possible. ASCII is 7-bit, and extended ASCII is 8-bit. Which means there is a representation space of 128 and 256 symbols respectively. This has numerous limitations that hinders you from representing other languages besides the ones that make use of the Latin alphabet, numeric characters, and some special characters. This led to the development of Unicode which covers almost all scripts (writing systems) which are used today. Leendert Viljoen 61269921 COS2621 2021 Nov Exam Question 3 Slower and less expensive memory is used in higher stages, with the most expensive being the registers in the processor as well as cache. Main memory is slower, less expensive, and is outside of the processor. Inboard memory – registers → cache (L1, L2, L3) → main memory Outboard memory – magnetic disk, CD-ROM, CD-RW, DVD-RW, Blu-ray etc. Offline storage – magnetic tape As you go down the hierarchy, the following occur: 1. Decreasing cost per bit 2. Increasing Capacity 3. Increasing Access Time 4. Decreasing frequency of access of the memory by the processor. There are 3 caches, 2 of which are on-chip. 1. L1 instruction cache (on-chip). 12K in size and holds micro-operations. Sits between the instruction decode logic and execution core. 2. L1 data cache (on-chip). 8Kb, 4-way set associative organisation. Uses a write-block policy. 3. L2 cache of 256 KB. Feeds both L1 data and instruction caches. Its organisation is 8-way set- associative. Leendert Viljoen 61269921 COS2621 2021 Nov Exam Question 4 Four instruction fetches 4*4 = 16 cycles Two MOV instructions 2*2 = 4 cycles One MUL instruction 1*5 = 5 cycles One ADD instruction 1*4 = 4 cycles Total = 29 cycles A machine speed of 800 MHZ means that the machine completes 800*(10^6) cycles per second. This means that one cycle takes: 1 800 ∗ 106 seconds to complete, which can also be represented as: 1 800 ∗ (10−6)𝑠𝑒𝑐𝑜𝑛𝑑𝑠 = 0.00125 μsec Therefore 29 cycles will take: 29 ∗ 0.00125 μsec = 0.03625 μsec to complete 1. Immediate Addressing mov ax 5 2. Direct Addressing mov ax,[temp] 3. Indexed Addressing mov ax,[si] 4. Stack Addressing push ax 5. Base Addressing mov ax,[bx] Leendert Viljoen 61269921 COS2621 2021 Nov Exam Question 5 1. Computer Architecture: The attributes of a system visible to a programmer in order words, those attributes that have a direct impact on the logical execution of a program. 2. Computer Organization: The operational units and their interconnections that realize the architectural specifications. 1. Program Counter (PC) – contains the address of the next instruction pair to be fetched from memory. 2. Instruction Register (IR) – contains the 8-bit opcode instruction being executed. 3. Instruction Buffer Register (IBR) – temporarily holds the right-hand instruction from a word in memory. 4. Accumulator (AC) and multiplier Quotient (MQ) – temporarily holds operands and results of ALU operations. bits 16 org 100h array times 10 db 0 ; reserve space for 10 chars in array a: dw 0002 b: dw 0003 c: dw 0005 main: mov si, array ; move array into destination index mov bx, 0 loop: inc bx cmp bx, 10 ; compare bx value to 10 jg next ; jump to next if bx is > 10 (i.e., end of loop condition) cmp [a], bx ; compare A to i je then ; jump to 'then' if equal Leendert Viljoen 61269921 COS2621 2021 Nov Exam cmp [c], bx ; compare C to i jne then ; jump to 'then' if not equal je else ; jump to 'else' if equal then: mov ax, [a] ; copy A to ax inc ax ; A + 1 mov [bx+si], ax ; copy ax to specific index in array [array start+current iteration] jmp loop ; do next iteration else: mov ax, [b] ; copy B to ax cmp [a], ax ; compare A to b je loop ; if equal do next iteration of loop dec ax ; B - 1 mov [bx+si], ax ; copy ax to specific index in array [array start+current iteration] jmp loop next: int 20h ; terminate Question 6 (1𝑥24) + (1𝑥23) + (1𝑥22) + (1𝑥2−2) + (1𝑥2−3) 16 + 8 + 4 + 0.25 + 0.125 = 28.375 (1𝑥25) + (1𝑥24) + (1𝑥2) + 1 + (1𝑥2−1) + (1𝑥24) + (1𝑥2−5) 32 + 16 + 2 + 1 + 0.5 + 0.0625 + 0.03125 51.59375 (1𝑥27) + (1𝑥25) + (1𝑥23) + (1𝑥2) + (1𝑥2−1) + (1𝑥2−3) 128 + 32 + 8 + 2 + 0.5 + 0.125 170.625 i. D52 = 1101 0101 0010, (D = 1101, 5 = 0101, 2 = 0010) ii. 67E = 110 0111 1110, (6 = 0110, 7 = 0111, E = 1110) iii. ABCD = 1010 1011 1100 1101 (A = 1010, B = 1011, C = 1100, D = 1101) iv. DF5A4 = 1101 1111 0110 1010 0100 (D = 1101, F = 1111, 5 = 0110, A = 1010, 4 = 0100)","libVersion":"0.2.3","langs":""}